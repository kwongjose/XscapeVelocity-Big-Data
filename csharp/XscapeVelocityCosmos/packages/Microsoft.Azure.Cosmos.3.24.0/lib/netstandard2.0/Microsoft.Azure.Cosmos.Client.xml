<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Azure.Cosmos.Client</name>
    </assembly>
    <members>
        <member name="M:Microsoft.Azure.Cosmos.AuthorizationHelper.OptimizedConvertToBase64string(System.Byte[],System.Boolean)">
            <summary>
            This an optimized version of doing Convert.ToBase64String(hashPayLoad) with an optional wrapping HttpUtility.UrlEncode.
            This avoids the over head of converting it to a string and back to a byte[].
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.AuthorizationHelper.UrlEncodeBase64SpanInPlace(System.Span{System.Byte},System.Int32)">
            <summary>
            This does HttpUtility.UrlEncode functionality with Span buffer. It does an in place update to avoid
            creating the new buffer.
            </summary>
            <param name="base64Bytes">The buffer that include the bytes to url encode.</param>
            <param name="length">The length of bytes used in the buffer</param>
            <returns>The URLEncoded string of the bytes in the buffer</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ICosmosAuthorizationTokenProvider">
            <summary>
            Interface that provides Authorization token headers for requests given
            a particular request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ICosmosAuthorizationTokenProvider.GetUserAuthorizationTokenAsync(System.String,System.String,System.String,Microsoft.Azure.Documents.Collections.INameValueCollection,Microsoft.Azure.Documents.AuthorizationTokenType,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Generates a Authorization Token for a given resource type, address and action.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.SecureStringHMACSHA256Helper">
            <summary>
            Manufactures SHA256 HMACs of byte payloads using a key. The key is a Base64-encoded SecureString.
            In keeping with the goals of SecureString, neither the original Base64 characters nor the decoded 
            bytes ever enters the managed heap, and they are kept decrypted in native memory for as short a 
            time as possible: just the duration of a single ComputeHash call.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.SecureStringHMACSHA256Helper.ComputeHash(System.ArraySegment{System.Byte})">
            <summary>
            Decode the SecureString containing the Base64-encoded key into native memory, compute the
            SHA256 HMAC of the payload, and destroy the native memory containing the decoded key.
            </summary>
            <param name="bytesToHash">payload that is hashed</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TokenCredentialCache">
            <summary>
            This is a token credential cache. 
            It starts a background task that refreshes the token at a set interval. 
            This way refreshing the token does not cause additional latency and also
            allows for transient issue to resolve before the token expires.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Base64Helper.SecureStringToNativeBytes(System.Security.SecureString,System.Int32,System.IntPtr@,System.UInt32@)">
            <summary>
            Interprets <paramref name="secureString"/> as a Base64 string, and decodes it into a native byte array,
            which it returns.
            Avoids loading either the original Base64 or decoded binary into managed heap.
            </summary>
            <param name="secureString">Base64 string to decode</param>
            <param name="secureStringLength">Length of the Base64 string to decode</param>
            <param name="bytes">
              An IntPtr allocated with Marshal.AllocCoTaskMem, which, when the user is done, 
              MUST be zeroed out and then freed with Marshal.FreeCoTaskMem by the caller.
            </param>
            <param name="bytesLength">Number of bytes in the decoded binary currentCharacter</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchAsyncBatcher">
            <summary>
            Maintains a batch of operations and dispatches it as a unit of work.
            </summary>
            <remarks>
            The dispatch process consists of:
            1. Creating a <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest"/>.
            2. Verifying overflow that might happen due to HybridRow serialization. Any operations that did not fit, get sent to the <see cref="T:Microsoft.Azure.Cosmos.BatchAsyncBatcherRetryDelegate"/>.
            3. Execution of the request gets delegated to <see cref="T:Microsoft.Azure.Cosmos.BatchAsyncBatcherExecuteDelegate"/>.
            4. If there was a split detected, all operations in the request, are sent to the <see cref="T:Microsoft.Azure.Cosmos.BatchAsyncBatcherRetryDelegate"/> for re-queueing.
            5. The result of the request is used to wire up all responses with the original Tasks for each operation.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.ItemBatchOperation"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchAsyncBatcherExecuteDelegate">
            <summary>
            Executor implementation that processes a list of operations.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchAsyncBatcherRetryDelegate">
            <summary>
            Delegate to process a request for retry an operation
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchAsyncContainerExecutor">
            <summary>
            Bulk batch executor for operations in the same container.
            </summary>
            <remarks>
            It maintains one <see cref="T:Microsoft.Azure.Cosmos.BatchAsyncStreamer"/> for each Partition Key Range, which allows independent execution of requests.
            Semaphores are in place to rate limit the operations at the Streamer / Partition Key Range level, this means that we can send parallel and independent requests to different Partition Key Ranges, but for the same Range, requests will be limited.
            Two delegate implementations define how a particular request should be executed, and how operations should be retried. When the <see cref="T:Microsoft.Azure.Cosmos.BatchAsyncStreamer"/> dispatches a batch, the batch will create a request and call the execute delegate, if conditions are met, it might call the retry delegate.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.BatchAsyncStreamer"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchAsyncContainerExecutor.#ctor">
            <summary>
            For unit testing.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchAsyncContainerExecutorCache">
            <summary>
            Cache to create and share Executor instances across the client's lifetime.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchAsyncStreamer">
            <summary>
            Handles operation queueing and dispatching.
            Fills batches efficiently and maintains a timer for early dispatching in case of partially-filled batches and to optimize for throughput.
            </summary>
            <remarks>
            There is always one batch at a time being filled. Locking is in place to avoid concurrent threads trying to Add operations while the timer might be Dispatching the current batch.
            The current batch is dispatched and a new one is readied to be filled by new operations, the dispatched batch runs independently through a fire and forget pattern.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.BatchAsyncBatcher"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchCore.#ctor(Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.PartitionKey)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.BatchCore"/> class.
            </summary>
            <param name="container">Container that has items on which batch operations are to be performed.</param>
            <param name="partitionKey">The partition key for all items in the batch. <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/>.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchCore.ExecuteAsync(Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Executes the batch at the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">Options that apply to the batch.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>An awaitable <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchResponse"/> which contains the completion status and results of each operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchCore.PatchItemStream(System.String,System.IO.Stream,Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions)">
            <summary>
            Adds an operation to patch an item into the batch.
            </summary>
            <param name="id">The cosmos item id.</param>
            <param name="patchStream">A <see cref="T:System.IO.Stream"/> containing the patch specification.</param>
            <param name="requestOptions">(Optional) The options for the patch request. <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions"/>.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/> instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchCore.PatchItem(System.String,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.PatchOperation},Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions)">
            <summary>
            Adds an operation to patch an item into the batch.
            </summary>
            <param name="id">The cosmos item id.</param>
            <param name="patchOperations">Represents a list of operations to be sequentially applied to the referred Cosmos item.</param>
            <param name="requestOptions">(Optional) The options for the Patch request. <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions"/>.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/> instance with the operation added.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BatchExecUtils">
            <summary>
            Util methods for batch requests.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchExecUtils.StreamToMemoryAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Converts a Stream to a Memory{byte} wrapping a byte array.
            </summary>
            <param name="stream">Stream to be converted to bytes.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> to cancel the operation.</param>
            <returns>A Memory{byte}.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchExecutor.ExecuteServerRequestAsync(Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest,Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            Makes a single batch request to the server.
            </summary>
            <param name="serverRequest">A server request with a set of operations on items.</param>
            <param name="trace">The trace.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>Response from the server.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.BatchPartitionMetric.#ctor(System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the OperationMetrics class (instance constructor).
            </summary>
            <param name="numberOfItemsOperatedOn">Number of documents operated on.</param>
            <param name="timeTakenInMilliseconds">Amount of time taken to insert the documents.</param>
            <param name="numberOfThrottles">The number of throttles encountered to insert the documents.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BatchPartitionMetric.NumberOfItemsOperatedOn">
            <summary>
            Gets the number of documents operated on.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BatchPartitionMetric.TimeTakenInMilliseconds">
            <summary>
            Gets the time taken to operate on the documents.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BatchPartitionMetric.NumberOfThrottles">
            <summary>
            Gets the number of throttles incurred while operating on the documents.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ItemBatchOperation">
            <summary>
            Represents an operation on an item which will be executed as part of a batch request
            on a container.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemBatchOperation.Context">
            <summary>
            Operational context used in stream operations.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.BatchAsyncBatcher"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.BatchAsyncStreamer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.BatchAsyncContainerExecutor"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperation.Dispose">
            <summary>
            Disposes the current <see cref="T:Microsoft.Azure.Cosmos.ItemBatchOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperation.GetApproximateSerializedLength">
            <summary>
            Computes and returns an approximation for the length of this <see cref="T:Microsoft.Azure.Cosmos.ItemBatchOperation"/>.
            when serialized.
            </summary>
            <returns>An under-estimate of the length.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperation.MaterializeResourceAsync(Microsoft.Azure.Cosmos.CosmosSerializerCore,System.Threading.CancellationToken)">
            <summary>
            Materializes the operation's resource into a Memory{byte} wrapping a byte array.
            </summary>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> for cancellation.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperation.AttachContext(Microsoft.Azure.Cosmos.ItemBatchOperationContext)">
            <summary>
            Attached a context to the current operation to track resolution.
            </summary>
            <exception cref="T:System.InvalidOperationException">If the operation already had an attached context.</exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperation.Dispose(System.Boolean)">
            <summary>
            Disposes the disposable members held by this class.
            </summary>
            <param name="disposing">Indicates whether to dispose managed resources or not.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperation`1.MaterializeResourceAsync(Microsoft.Azure.Cosmos.CosmosSerializerCore,System.Threading.CancellationToken)">
            <summary>
            Materializes the operation's resource into a Memory{byte} wrapping a byte array.
            </summary>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> for cancellation.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ItemBatchOperationContext">
            <summary>
            Context for a particular Batch operation.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemBatchOperationContext.ShouldRetryAsync(Microsoft.Azure.Cosmos.TransactionalBatchOperationResult,System.Threading.CancellationToken)">
            <summary>
            Based on the Retry Policy, if a failed response should retry.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse">
            <summary>
            Response of a cross partition key batch request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.#ctor(System.Int32,Microsoft.Azure.Cosmos.TransactionalBatchResponse,Microsoft.Azure.Cosmos.CosmosSerializerCore)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse"/> class.
            </summary>
            <param name="originalOperationsCount">Original operations that generated the server responses.</param>
            <param name="serverResponse">Response from the server.</param>
            <param name="serializerCore">Serializer to deserialize response resource body streams.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.ActivityId">
            <summary>
            Gets the ActivityId that identifies the server request made to execute the batch request.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.Diagnostics">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.Count">
            <summary>
            Gets the number of operation results.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.GetOperationResultAtIndex``1(System.Int32)">
            <summary>
            Gets the result of the operation at the provided index in the batch - the returned result has a Resource of provided type.
            </summary>
            <typeparam name="T">Type to which the Resource in the operation result needs to be deserialized to, when present.</typeparam>
            <param name="index">0-based index of the operation in the batch whose result needs to be returned.</param>
            <returns>Result of batch operation that contains a Resource deserialized to specified type.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.GetEnumerator">
            <summary>
            Gets an enumerator over the operation results.
            </summary>
            <returns>Enumerator over the operation results.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeBatchResponse.Dispose(System.Boolean)">
            <summary>
            Disposes the disposable members held.
            </summary>
            <param name="disposing">Indicates whether to dispose managed resources or not.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest.#ctor(System.String,System.Boolean,System.String,System.Int32,System.Int32,Microsoft.Azure.Cosmos.CosmosSerializerCore)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest"/> class.
            </summary>
            <param name="partitionKeyRangeId">The partition key range id associated with all requests.</param>
            <param name="isClientEncrypted"> If the operation has Encrypted data. </param>
            <param name="intendedCollectionRidValue"> Intended Collection Rid value. </param>
            <param name="maxBodyLength">Maximum length allowed for the request body.</param>
            <param name="maxOperationCount">Maximum number of operations allowed in the request.</param>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest.PartitionKeyRangeId">
            <summary>
             Gets the PartitionKeyRangeId that applies to all operations in this request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest.CreateAsync(System.String,System.ArraySegment{Microsoft.Azure.Cosmos.ItemBatchOperation},System.Int32,System.Int32,System.Boolean,Microsoft.Azure.Cosmos.CosmosSerializerCore,System.Boolean,System.String,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest"/>.
            In case of direct mode requests, all the operations are expected to belong to the same PartitionKeyRange.
            The body of the request is populated with operations till it reaches the provided maxBodyLength.
            </summary>
            <param name="partitionKeyRangeId">The partition key range id associated with all requests.</param>
            <param name="operations">Operations to be added into this batch request.</param>
            <param name="maxBodyLength">Desired maximum length of the request body.</param>
            <param name="maxOperationCount">Maximum number of operations allowed in the request.</param>
            <param name="ensureContinuousOperationIndexes">Whether to stop adding operations to the request once there is non-continuity in the operation indexes.</param>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
            <param name="isClientEncrypted"> Indicates if the request has encrypted data. </param>
            <param name="intendedCollectionRidValue"> The intended collection Rid value. </param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A newly created instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyRangeServerBatchRequest"/> and the overflow ItemBatchOperation not being processed.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ServerBatchRequest.#ctor(System.Int32,System.Int32,Microsoft.Azure.Cosmos.CosmosSerializerCore)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ServerBatchRequest"/> class.
            </summary>
            <param name="maxBodyLength">Maximum length allowed for the request body.</param>
            <param name="maxOperationCount">Maximum number of operations allowed in the request.</param>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ServerBatchRequest.TransferBodyStream">
            <summary>
            Returns the body Stream.
            Caller is responsible for disposing it after use.
            </summary>
            <returns>Body stream.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ServerBatchRequest.CreateBodyStreamAsync(System.ArraySegment{Microsoft.Azure.Cosmos.ItemBatchOperation},System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Adds as many operations as possible from the provided list of operations
            in the list order while having the body stream not exceed maxBodySize.
            </summary>
            <param name="operations">Operations to be added; read-only.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <param name="ensureContinuousOperationIndexes">Whether to stop adding operations to the request once there is non-continuity in the operation indexes.</param>
            <returns>Any pending operations that were not included in the request.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest.#ctor(System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},Microsoft.Azure.Cosmos.CosmosSerializerCore)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest"/> class.
            Single partition key server request.
            </summary>
            <param name="partitionKey">Partition key that applies to all operations in this request.</param>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest.PartitionKey">
            <summary>
             PartitionKey that applies to all operations in this request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest.CreateAsync(System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},System.ArraySegment{Microsoft.Azure.Cosmos.ItemBatchOperation},Microsoft.Azure.Cosmos.CosmosSerializerCore,Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of <see cref="T:Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest"/>.
            The body of the request is populated with operations till it reaches the provided maxBodyLength.
            </summary>
            <param name="partitionKey">Partition key of the request.</param>
            <param name="operations">Operations to be added into this batch request.</param>
            <param name="serializerCore">Serializer to serialize user provided objects to JSON.</param>
            <param name="trace">The trace.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A newly created instance of <see cref="T:Microsoft.Azure.Cosmos.SinglePartitionKeyServerBatchRequest"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatch">
             <summary>
             Represents a batch of operations against items with the same <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> in a container that
             will be performed in a transactional manner at the Azure Cosmos DB service.
             Use <see cref="M:Microsoft.Azure.Cosmos.Container.CreateTransactionalBatch(Microsoft.Azure.Cosmos.PartitionKey)"/> to create an instance of TransactionalBatch.
             </summary>
             <example>
             This example atomically modifies a set of documents as a batch.
             <code language="c#">
             <![CDATA[
             public class ToDoActivity
             {
                 public string type { get; set; }
                 public string id { get; set; }
                 public string status { get; set; }
             }
            
             string activityType = "personal";
             ToDoActivity test1 = new ToDoActivity()
             {
                 type = activityType,
                 id = "learning",
                 status = "ToBeDone"
             };
            
             ToDoActivity test2 = new ToDoActivity()
             {
                 type = activityType,
                 id = "shopping",
                 status = "Done"
             };
            
             ToDoActivity test3 = new ToDoActivity()
             {
                 type = activityType,
                 id = "swimming",
                 status = "ToBeDone"
             };
            
             ToDoActivity test4 = new ToDoActivity()
             {
                 type = activityType,
                 id = "running",
                 status = "ToBeDone"
             };
            
             List<PatchOperation> patchOperations = new List<PatchOperation>();
             patchOperations.Add(PatchOperation.Replace("/status", "InProgress");
             patchOperations.Add(PatchOperation.Add("/progress", 50);
             
             using (TransactionalBatchResponse batchResponse = await container.CreateTransactionalBatch(new Cosmos.PartitionKey(activityType))
                 .CreateItem<ToDoActivity>(test1)
                 .ReplaceItem<ToDoActivity>(test2.id, test2)
                 .UpsertItem<ToDoActivity>(test3)
                 .PatchItem(test4.id, patchOperations)
                 .DeleteItem("reading")
                 .CreateItemStream(streamPayload1)
                 .ReplaceItemStream("eating", streamPayload2)
                 .UpsertItemStream(streamPayload3)
                 .ExecuteAsync())
             {
                if (!batchResponse.IsSuccessStatusCode)
                {
                    // Handle and log exception
                    return;
                }
            
                // Look up interested results - eg. via typed access on operation results
                TransactionalBatchOperationResult<ToDoActivity> replaceResult = batchResponse.GetOperationResultAtIndex<ToDoActivity>(0);
                ToDoActivity readActivity = replaceResult.Resource;
             }
             ]]>
             </code>
             </example>
             <example>
             This example atomically reads a set of documents as a batch.
             <code language="c#">
             <![CDATA[
             string activityType = "personal";
             using (TransactionalBatchResponse batchResponse = await container.CreateTransactionalBatch(new Cosmos.PartitionKey(activityType))
                .ReadItem("playing")
                .ReadItem("walking")
                .ReadItem("jogging")
                .ReadItem("running")
                .ExecuteAsync())
             {
                 // Look up interested results - eg. via direct access to operation result stream
                 List<string> resultItems = new List<string>();
                 foreach (TransactionalBatchOperationResult operationResult in batchResponse)
                 {
                     using (StreamReader streamReader = new StreamReader(operationResult.ResourceStream))
                     {
                         resultItems.Add(await streamReader.ReadToEndAsync());
                     }
                 }
             }
             ]]>
             </code>
             </example>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/concepts-limits">Limits on TransactionalBatch requests</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.CreateItem``1(``0,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to create an item into the batch.
            </summary>
            <param name="item">A JSON serializable object that must contain an id property. See <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> to implement a custom serializer.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
            <typeparam name="T">The type of item to be created.</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.CreateItemStream(System.IO.Stream,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to create an item into the batch.
            </summary>
            <param name="streamPayload">
            A Stream containing the payload of the item.
            The stream must have a UTF-8 encoded JSON object which contains an id property.
            </param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.ReadItem(System.String,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to read an item into the batch.
            </summary>
            <param name="id">The unique id of the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.UpsertItem``1(``0,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to upsert an item into the batch.
            </summary>
            <param name="item">A JSON serializable object that must contain an id property. See <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> to implement a custom serializer.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
            <typeparam name="T">The type of item to be created.</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.UpsertItemStream(System.IO.Stream,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to upsert an item into the batch.
            </summary>
            <param name="streamPayload">
            A Stream containing the payload of the item.
            The stream must have a UTF-8 encoded JSON object which contains an id property.
            </param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.ReplaceItem``1(System.String,``0,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to replace an item into the batch.
            </summary>
            <param name="id">The unique id of the item.</param>
            <param name="item">A JSON serializable object that must contain an id property. See <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> to implement a custom serializer.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
            <typeparam name="T">The type of item to be created.</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.ReplaceItemStream(System.String,System.IO.Stream,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to replace an item into the batch.
            </summary>
            <param name="id">The unique id of the item.</param>
            <param name="streamPayload">
            A Stream containing the payload of the item.
            The stream must have a UTF-8 encoded JSON object which contains an id property.
            </param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.DeleteItem(System.String,Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions)">
            <summary>
            Adds an operation to delete an item into the batch.
            </summary>
            <param name="id">The unique id of the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.PatchItem(System.String,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.PatchOperation},Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions)">
            <summary>
            Adds an operation to patch an item into the batch.
            </summary>
            <param name="id">The unique id of the item.</param>
            <param name="patchOperations">Represents a list of operations to be sequentially applied to the referred Cosmos item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <returns>The transactional batch instance with the operation added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.ExecuteAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the transactional batch at the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="cancellationToken">(Optional) Cancellation token representing request cancellation.</param>
            <returns>An awaitable response which contains details of execution of the transactional batch.
            <para>
            If the transactional batch executes successfully, the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode"/> on the response returned
            will be set to <see cref="F:System.Net.HttpStatusCode.OK"/>.
            </para>
            <para>
            If an operation within the transactional batch fails during execution, no changes from the batch will be committed
            and the status of the failing operation is made available in the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode"/>.
            To get more details about the operation that failed, the response can be enumerated - this returns <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult" />
            instances corresponding to each operation in the transactional batch in the order they were added into the transactional batch.
            For a result corresponding to an operation within the transactional batch, the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.StatusCode"/> indicates
            the status of the operation - if the operation was not executed or it was aborted due to the failure of another operation within the transactional batch,
            the value of this field will be HTTP 424 (Failed Dependency); for the operation that caused the batch to abort, the value of this field will indicate
            the cause of failure as a HTTP status code.
            </para>
            <para>
            The <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode"/> on the response returned may also have values such as HTTP 5xx in case of server errors and HTTP 429 (Too Many Requests).
            </para>
            </returns>
            <remarks>
            This API only throws on client side exceptions. This is to increase performance and prevent the overhead of throwing exceptions.
            Use <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.IsSuccessStatusCode"/> on the response returned to ensure that the transactional batch succeeded.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatch.ExecuteAsync(Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Executes the transactional batch at the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">Options that apply specifically to batch request.</param>
            <param name="cancellationToken">(Optional) Cancellation token representing request cancellation.</param>
            <returns>An awaitable response which contains details of execution of the transactional batch.
            <para>
            If the transactional batch executes successfully, the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode"/> on the response returned
            will be set to <see cref="F:System.Net.HttpStatusCode.OK"/>.
            </para>
            <para>
            If an operation within the transactional batch fails during execution, no changes from the batch will be committed
            and the status of the failing operation is made available in the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode"/>.
            To get more details about the operation that failed, the response can be enumerated - this returns <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult" />
            instances corresponding to each operation in the transactional batch in the order they were added into the transactional batch.
            For a result corresponding to an operation within the transactional batch, the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.StatusCode"/> indicates
            the status of the operation - if the operation was not executed or it was aborted due to the failure of another operation within the transactional batch,
            the value of this field will be HTTP 424 (Failed Dependency); for the operation that caused the batch to abort, the value of this field will indicate
            the cause of failure as a HTTP status code.
            </para>
            <para>
            The <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode"/> on the response returned may also have values such as HTTP 5xx in case of server errors and HTTP 429 (Too Many Requests).
            </para>
            </returns>
            <remarks>
            This API only throws on client side exceptions. This is to increase performance and prevent the overhead of throwing exceptions.
            Use <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.IsSuccessStatusCode"/> on the response returned to ensure that the transactional batch succeeded.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.RequestOptions"/> that applies to an operation within a <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions.IndexingDirective">
            <summary>
            Gets or sets the indexing directive (Include or Exclude) for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The indexing directive to use with a request.
            </value>
            <seealso cref="T:Microsoft.Azure.Cosmos.IndexingPolicy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions.EnableContentResponseOnWrite">
            <summary>
            Gets or sets the boolean to only return the headers and status code in
            the Cosmos DB response for write item operations like Create, Upsert and Replace.
            This removes the resource from the response. This reduces networking and CPU load by not sending
            the resource back over the network and serializing it on the client.
            </summary>
            <remarks>
            This is optimal for workloads where the returned resource is not used.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult">
            <summary>
            Represents a result for a specific operation that was part of a <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/> request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.StatusCode">
            <summary>
            Gets the completion status of the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.IsSuccessStatusCode">
            <summary>
            Gets a value indicating whether the current operation completed successfully.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.ETag">
            <summary>
            Gets the entity tag associated with the resource.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.ResourceStream">
            <summary>
            Gets the content of the resource.
            </summary>
            <value>
            The content of the resource as a Stream.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.RetryAfter">
            <summary>
            In case the operation is rate limited, indicates the time post which a retry can be attempted.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.RequestCharge">
            <summary>
            Request charge in request units for the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.SubStatusCode">
            <summary>
            Gets detail on the completion status of the operation.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.SessionToken">
            <summary>
            Gets the SessionToken assigned to this result, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult.ActivityId">
            <summary>
            ActivityId related to the operation
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult`1">
            <summary>
            Represents a result for a specific operation that is part of a batch.
            </summary>
            <typeparam name="T">The type of the Resource which this class wraps.</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult`1.#ctor(Microsoft.Azure.Cosmos.TransactionalBatchOperationResult,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult`1"/> class.
            </summary>
            <param name="result">BatchOperationResult with stream resource.</param>
            <param name="resource">Deserialized resource.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult`1"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchOperationResult`1.Resource">
            <summary>
            Gets the content of the resource.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions">
            <summary>
            Cosmos Batch Patch request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions.FilterPredicate">
            <summary>
            Gets or sets condition to be checked before the patch operations in the Azure Cosmos DB service.
            </summary>
            <value>
            The condition to be checked before execution of operations.
            </value>
            <remarks>
            Condition can only be a sql statement.
            Creates a conditional SQL argument which is of format from-clause,
            the condition has to be within the scope of the document which is supposed to be patched in the particular request.
            If the condition is satisfied (given document meets the given from-clause SQL statement),
            the patch transaction will take place otherwise it will be returned with precondition failed.
            </remarks>
            <sample>
            TransactionalBatchPatchItemRequestOptions requestOptions = new TransactionalBatchPatchItemRequestOptions()
               {
                   FilterPredicate = "from c where c.taskNum = 3"
               };
            </sample>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions">
            <summary>
            Cosmos batch request options.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions.SessionToken">
             <summary>
             Gets or sets the token for use with session consistency in the Azure Cosmos DB service.
             </summary>
             <value>
             The token for use with session consistency.
             </value>
            
             <remarks>
             One of the <see cref="P:Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions.ConsistencyLevel"/> for Azure Cosmos DB is Session. In fact, this is the default level applied to accounts.
             <para>
             When working with Session consistency, each batch request with write operation to Azure Cosmos DB is assigned a new SessionToken.
             The CosmosClient will use this token internally with each read/query/batch request to ensure that the set
             consistency level is maintained.
            
             <para>
             In some scenarios you need to manage this Session yourself;
             Consider a web application with multiple nodes, each node will have its own instance of <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>
             If you wanted these nodes to participate in the same session (to be able read your own writes consistently across web tiers)
             you would have to send the SessionToken from <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchResponse"/> of the write action on one node
             to the client tier, using a cookie or some other mechanism, and have that token flow back to the web tier for subsequent reads.
             If you are using a round-robin load balancer which does not maintain session affinity between requests, such as the Azure Load Balancer,
             the read could potentially land on a different node to the write request, where the session was created.
             </para>
            
             <para>
             If you do not flow the Azure Cosmos DB SessionToken across as described above you could end up with inconsistent read results for a period of time.
             </para>
            
             </para>
             <see href="https://docs.microsoft.com/azure/cosmos-db/consistency-levels" />
             </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions.ConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            Azure Cosmos DB offers 5 different consistency levels. Strong, Bounded Staleness, Session, Consistent Prefix and Eventual - in order of strongest to weakest consistency. <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
            <para>
            While this is set at a database account level, Azure Cosmos DB allows a developer to override the default consistency level
            for each individual request.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TransactionalBatchResponse">
            <summary>
            Response of a <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/> request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Documents.SubStatusCodes,System.String,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.ItemBatchOperation},Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchResponse"/> class.
            This method is intended to be used only when a response from the server is not available.
            </summary>
            <param name="statusCode">Indicates why the batch was not processed.</param>
            <param name="subStatusCode">Provides further details about why the batch was not processed.</param>
            <param name="errorMessage">The reason for failure.</param>
            <param name="operations">Operations that were to be executed.</param>
            <param name="trace">Diagnostics for the operation</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchResponse"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.Headers">
            <summary>
            Gets the current HTTP headers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.ActivityId">
            <summary>
            Gets the ActivityId that identifies the server request made to execute the batch.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.RequestCharge">
            <summary>
            Gets the request charge for the batch request.
            </summary>
            <value>
            The request charge measured in request units.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.RetryAfter">
            <summary>
            Gets the amount of time to wait before retrying this or any other request within Cosmos container or collection due to throttling.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.StatusCode">
            <summary>
            Gets the completion status code of the batch request.
            </summary>
            <value>The request completion status code.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.ErrorMessage">
            <summary>
            Gets the reason for failure of the batch request.
            </summary>
            <value>The reason for failure, if any.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.IsSuccessStatusCode">
            <summary>
            Gets a value indicating whether the batch was processed.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.Count">
            <summary>
            Gets the number of operation results.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.Diagnostics">
            <summary>
            Gets the cosmos diagnostic information for the current request to Azure Cosmos DB service
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TransactionalBatchResponse.Item(System.Int32)">
            <summary>
            Gets the result of the operation at the provided index in the batch.
            </summary>
            <param name="index">0-based index of the operation in the batch whose result needs to be returned.</param>
            <returns>Result of operation at the provided index in the batch.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.GetOperationResultAtIndex``1(System.Int32)">
            <summary>
            Gets the result of the operation at the provided index in the batch - the returned result has a Resource of provided type.
            </summary>
            <typeparam name="T">Type to which the Resource in the operation result needs to be deserialized to, when present.</typeparam>
            <param name="index">0-based index of the operation in the batch whose result needs to be returned.</param>
            <returns>Result of batch operation that contains a Resource deserialized to specified type.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.GetEnumerator">
            <summary>
            Gets an enumerator over the operation results.
            </summary>
            <returns>Enumerator over the operation results.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.GetActivityIds">
            <summary>
            Gets all the Activity IDs associated with the response.
            </summary>
            <returns>An enumerable that contains the Activity IDs.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.Dispose">
            <summary>
            Disposes the current <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatchResponse"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TransactionalBatchResponse.Dispose(System.Boolean)">
            <summary>
            Disposes the disposable members held by this class.
            </summary>
            <param name="disposing">Indicates whether to dispose managed resources or not.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BulkExecutionRetryPolicy">
            <summary>
            Used only in the context of Bulk Stream operations.
            </summary>
            <see cref="T:Microsoft.Azure.Cosmos.BatchAsyncBatcher"/>
            <see cref="T:Microsoft.Azure.Cosmos.ItemBatchOperationContext"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedOptions">
            <summary>
            Specifies the options associated with change feed methods (enumeration operations) in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.MaxItemCount">
            <summary>
            Gets or sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum number of items to be returned in the enumeration operation.
            </value> 
            <remarks>
            Used for query pagination.
            '-1' Used for dynamic page size.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.RequestContinuation">
            <summary>
            Gets or sets the request continuation token in the Azure Cosmos DB service.
            </summary>
            <value>
            The request continuation token.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.SessionToken">
            <summary>
            Gets or sets the session token for use with session consistency in the Azure Cosmos DB service.
            </summary>
            <value>
            The session token for use with session consistency.
            </value>
            <remarks>
            Useful for applications that are load balanced across multiple Microsoft.Azure.Documents.Client.DocumentClient instances. 
            In this case, round-trip the token from end user to the application and then back to Azure Cosmos DB so that a session
            can be preserved across servers.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.PartitionKeyRangeId">
            <summary>
            Gets or sets the partition key range id for the current request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            ChangeFeed requests can be executed against specific partition key ranges. 
            This is used to process the change feed in parallel across multiple consumers.
            PartitionKeyRangeId cannot be specified along with PartitionKey.
            </remarks>
            <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange" />
            <see cref="M:Microsoft.Azure.Cosmos.DocumentClient.ReadPartitionKeyRangeFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.PartitionKey">
            <summary>
            Gets or sets the partition key for the current request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            PartitionKey cannot be specified along with PartitionKeyRangeId.
            </remarks>
            <see cref="T:Microsoft.Azure.Documents.PartitionKey" />
            <example>
            <![CDATA[
            var options = new ChangeFeedOptions()
            {
                PartitionKey = new PartitionKey("c7580115-8f46-4ac4-a0c7-22eae9aaabf1"),
                StartFromBeginning = true
            };
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.StartFromBeginning">
            <summary>
            Gets or sets a value indicating whether change feed in the Azure Cosmos DB service 
            should start from beginning (true) or from current (false).
            By default it's start from current (false).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.StartTime">
            <summary>
            Gets or sets the time (exclusive) to start looking for changes after.
            If this is specified, StartFromBeginning is ignored.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.IncludeTentativeWrites">
            <summary>
            Gets or sets a value indicating whether change feed in the Azure Cosmos DB service 
            should return tentative writes in addition to committed writes.
            By default the flag is set to false meaning only committed writes will be sent in response.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Bootstrapping.PartitionSynchronizerCore.HandlePartitionGoneAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Handle a Partition Gone response and decide what to do based on the type of lease.
            </summary>
            <returns>Returns the list of leases to create and a boolean that indicates whether or not to remove the current lease.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Bootstrapping.PartitionSynchronizerCore.HandlePartitionGoneAsync(System.String,System.String,Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseCore,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Documents.PartitionKeyRange})">
            <summary>
            Handles splits and merges for partition based leases.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Bootstrapping.PartitionSynchronizerCore.HandlePartitionGoneAsync(System.String,System.String,Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseCoreEpk,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Documents.PartitionKeyRange})">
            <summary>
            Handles splits and merges for feed range based leases.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Bootstrapping.PartitionSynchronizerCore.CreateLeasesAsync(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Documents.PartitionKeyRange})">
            <summary>
            Creates leases if they do not exist. This might happen on initial start or if some lease was unexpectedly lost.
            Leases are created without the continuation token. It means partitions will be read according to 'From Beginning' or
            'From current time'.
            Same applies also to split partitions. We do not search for parent lease and take continuation token since this might end up
            of reprocessing all the events since the split.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedEstimatorIterator.#ctor(Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseContainer,System.Func{Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease,System.String,System.Boolean,Microsoft.Azure.Cosmos.FeedIteratorInternal},Microsoft.Azure.Cosmos.ChangeFeedEstimatorRequestOptions)">
            <summary>
            For testing purposes
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedEstimatorIterator.ExtractLsnFromSessionToken(System.String)">
            <summary>
            Parses a Session Token and extracts the LSN.
            </summary>
            <param name="sessionToken">A Session Token</param>
            <returns>LSN value</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedEstimatorRunner">
            <summary>
            Implementation of the Estimator as a push model.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedEstimatorRunner.#ctor(Microsoft.Azure.Cosmos.Container.ChangesEstimationHandler,System.Nullable{System.TimeSpan},Microsoft.Azure.Cosmos.ChangeFeedEstimator)">
            <summary>
            Used for tests
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions">
            <summary>
            Options to control various aspects of partition distribution happening within <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedProcessorCore"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions" /> class.</summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions.LeaseRenewInterval">
            <summary>
            Gets or sets renew interval for all leases currently held by <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedProcessorCore"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions.LeaseAcquireInterval">
            <summary>
            Gets or sets the interval to kick off a task to compute if leases are distributed evenly among known host instances.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions.LeaseExpirationInterval">
            <summary>
            Gets or sets the interval for which the lease is taken. If the lease is not renewed within this
            interval, it will cause it to expire and ownership of the lease will move to another <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedProcessorCore"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions.LeasePrefix">
            <summary>
            Gets or sets a prefix to be used as part of the lease id. This can be used to support multiple instances of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedProcessorCore"/>
            instances pointing at the same feed while using the same auxiliary collection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions">
            <summary>
            Options to control various aspects of partition distribution happening within <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedProcessorCore"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions" /> class.</summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions.FeedPollDelay">
            <summary>
            Gets or sets the delay in between polling the change feed for new changes, after all current changes are drained.
            <remarks>
            Applies only after a read on the change feed yielded no results.
            </remarks>
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions.MaxItemCount">
            <summary>
            Gets or sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions.StartContinuation">
            <summary>
            Gets or sets the start request continuation token to start looking for changes after.
            </summary>
            <remarks>
            This is only used when lease store is not initialized and is ignored if a lease exists and has continuation token.
            If this is specified, both StartTime and StartFromBeginning are ignored.
            </remarks>
            <seealso cref="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.RequestContinuation"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions.StartTime">
            <summary>
            Gets or sets the time (exclusive) to start looking for changes after.
            </summary>
            <remarks>
            This is only used when:
            (1) Lease store is not initialized and is ignored if a lease exists and has continuation token.
            (2) StartContinuation is not specified.
            If this is specified, StartFromBeginning is ignored.
            </remarks>
            <seealso cref="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.StartTime"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedProcessorOptions.StartFromBeginning">
            <summary>
            Gets or sets a value indicating whether change feed in the Azure Cosmos DB service should start from beginning (true) or from current (false).
            By default it's start from current (false).
            </summary>
            <remarks>
            This is only used when:
            (1) Lease store is not initialized and is ignored if a lease exists and has continuation token.
            (2) StartContinuation is not specified.
            (3) StartTime is not specified.
            </remarks>
            <seealso cref="P:Microsoft.Azure.Cosmos.ChangeFeedOptions.StartFromBeginning"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException">
            <summary>
            Exception occurred during feed processing because of a split.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException"/> class using error message and last continuation token.
            </summary>
            <param name="message">The exception error message.</param>
            <param name="lastContinuation"> Request continuation token.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException" /> class using error message and inner exception.
            </summary>
            <param name="message">The exception error message.</param>
            <param name="lastContinuation">Request continuation token.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException" /> class using default values.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException.LastContinuation">
            <summary>
            Gets the value of request continuation token.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the System.Runtime.Serialization.SerializationInfo with information about the exception.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedRangeGoneException">
            <summary>
            Exception occurred during feed processing because of a partition gone.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedRangeGoneException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedRangeGoneException"/> class using error message and last continuation token.
            </summary>
            <param name="message">The exception error message.</param>
            <param name="lastContinuation"> Request continuation token.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedRangeGoneException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.FeedRangeGoneException" /> class using default values.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException">
            <summary>
            Exception occurred when lease is lost, that would typically happen when it is taken by another host. Other cases: communication failure, number of retries reached, lease not found.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class using the specified lease.
            </summary>
            <param name="lease">Instance of a lost lease.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class using error message.
            </summary>
            <param name="message">The exception error message.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class using error message and inner exception.
            </summary>
            <param name="message">The exception error message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class using the specified lease, and a flag indicating whether lease is gone.
            </summary>
            <param name="lease">Instance of a lost lease.</param>
            <param name="isGone">Whether lease doesn't exist.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease,System.Exception,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class using the specified lease, inner exception, and a flag indicating whether lease is gone.
            </summary>
            <param name="lease">Instance of a lost lease.</param>
            <param name="innerException">The inner exception.</param>
            <param name="isGone">Whether lease doesn't exist.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException" /> class using default values.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.Lease">
            <summary>
            Gets the lost lease.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.IsGone">
            <summary>
            Gets a value indicating whether lease doesn't exist.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the System.Runtime.Serialization.SerializationInfo with information about the exception.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.LeaseRenewer.RunAsync(System.Threading.CancellationToken)">
            <summary>
            Starts the lease renewer
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.LoadBalancingStrategy">
             <summary>
             A strategy defines which leases should be taken by the current host in a certain moment.
             </summary>
             <remarks>
             It can set new <see cref="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.Properties"/> for all returned leases if needed, including currently owned leases.
             </remarks>
             <example>
             <code language="C#">
             <![CDATA[
             public class CustomStrategy : LoadBalancingStrategy
             {
                 private string hostName;
                 private string hostVersion;
                 private TimeSpan leaseExpirationInterval;
            
                 private const string VersionPropertyKey = "version";
            
                 public IEnumerable<DocumentServiceLease> SelectLeasesToTake(IEnumerable<DocumentServiceLease> allLeases)
                 {
                     var takenLeases = this.FindLeasesToTake(allLeases);
                     foreach (var lease in takenLeases)
                     {
                         lease.Properties[VersionPropertyKey] = this.hostVersion;
                     }
            
                     return takenLeases;
                 }
            
                 private IEnumerable<ILease> FindLeasesToTake(IEnumerable<DocumentServiceLease> allLeases)
                 {
                     List<DocumentServiceLease> takenLeases = new List<DocumentServiceLease>();
                     foreach (var lease in allLeases)
                     {
                         if (string.IsNullOrWhiteSpace(lease.Owner) || this.IsExpired(lease))
                         {
                             takenLeases.Add(lease);
                         }
            
                         if (lease.Owner != this.hostName)
                         {
                             var ownerVersion = lease.Properties[VersionPropertyKey];
                             if (ownerVersion < this.hostVersion)
                             {
                                 takenLeases.Add(lease);
                             }
            
                             // more logic for leases owned by other hosts
                         }
                     }
            
                     return takenLeases;
                 }
            
                 private bool IsExpired(DocumentServiceLease lease)
                 {
                     return lease.Timestamp.ToUniversalTime() + this.leaseExpirationInterval < DateTime.UtcNow;
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.LoadBalancingStrategy.SelectLeasesToTake(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease})">
            <summary>
            Select leases that should be taken for processing.
            This method will be called periodically with <see cref="P:Microsoft.Azure.Cosmos.ChangeFeed.Configuration.ChangeFeedLeaseOptions.LeaseAcquireInterval"/>
            </summary>
            <param name="allLeases">All leases</param>
            <returns>Leases that should be taken for processing by this host</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.PartitionCheckpointer.CheckpointPartitionAsync(System.String)">
            <summary>
            Checkpoint the given partition up to the given continuation token.
            </summary>
            <param name="ontinuationToken">Continuation token</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.PartitionLoadBalancer.Start">
            <summary>
            Starts the load balancer
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.PartitionLoadBalancer.StopAsync">
            <summary>
            Stops the load balancer
            </summary>
            <returns>Task that completes once load balancer is fully stopped</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.PartitionSynchronizer">
            <summary>
            Read DocDB partitions and create leases if they do not exist
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedEstimatorRunner">
            <summary>
            Obtains the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedEstimator"/> estimation as a periodic Task and notifies it to a <see cref="T:Microsoft.Azure.Cosmos.Container.ChangesEstimationHandler"/>..
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessor">
            <summary>
            Provides an API to run continuous processing on a single processing unit of some resource.
            Created by <see cref="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessorFactory.Create(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease,Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver)"/> after some lease is acquired by the current host.
            Processing can perform the following tasks in a loop:
              1. Read some data from the resource feed.
              2. Handle possible problems with the read.
              3. Pass the obtained data to an observer by calling <see cref="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver.ProcessChangesAsync(Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverContextCore,System.IO.Stream,System.Threading.CancellationToken)"/> with the context <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessor.RunAsync(System.Threading.CancellationToken)">
            <summary>
            Perform feed processing.
            </summary>
            <param name="cancellationToken">Cancellation token to be used to stop processing</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessorFactory">
            <summary>
            Factory class used to create instance(s) of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessor"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessorFactory.Create(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease,Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver)">
            <summary>
            Creates an instance of a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessor"/>.
            </summary>
            <param name="lease">Lease to be used for feed processing</param>
            <param name="observer">Observer to be used</param>
            <returns>An instance of a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.FeedProcessor"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.CheckpointerObserverFactory">
            <summary>
            Factory class used to create instance(s) of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/> wrapping with the desired checkpoint logic.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.CheckpointerObserverFactory.#ctor(Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverFactory,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.CheckpointerObserverFactory"/> class.
            </summary>
            <param name="observerFactory">Instance of Observer Factory</param>
            <param name="withManualCheckpointing">Should it automatically checkpoint or not.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.FeedProcessing.CheckpointerObserverFactory.CreateObserver">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/> with either automatic checkpoint or manual.
            </summary>
            <returns>Created instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease">
            <summary>
            Represents a lease that is persisted as a document in the lease collection.
            Leases are used to:
            * Keep track of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> progress for a particular Partition Key Range.
            * Distribute load between different instances of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/>.
            * Ensure reliable recovery for cases when an instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> gets disconnected, hangs or crashes.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.CurrentLeaseToken">
            <summary>
            Gets the processing distribution unit identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.FeedRange">
            <summary>
            Gets the range associated with this lease.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.Owner">
            <summary>
            Gets or sets the host name owner of the lease.
            The Owner keeps track which <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> is currently processing that Partition Key Range.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.Timestamp">
            <summary>
            Gets or sets the Timestamp of the lease.
            Timestamp is used to determine lease expiration.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.ContinuationToken">
            <summary>
            Gets or sets the Continuation Token.
            Continuation Token is used to determine the last processed point of the Change Feed.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.Id">
            <summary>
            Gets the lease Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.PartitionKey">
            <summary>
            Gets the lease PartitionKey.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.ConcurrencyToken">
            <summary>
            Gets the Concurrency Token.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease.Properties">
            <summary>
            Gets or sets custom lease properties which can be managed from <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.FeedManagement.LoadBalancingStrategy"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseCheckpointer">
            <summary>
            Used to checkpoint leases.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseCheckpointer.CheckpointAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease,System.String)">
            <summary>
            Checkpoint the lease.
            </summary>
            <param name="lease">Lease to renew</param>
            <param name="continuationToken">Continuation token</param>
            <returns>Updated renewed lease</returns>
            <exception cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException">Thrown if other host acquired the lease or lease was deleted</exception>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseContainer">
            <summary>
            Represents operations to get leases from lease store.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseContainer.GetAllLeasesAsync">
            <summary>
            Get all leases.
            </summary>
            <returns>List of all leases</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseContainer.GetOwnedLeasesAsync">
            <summary>
            Get all the leases owned by the current host.
            </summary>
            <returns>Enumerable of all leases owned by the current host</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseCore">
            <summary>
            Lease implementation for PartitionKeyRange based leases.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseCoreEpk">
            <summary>
            Lease implementation for EPK based leases.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager">
            <summary>
            The DocumentServiceLeaseManager defines a way to perform operations with <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.CreateLeaseIfNotExistAsync(Microsoft.Azure.Documents.PartitionKeyRange,System.String)">
            <summary>
            Checks whether the lease exists and creates it if it does not exist for a physical partition.
            </summary>
            <param name="partitionKeyRange">Partition for the lease.</param>
            <param name="continuationToken">Continuation token if it exists.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.CreateLeaseIfNotExistAsync(Microsoft.Azure.Cosmos.FeedRangeEpk,System.String)">
            <summary>
            Checks whether the lease exists and creates it if it does not exist for a range.
            </summary>
            <param name="feedRange">Feed range for the lease.</param>
            <param name="continuationToken">Continuation token if it exists.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.DeleteAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Delete the lease.
            </summary>
            <param name="lease">Lease to remove.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.AcquireAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Acquire ownership of the lease.
            </summary>
            <param name="lease">Lease to acquire.</param>
            <returns>Updated acquired lease.</returns>
            <exception cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException">Thrown if other host acquired concurrently</exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.ReleaseAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Release ownership of the lease.
            </summary>
            <param name="lease">Lease to acquire.</param>
            <exception cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException">Thrown if other host acquired the lease or lease was deleted</exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.RenewAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Renew the lease. Leases are periodically renewed to prevent expiration.
            </summary>
            <param name="lease">Lease to renew.</param>
            <returns>Updated renewed lease.</returns>
            <exception cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException">Thrown if other host acquired the lease or lease was deleted</exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager.UpdatePropertiesAsync(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease)">
            <summary>
            Replace properties from the specified lease.
            </summary>
            <param name="leaseToUpdatePropertiesFrom">Lease containing new properties</param>
            <returns>Updated lease.</returns>
            <exception cref="T:Microsoft.Azure.Cosmos.ChangeFeed.Exceptions.LeaseLostException">Thrown if other host acquired the lease</exception>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManagerCosmos">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager"/> implementation that uses Azure Cosmos DB service
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManagerInMemory">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseManager"/> implementation that uses In-Memory
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore">
            <summary>
            Represents the lease store container to deal with initialiation/cleanup of leases
            for particular monitoring collection and lease container prefix.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore.IsInitializedAsync">
            <summary>
            Checks if the lease store is initialized.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore.MarkInitializedAsync">
            <summary>
            Mark the store as initialized.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore.AcquireInitializationLockAsync(System.TimeSpan)">
            <summary>
            Places a lock on the lease store for initialization. Only one process may own the store for the lock time.
            </summary>
            <param name="lockExpirationTime">The time for the lock to expire.</param>
            <returns>True if the lock was acquired, false otherwise.</returns>
            <remarks>In order for expiration time work, lease collection needs to have TTL enabled.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore.ReleaseInitializationLockAsync">
            <summary>
            Releases the lock one the lease store for initialization.
            </summary>
            <returns>True if the lock was acquired and was released, false if the lock was not acquired.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreCosmos">
            <summary>
            Implementation of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore"/> for state in Azure Cosmos DB
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreInMemory">
            <summary>
            Implementation of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStore"/> for state in-memory
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManager">
            <summary>
            The DocumentServiceLeaseStoreManager defines a way to perform operations with <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManager.LeaseContainer">
            <summary>
            Represents operations to get leases from lease store.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManager.LeaseManager">
            <summary>
            The DocumentServiceLeaseManager defines a way to perform operations with <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManager.LeaseCheckpointer">
            <summary>
            Used to checkpoint leases.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManager.LeaseStore">
            <summary>
            Represents the lease store container to deal with initialiation/cleanup of leases
            for particular monitoring collection and lease container prefix.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerBuilder">
            <summary>
            Provides flexible way to build lease manager constructor parameters.
            For the actual creation of lease manager instance, delegates to lease manager factory.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerCosmos">
            <summary>
            Lease manager that is using Azure Document Service as lease storage.
            Documents in lease collection are organized as this:
            ChangeFeed.federation|database_rid|collection_rid.info            -- container
            ChangeFeed.federation|database_rid|collection_rid..partitionId1   -- each partition
            ChangeFeed.federation|database_rid|collection_rid..partitionId2
                                                    ...
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerCosmos.#ctor(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerOptions,Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.RequestOptionsFactory,Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseUpdater)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerCosmos"/> class.
            </summary>
            <remarks>
            Internal only for testing purposes, otherwise would be private.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerInMemory">
            <summary>
            Lease manager that is using In-Memory as lease storage.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerInMemory.#ctor(Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseUpdater,System.Collections.Concurrent.ConcurrentDictionary{System.String,Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLease})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerInMemory"/> class.
            </summary>
            <remarks>
            Internal only for testing purposes, otherwise would be private.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseUpdaterCosmos">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseUpdater"/> that uses Azure Cosmos DB
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseUpdaterInMemory">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseUpdater"/> that uses In-Memory
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseVersion">
            <summary>
            Versioning of the lease schema.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.PartitionedByIdCollectionRequestOptionsFactory">
            <summary>
            Used to create request options for partitioned lease collections, when partition key is defined as /id.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.PartitionedByPartitionKeyCollectionRequestOptionsFactory">
            <summary>
            Used to create request options for partitioned lease collections, when partition key is defined as /partitionKey.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.RequestOptionsFactory">
            <summary>
            Defines request options for lease requests to use with <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreManagerCosmos"/> and <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.DocumentServiceLeaseStoreCosmos"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.LeaseManagement.SinglePartitionRequestOptionsFactory">
            <summary>
            Used to create request options for non-partitioned lease collections.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.Monitoring.ChangeFeedProcessorHealthMonitorCore">
            <summary>
            A monitor which uses the default trace
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver">
            <summary>
            This interface is used to deliver change events to document feed observers.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver.OpenAsync(System.String)">
            <summary>
            This is called when change feed observer is opened.
            </summary>
            <param name="leaseToken">Token representing the lease that is starting processing.</param>
            <returns>A Task to allow asynchronous execution.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver.CloseAsync(System.String,Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason)">
            <summary>
            This is called when change feed observer is closed.
            </summary>
            <param name="leaseToken">Token representing the lease that is finishing processing.</param>
            <param name="reason">Specifies the reason the observer is closed.</param>
            <returns>A Task to allow asynchronous execution.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver.ProcessChangesAsync(Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverContextCore,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            This is called when document changes are available on change feed.
            </summary>
            <param name="context">The context specifying partition for this change event, etc.</param>
            <param name="stream">The document streams that contain the change feed events.</param>
            <param name="cancellationToken">Token to signal that the partition processing is going to finish.</param>
            <returns>A Task to allow asynchronous execution.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason">
            <summary>
            The reason for the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/> to close.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.Unknown">
            <summary>
            Unknown failure. This should never be sent to observers.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.Shutdown">
            <summary>
            The ChangeFeedEventHost is shutting down.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.ResourceGone">
            <summary>
            The resource, such as database or collection was removed.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.LeaseLost">
            <summary>
            Lease was lost due to expiration or load-balancing.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.ObserverError">
            <summary>
            IChangeFeedObserver threw an exception.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.LeaseGone">
            <summary>
            The lease is gone. This can be due to partition split.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.ReadSessionNotAvailable">
            <summary>
            Indicates a "read session not available" warning related to <see cref="F:Microsoft.Azure.Cosmos.ConsistencyLevel.Session"/>.
            Note: SDK retries on this error.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverCloseReason.CosmosException">
            <summary>
            Related to a server response
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverContextCore">
            <summary>
            The context passed to <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/> events.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverFactory">
            <summary>
            Factory class used to create instance(s) of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserverFactory.CreateObserver">
            <summary>
            Creates an instance of a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/>.
            </summary>
            <returns>An instance of a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedObserver"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedPartitionKeyResultSetIteratorCore">
            <summary>
            Cosmos Change Feed Iterator for a particular Partition Key Range
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedPartitionKeyResultSetIteratorCore.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A change feed response from cosmos service</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromBeginning">
            <summary>
            Derived instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from the beginning of time.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromBeginning.#ctor(Microsoft.Azure.Cosmos.FeedRangeInternal)">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromBeginning"/> class.
            </summary>
            <param name="feedRange">The (optional) range to start from.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromContinuation">
            <summary>
            Derived instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from a save point.
            </summary>
            <remarks>This class is used to temporarily store the fully serialized composite continuation token and needs to transformed into a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromContinuationAndFeedRange"/>.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromContinuation.#ctor(System.String)">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromContinuation"/> class.
            </summary>
            <param name="continuation">The continuation to resume from.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromContinuation.Continuation">
            <summary>
            Gets the continuation to resume from.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromContinuationAndFeedRange">
            <summary>
            Derived instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading from an LSN for a particular feed range.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromNow">
            <summary>
            Derived instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from this moment onward.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromNow.#ctor(Microsoft.Azure.Cosmos.FeedRangeInternal)">
            <summary>
            Intializes an instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromNow"/> class.
            </summary>
            <param name="feedRange">The (optional) feed range to start from.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromTime">
            <summary>
            Derived instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from some point in time onward.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromTime.#ctor(System.DateTime,Microsoft.Azure.Cosmos.FeedRangeInternal)">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromTime"/> class.
            </summary>
            <param name="time">The time to start reading from.</param>
            <param name="feedRange">The (optional) range to start from.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedStartFromTime.StartTime">
            <summary>
            Gets the time the ChangeFeed operation should start reading from.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.StandByFeedContinuationToken">
            <summary>
            Stand by continuation token representing a contiguous read over all the ranges with continuation state across all ranges.
            </summary>
            <remarks>
            The StandByFeed token represents the state of continuation tokens across all Partition Key Ranges and can be used to sequentially read the Change Feed for each range while maintaining a global state by serializing the values (and allowing deserialization).
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeed.StandByFeedIteratorCore">
            <summary>
            Cosmos Stand-By Feed iterator implementing Composite Continuation Token
            </summary>
            <remarks>
            Legacy, see <see cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedIteratorCore"/>.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.ChangeFeed.ChangeFeedIteratorCore"/>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ChangeFeed.StandByFeedIteratorCore.changeFeedOptions">
            <summary>
            The query options for the result set
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.StandByFeedIteratorCore.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A query response from cosmos service</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeed.StandByFeedIteratorCore.ShouldRetryFailureAsync(Microsoft.Azure.Cosmos.ResponseMessage,System.Threading.CancellationToken)">
            <summary>
            During Feed read, split can happen or Max Item count can go beyond the max response size
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedEstimator">
            <summary>
            Used to estimate the pending work remaining to be read by a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> deployment.
            </summary>
            <remarks>
            The estimator is meant to monitor an existing deployment of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instances that are currently running.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/change-feed-processor"/>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/how-to-use-change-feed-estimator"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedEstimator.GetCurrentStateIterator(Microsoft.Azure.Cosmos.ChangeFeedEstimatorRequestOptions)">
            <summary>
            Gets the estimation per lease in the lease container.
            </summary>
            <param name="changeFeedEstimatorRequestOptions">(Optional) Customize the estimation iterator.</param>
            <returns>An iterator that yields an estimation of pending work in amount of transactions per distributed lease token.</returns>
            <remarks>
            The estimation over the Change Feed identifies volumes of transactions. If operations in the container are performed through stored procedures, transactional batch or bulk, a group of operations may share the same <see href="https://docs.microsoft.com/azure/cosmos-db/stored-procedures-triggers-udfs#transactions">transaction scope</see> and represented by a single transaction. 
            In those cases, the estimation might not exactly represent number of items, but it is still valid to understand if the pending volume is increasing, decreasing, or on a steady state.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor">
            <summary>
            Provides an API to start and stop a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance created by <see cref="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.Build"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessor.StartAsync">
            <summary>
            Start listening for changes.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessor.StopAsync">
            <summary>
            Stops listening for changes.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder">
            <summary>
            Provides a flexible way to create an instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> with custom set of parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithInstanceName(System.String)">
            <summary>
            Sets the Host name.
            </summary>
            <param name="instanceName">Name to be used for the processor instance. When using multiple processor hosts, each host must have a unique name.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithLeaseConfiguration(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
            <summary>
            Sets a custom configuration to be used by this instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> to control how leases are maintained in a container when using <see cref="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithLeaseContainer(Microsoft.Azure.Cosmos.Container)"/>.
            </summary>
            <param name="acquireInterval">Interval to kick off a task to verify if leases are distributed evenly among known host instances.</param>
            <param name="expirationInterval">Interval for which the lease is taken. If the lease is not renewed within this interval, it will cause it to expire and ownership of the lease will move to another processor instance.</param>
            <param name="renewInterval">Renew interval for all leases currently held by a particular processor instance.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithPollInterval(System.TimeSpan)">
            <summary>
            Gets or sets the delay in between polling the change feed for new changes, after all current changes are drained.
            </summary>
            <remarks>
            Applies only after a read on the change feed yielded no results.
            </remarks>
            <param name="pollInterval">Polling interval value.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithStartFromBeginning">
            <summary>
            Indicates whether change feed in the Azure Cosmos DB service should start from beginning.
            By default it's start from current time.
            </summary>
            <remarks>
            This is only used when:
            (1) Lease store is not initialized and is ignored if a lease exists and has continuation token.
            (2) StartContinuation is not specified.
            (3) StartTime is not specified.
            </remarks>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithStartTime(System.DateTime)">
            <summary>
            Sets the time (exclusive) to start looking for changes after.
            </summary>
            <remarks>
            This is only used when:
            (1) Lease store is not initialized and is ignored if a lease exists and has continuation token.
            (2) StartContinuation is not specified.
            If this is specified, StartFromBeginning is ignored.
            </remarks>
            <param name="startTime">Date and time when to start looking for changes.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithMaxItems(System.Int32)">
            <summary>
            Sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
            <param name="maxItemCount">Maximum amount of items to be returned in a Change Feed request.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/>.</returns>
            <remarks>This is just a hint to the server which can return less or more items per page. If operations in the container are performed through stored procedures or transactional batch, <see href="https://docs.microsoft.com/azure/cosmos-db/stored-procedures-triggers-udfs#transactions">transaction scope</see> is preserved when reading items from the Change Feed. As a result, the number of items received could be higher than the specified value so that the items changed by the same transaction are returned as part of one atomic batch.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithLeaseContainer(Microsoft.Azure.Cosmos.Container)">
            <summary>
            Sets the Cosmos Container to hold the leases state
            </summary>
            <param name="leaseContainer">Instance of a Cosmos Container to hold the leases.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithInMemoryLeaseContainer">
            <summary>
            Uses an in-memory container to maintain state of the leases
            </summary>
            <remarks>
            Using an in-memory container restricts the scaling capability to just the instance running the current processor.
            </remarks>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithErrorNotification(Microsoft.Azure.Cosmos.Container.ChangeFeedMonitorErrorDelegate)">
            <summary>
            Defines a delegate to receive notifications on errors that occur during change feed processor execution.
            </summary>
            <param name="errorDelegate">A delegate to receive notifications for change feed processor related errors.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithLeaseAcquireNotification(Microsoft.Azure.Cosmos.Container.ChangeFeedMonitorLeaseAcquireDelegate)">
            <summary>
            Defines a delegate to receive notifications on lease acquires that occur during change feed processor execution.
            </summary>
            <param name="acquireDelegate">A delegate to receive notifications when a change feed processor acquires a lease.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.WithLeaseReleaseNotification(Microsoft.Azure.Cosmos.Container.ChangeFeedMonitorLeaseReleaseDelegate)">
            <summary>
            Defines a delegate to receive notifications on lease releases that occur during change feed processor execution.
            </summary>
            <param name="releaseDelegate">A delegate to receive notifications when a change feed processor releases a lease.</param>
            <returns>The instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> to use.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder.Build">
            <summary>
            Builds a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> with the specified configuration.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorContext">
            <summary>
            Context that is related to the set of delivered changes.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorContext.LeaseToken">
            <summary>
            Gets the token representative of the current lease from which the changes come from.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorContext.Diagnostics">
            <summary>
            Gets the diagnostics related to the service response.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorContext.Headers">
            <summary>
            Gets the headers related to the service response that provided the changes.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorState">
            <summary>
            Change Feed processor state for a particular range of partition keys.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorState.#ctor(System.String,System.Int64,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorState"/> class.
            </summary>
            <param name="leaseToken">The lease token that identifies this lease.</param>
            <param name="estimatedLag">The amount of documents remaining to be processed</param>
            <param name="instanceName">The instance currently owning the lease.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorState.LeaseToken">
            <summary>
            Gets the lease token for which the state is calculated
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorState.EstimatedLag">
            <summary>
            Gets an approximation of the difference between the last processed transaction in the feed container and the latest transaction recorded.
            </summary>
            <remarks>
            The estimation over the Change Feed identifies volumes of transactions. If operations in the container are performed through stored procedures, transactional batch or bulk, a group of operations may share the same <see href="https://docs.microsoft.com/azure/cosmos-db/stored-procedures-triggers-udfs#transactions">transaction scope</see> and represented by a single transaction. 
            In those cases, the estimation might not exactly represent number of items, but it is still valid to understand if the pending volume is increasing, decreasing, or on a steady state.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorState.InstanceName">
            <summary>
            Gets the name of the instance currently owning the lease.
            </summary>
            <remarks>
            Leases can be in a released state and not being owned by any instance on a particular moment in time, in which case, this value is null.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException">
            <summary>
            Exception occurred when an operation in an IChangeFeedObserver is running and throws by user code
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException.#ctor(System.Exception,Microsoft.Azure.Cosmos.ChangeFeedProcessorContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException" /> class using the specified internal exception.
            </summary>
            <param name="originalException"><see cref="T:System.Exception"/> thrown by the user code.</param>
            <param name="context">Context under which the exception occurred.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException" /> for serialization purposes.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException.ChangeFeedProcessorContext">
            <summary>
            Contextual information that identifies which was the payload that was delivered to the delegate when this error occurred.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorUserException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the System.Runtime.Serialization.SerializationInfo with information about the exception.
            </summary>
            <param name="info">The SerializationInfo object that holds serialized object data for the exception being thrown.</param>
            <param name="context">The StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorHealthMonitor">
            <summary>
            Health monitor to capture lifecycle events of the Change Feed Processor.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorHealthMonitor.NotifyLeaseAcquireAsync(System.String)">
            <summary>
            For normal informational events happening on the context of a lease
            </summary>
            <param name="leaseToken">A unique identifier for the lease.</param>
            <returns>An asynchronous operation representing the logging operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorHealthMonitor.NotifyLeaseReleaseAsync(System.String)">
            <summary>
            For transient errors that the Change Feed Processor attemps retrying on.
            </summary>
            <param name="leaseToken">A unique identifier for the lease.</param>
            <returns>An asynchronous operation representing the logging operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedProcessorHealthMonitor.NotifyErrorAsync(System.String,System.Exception)">
            <summary>
            For critical errors that the Change Feed Processor that might not be recoverable.
            </summary>
            <param name="leaseToken">A unique identifier for the lease.</param>
            <param name="exception">The exception that happened.</param>
            <returns>An asynchronous operation representing the logging operation.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedMode">
            <summary>
            Base class for the change feed mode <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions"/>.
            </summary>
            <remarks>Use one of the static constructors to generate a ChangeFeedMode option.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedMode.#ctor">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedMode"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedMode.Incremental">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedMode"/> to receive incremental item changes.
            </summary>
            <remarks>
            Incremental mode includes item creations and updates, not deletions.
            </remarks>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedMode"/>  to receive incremental item changes.</returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedMode.FullFidelity">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedMode"/> to receive notifications for creations, deletes, as well as all intermediary snapshots for updates.
            </summary>
            <remarks>
            A container with a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedPolicy"/> configured is required. The delete operations will be included only within the configured retention period.
            When enabling full fidelity mode you will only be able to process change feed events within the retention window configured in the change feed policy of the container.
            If you attempt to process a change feed after more than the retention window an error(Status Code 400) will be returned because the events for intermediary
            updates and deletes have vanished.
            It would still be possible to process changes using <see cref="P:Microsoft.Azure.Cosmos.ChangeFeedMode.Incremental"/> mode even when configuring a full fidelity change feed policy 
            with retention window on the container and when using Incremental mode it doesn't matter whether your are out of the retention window or not -
            but no events for deletes or intermediary updates would be included.
            </remarks>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedMode"/>  to receive notifications for insertions, updates, and delete operations.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom">
            <summary>
            Base class for where to start a ChangeFeed operation in <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions"/>.
            </summary>
            <remarks>Use one of the static constructors to generate a StartFrom option.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.#ctor(Microsoft.Azure.Cosmos.FeedRange)">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.FeedRange">
            <summary>
            Gets the (optional) range to start from.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.Now">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from this moment onward.
            </summary>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from this moment onward.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.Now(Microsoft.Azure.Cosmos.FeedRange)">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from this moment onward.
            </summary>
            <param name="feedRange">The range to start from.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from this moment onward.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.Time(System.DateTime)">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from some point in time onward.
            </summary>
            <param name="dateTimeUtc">The time (in UTC) to start reading from.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from some point in time onward.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.Time(System.DateTime,Microsoft.Azure.Cosmos.FeedRange)">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from some point in time onward.
            </summary>
            <param name="dateTimeUtc">The time to start reading from.</param>
            <param name="feedRange">The range to start from.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from some point in time onward.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.ContinuationToken(System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from a save point.
            </summary>
            <param name="continuationToken">The continuation to resume from.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from a save point.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.Beginning">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start from the beginning of time.
            </summary>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from the beginning of time.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedStartFrom.Beginning(Microsoft.Azure.Cosmos.FeedRange)">
            <summary>
            Creates a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start from the beginning of time.
            </summary>
            <param name="feedRange">The range to start from.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedStartFrom"/> that tells the ChangeFeed operation to start reading changes from the beginning of time.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClearingSessionContainerClientRetryPolicy">
            <summary>
            This retry policy is designed to work with in a pair with ClientRetryPolicy.
            The inner retryPolicy must be a ClientRetryPolicy or a rety policy delegating to it.
            
            The expectation that is the outer retry policy in the retry policy chain and nobody can overwrite ShouldRetryResult.
            Once we clear the session we expect call to fail and throw exceptio to the client. Otherwise we may violate session consistency.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.AllServicePoolsEmpty">
            <summary>
              Looks up a localized string similar to Sorry, we are currently experiencing high demand in this region, and cannot fulfill your request at this time. We work continuously to bring more and more capacity online, and encourage you to try again shortly. Please do not hesitate to contact us via Azure support at any time or for any reason using this link http://aka.ms/azuresupport..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.AuthTokenNotFound">
            <summary>
              Looks up a localized string similar to The client does not have any valid token for the requested resource {0}..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_IllegalMemberAccess">
            <summary>
              Looks up a localized string similar to Query expression is invalid, member {0} of type {1} is invalid..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidArrayIndexExpression">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} is unsupported in this context. Supported expressions are MemberAccess and ArrayIndex..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidArrayIndexType">
            <summary>
              Looks up a localized string similar to Type {0} for an array index parameter is invalid. Array index parameter must be int..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidComparison">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} must either have LHS or RHS as constant..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidComparisonType">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} of type {1} cannot be used in this context..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidExpression">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} is unsupported. Supported expressions are &apos;Queryable.Where&apos;, &apos;Queryable.Select&apos; &amp; &apos;Queryable.SelectMany&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidLeftExpression">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} is not allowed in this context..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidMemberAccessExpression">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} is unsupported in this context. Supported expressions are parameter reference, array index and property reference..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidMethodCall">
            <summary>
              Looks up a localized string similar to Query expression is invalid, method call {0} is not allowed at this context. Allowed methods are {1}..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidQueryType">
            <summary>
              Looks up a localized string similar to QueryType {0} is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_InvalidReturnType">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression return type {0} is unsupported. Query must evaluate to IEnumerable..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_TooManySelectManyArguments">
            <summary>
              Looks up a localized string similar to Query expression is invalid, expression {0} contains too many arguments. .
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadQuery_TransformQueryException">
            <summary>
              Looks up a localized string similar to An error occured while evaluating the transform expression {0}..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BadSession">
            <summary>
              Looks up a localized string similar to Session object retrieved from client with endpoint {0} cannot be used on a client initialized to endpoint {1}..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BatchNoOperations">
            <summary>
              Looks up a localized string similar to The batch request did not have any operations to be executed..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BatchOperationTooLarge">
            <summary>
              Looks up a localized string similar to One or more batch operations are larger than the allowed limit..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BatchRequestOptionNotSupported">
            <summary>
              Looks up a localized string similar to One or more request options provided on the batch request are not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BatchTooLarge">
            <summary>
              Looks up a localized string similar to This batch request cannot be executed as it is larger than the allowed limit. Please reduce the number of operations in the batch and try again..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.BinaryOperatorNotSupported">
            <summary>
              Looks up a localized string similar to Binary operator &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ConstantTypeIsNotSupported">
            <summary>
              Looks up a localized string similar to Constant of type &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ConstructorInvocationNotSupported">
            <summary>
              Looks up a localized string similar to Constructor invocation is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.EncryptorNotConfigured">
            <summary>
              Looks up a localized string similar to The client was not configured to allow for encryption. Create the client by using cosmosClientBuilder.WithEncryptor..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.EpkPropertiesPairingExpected">
            <summary>
              Looks up a localized string similar to Expected valid byte[] value for {0} and string value for {1} when either property is set..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ExpectedMethodCallsMethods">
            <summary>
              Looks up a localized string similar to Expected a static IQueryable or IEnumerable extension method, received an instance method..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ExpressionTypeIsNotSupported">
            <summary>
              Looks up a localized string similar to Expression with NodeType &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.FailedToEvaluateSpatialExpression">
            <summary>
              Looks up a localized string similar to Expression tree cannot be processed because evaluation of Spatial expression failed..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.FailedToGetAadToken">
            <summary>
              Looks up a localized string similar to Failed to get AAD token from the provided Azure.Core.TokenCredential..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.FeedToken_EffectivePartitionKeyRouting">
            <summary>
              Looks up a localized string similar to Cannot define EffectivePartitionKeyRouting and FeedRange simultaneously..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.FeedToken_InvalidFeedTokenForContainer">
            <summary>
              Looks up a localized string similar to The continuation was generated for container {0} but current container is {1}..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.FeedToken_UnknownFormat">
            <summary>
              Looks up a localized string similar to The provided string &apos;{0}&apos; does not represent any known format..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.FeedToken_UnrecognizedFeedToken">
            <summary>
              Looks up a localized string similar to Unrecognized Feed Token type..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InputIsNotIDocumentQuery">
            <summary>
              Looks up a localized string similar to Input is not of type IDocumentQuery..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidArgumentsCount">
            <summary>
              Looks up a localized string similar to Incorrect number of arguments for method &apos;{0}&apos;. Expected &apos;{1}&apos; but received &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidCallToUserDefinedFunctionProvider">
            <summary>
              Looks up a localized string similar to This method should only be called within Linq expression to Invoke a User-defined function..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidRangeError">
            <summary>
              Looks up a localized string similar to Range low value must be less than or equal the high value..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidRequestWithEncryptionOptions">
            <summary>
              Looks up a localized string similar to Encryption options may not be specified on this request..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidServerResponse">
            <summary>
              Looks up a localized string similar to Received an invalid response from the server..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidSkipValue">
            <summary>
              Looks up a localized string similar to The count value provided for a Skip expression must be a non-negative integer..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidTakeValue">
            <summary>
              Looks up a localized string similar to The count value provided for a Take expression must be a non-negative integer..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.InvalidTypesForMethod">
            <summary>
              Looks up a localized string similar to Method &apos;{0}&apos; can not be invoked for type &apos;{1}&apos;. Supported types are &apos;[{2}]&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.MediaLinkInvalid">
            <summary>
              Looks up a localized string similar to MediaLink is invalid.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.MemberBindingNotSupported">
            <summary>
              Looks up a localized string similar to Member binding is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.MethodNotSupported">
            <summary>
              Looks up a localized string similar to Method &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.NotSupported">
            <summary>
              Looks up a localized string similar to Not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.OnlyLINQMethodsAreSupported">
            <summary>
              Looks up a localized string similar to Method &apos;{0}&apos; is not supported. Only LINQ Methods are supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PartitionKeyExtractError">
            <summary>
              Looks up a localized string similar to Unable to extract partition key from document. Ensure that you have provided a valid PartitionKeyValueExtractor function..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PartitionKeyPathConflict">
            <summary>
              Looks up a localized string similar to The requested partition key path &apos;{0}&apos; does not match existing Container &apos;{1}&apos; with partition key path &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PartitionPropertyNotFound">
            <summary>
              Looks up a localized string similar to Partition property not found in the document..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PartitionResolver_DatabaseAlreadyExist">
            <summary>
              Looks up a localized string similar to An IPartitionResolver already exists for this database.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PartitionResolver_DatabaseDoesntExist">
            <summary>
              Looks up a localized string similar to No IPartitionResolver available for this database.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PathExpressionsOnly">
            <summary>
              Looks up a localized string similar to Only path expressions are supported for SelectMany..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.PKAndEpkSetTogether">
            <summary>
              Looks up a localized string similar to Partition key and effective partition key may not both be set..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.RangeNotFoundError">
            <summary>
              Looks up a localized string similar to A containing range for {0} doesn&apos;t exist in the partition map..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ServerResponseDeserializationFailure">
            <summary>
              Looks up a localized string similar to Failed to deserialize response returned by server..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.StringCompareToInvalidConstant">
            <summary>
              Looks up a localized string similar to The right hand side of string.CompareTo() comparison must be constant &apos;0&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.StringCompareToInvalidOperator">
            <summary>
              Looks up a localized string similar to Invalid operator for string.CompareTo(). Vaid operators are (&apos;==&apos;, &apos;&lt;&apos;, &apos;&lt;=&apos;, &apos;&gt;&apos; or &apos;&gt;=&apos;).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.TokenRefreshInProgress">
            <summary>
              Looks up a localized string similar to Token refresh in progress..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.TypeCheckExtensionFunctionsNotImplemented">
            <summary>
              Looks up a localized string similar to Type check operations can be used in Linq expressions only and are evaluated in Azure CosmosDB server..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.UdfNameIsNullOrEmpty">
            <summary>
              Looks up a localized string similar to User-defined function name can not be null or empty..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.UnaryOperatorNotSupported">
            <summary>
              Looks up a localized string similar to Unary operator &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.UnexpectedAuthTokenType">
            <summary>
              Looks up a localized string similar to Unexpected authorization token type &apos;({0})&apos;. Expected &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.UnexpectedTokenType">
            <summary>
              Looks up a localized string similar to Unexpected token type: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.UnsupportedBulkRequestOptions">
            <summary>
              Looks up a localized string similar to Consistency, Session, Properties, and Triggers are not allowed when AllowBulkExecution is set to true..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.UnsupportedPartitionKey">
            <summary>
              Looks up a localized string similar to Unsupported type {0} for partitionKey..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientResources.ValueAndAnonymousTypesAndGeometryOnly">
            <summary>
              Looks up a localized string similar to Instantiation of only value types, anonymous types and spatial types are supported..
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientRetryPolicy">
            <summary>
            Client policy is combination of endpoint change retry + throttling retry.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientRetryPolicy.ShouldRetryAsync(System.Exception,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="exception">Exception that occurred when the operation was tried</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientRetryPolicy.ShouldRetryAsync(Microsoft.Azure.Cosmos.ResponseMessage,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="cosmosResponseMessage"><see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> in return of the request</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientRetryPolicy.OnBeforeSendRequest(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Method that is called before a request is sent to allow the retry policy implementation
            to modify the state of the request.
            </summary>
            <param name="request">The request being sent to the service.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientRetryPolicy.ShouldRetryOnServiceUnavailable">
            <summary>
            For a ServiceUnavailable (503.0) we could be having a timeout from Direct/TCP locally or a request to Gateway request with a similar response due to an endpoint not yet available.
            We try and retry the request only if there are other regions available.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ConnectionMode">
            <summary>
            Represents the connection mode to be used by the client when connecting to the Azure Cosmos DB service.
            </summary>
            <remarks>
            Direct and Gateway connectivity modes are supported. Direct is the default. 
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            CosmosClient client = new CosmosClient(connectionString, new CosmosClientOptions { ConnectionMode = ConnectionMode.Gateway });
            ]]>
            </code>
            </example>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/sql-sdk-connection-modes"/>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway">
            <summary>
            Use the Azure Cosmos DB gateway to route all requests to the Azure Cosmos DB service. The gateway proxies requests to the right data partition.
            </summary>
            <remarks>
            Use Gateway connectivity when within firewall settings do not allow Direct connectivity. All connections 
            are made to the database account's endpoint through the standard HTTPS port (443).
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConnectionMode.Direct">
            <summary>
            Uses direct connectivity to connect to the data nodes in the Azure Cosmos DB service. Use gateway only to initialize and cache logical addresses and refresh on updates
            </summary>
            <remarks>
            Use Direct connectivity for best performance. Connections are made to the data nodes on Azure Cosmos DB's clusters 
            on a range of port numbers either using HTTPS or TCP/SSL.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ConnectionPolicy">
            <summary>
            Represents the connection policy associated with a DocumentClient to connect to the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ConnectionPolicy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/> class to connect to the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ConnectionPolicy.SetCurrentLocation(System.String)">
            <summary>
            Automatically populates the <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferredLocations"/> for geo-replicated database accounts in the Azure Cosmos DB service,
            based on the current region that the client is running in.
            </summary>
            <param name="location">The current region that this client is running in. E.g. "East US" </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MaxConcurrentFanoutRequests">
            <summary>
            Gets or sets the maximum number of concurrent fanout requests sent to the Azure Cosmos DB service.
            </summary>
            <value>Default value is 32.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RequestTimeout">
            <summary>
            Gets or sets the request timeout in seconds when connecting to the Azure Cosmos DB service.
            The number specifies the time to wait for response to come back from network peer.
            </summary>
            <value>Default value is 10 seconds.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MediaRequestTimeout">
            <summary>
            Gets or sets the media request timeout in seconds when connecting to the Azure Cosmos DB service.
            The number specifies the time to wait for response to come back from network peer for attachment content (a.k.a. media) operations.
            </summary>
            <value>
            Default value is 300 seconds.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.ConnectionMode">
            <summary>
            Gets or sets the connection mode used by the client when connecting to the Azure Cosmos DB service.
            </summary>
            <value>
            Default value is <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway"/>
            </value>
            <remarks>
            For more information, see <see href="https://docs.microsoft.com/en-us/azure/documentdb/documentdb-performance-tips#direct-connection">Connection policy: Use direct connection mode</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MediaReadMode">
            <summary>
            Gets or sets the attachment content (a.k.a. media) download mode when connecting to the Azure Cosmos DB service.
            </summary>
            <value>
            Default value is <see cref="F:Microsoft.Azure.Cosmos.MediaReadMode.Buffered"/>.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.ConnectionProtocol">
            <summary>
            Gets or sets the connection protocol when connecting to the Azure Cosmos DB service.
            </summary>
            <value>
            Default value is <see cref="F:Microsoft.Azure.Documents.Client.Protocol.Https"/>.
            </value>
            <remarks>
            This setting is not used when <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.ConnectionMode"/> is set to <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway"/>.
            Gateway mode only supports HTTPS.
            For more information, see <see href="https://docs.microsoft.com/en-us/azure/documentdb/documentdb-performance-tips#use-tcp">Connection policy: Use the TCP protocol</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.EnableReadRequestsFallback">
            <summary>
            Gets or sets whether to allow for reads to go to multiple regions configured on an account of Azure Cosmos DB service.
            </summary>
            <value>
            Default value is null.
            </value>
            <remarks>
            If this property is not set, the default is true for all Consistency Levels other than Bounded Staleness,
            The default is false for Bounded Staleness.
            This property only has effect if the following conditions are satisifed:
            1. <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.EnableEndpointDiscovery"/> is true
            2. the Azure Cosmos DB account has more than one region
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.EnableTcpConnectionEndpointRediscovery">
            <summary>
            Gets or sets the flag to enable address cache refresh on connection reset notification.
            </summary>
            <value>
            The default value is false
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.Default">
            <summary>
            Gets the default connection policy used to connect to the Azure Cosmos DB service.
            </summary>
            <value>
            Refer to the default values for the individual properties of <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/> that determine the default connection policy.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.UserAgentSuffix">
            <summary>
            A suffix to be added to the default user-agent for the Azure Cosmos DB service.
            </summary>
            <remarks>
            Setting this property after sending any request won't have any effect.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferredLocations">
            <summary>
            Gets and sets the preferred locations (regions) for geo-replicated database accounts in the Azure Cosmos DB service.
            For example, "East US" as the preferred location.
            </summary>
            <remarks>
            <para>
            When <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.EnableEndpointDiscovery"/> is true and the value of this property is non-empty,
            the SDK uses the locations in the collection in the order they are specified to perform operations,
            otherwise if the value of this property is not specified,
            the SDK uses the write region as the preferred location for all operations.
            </para>
            <para>
            If <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.EnableEndpointDiscovery"/> is set to false, the value of this property is ignored.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.EnableEndpointDiscovery">
            <summary>
            Gets or sets the flag to enable endpoint discovery for geo-replicated database accounts in the Azure Cosmos DB service.
            </summary>
            <remarks>
            When the value of this property is true, the SDK will automatically discover the
            current write and read regions to ensure requests are sent to the correct region
            based on the regions specified in the <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferredLocations"/> property.
            <value>Default value is true indicating endpoint discovery is enabled.</value>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.UseMultipleWriteLocations">
            <summary>
            Gets or sets the flag to enable writes on any locations (regions) for geo-replicated database accounts in the Azure Cosmos DB service.
            </summary>
            <remarks>
            When the value of this property is true, the SDK will direct write operations to
            available writable locations of geo-replicated database account. Writable locations
            are ordered by <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferredLocations"/> property. Setting the property value
            to true has no effect until <see cref="P:Microsoft.Azure.Cosmos.AccountProperties.EnableMultipleWriteLocations"/> 
            is also set to true.
            <value>Default value is false indicating that writes are only directed to
            first region in <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferredLocations"/> property.</value>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MaxConnectionLimit">
            <summary>
            Gets or sets the maximum number of concurrent connections allowed for the target
            service endpoint in the Azure Cosmos DB service.
            </summary>
            <remarks>
            This setting is only applicable in Gateway mode.
            </remarks>
            <value>Default value is 50.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions">
             <summary>
             Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/> associated
             with the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> in the Azure Cosmos DB service.
             </summary>
             <seealso cref="T:Microsoft.Azure.Cosmos.DocumentClient"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
             <seealso cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>
             <example>
             The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> and sets the <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
             using the <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/> property.
             <para>
             <see cref="P:Microsoft.Azure.Cosmos.RetryOptions.MaxRetryAttemptsOnThrottledRequests"/> is set to 3, so in this case, if a request operation is rate limited by exceeding the reserved 
             throughput for the collection, the request operation retries 3 times before throwing the exception to the application.
             <see cref="P:Microsoft.Azure.Cosmos.RetryOptions.MaxRetryWaitTimeInSeconds"/> is set to 60, so in this case if the cumulative retry 
             wait time in seconds since the first request exceeds 60 seconds, the exception is thrown.
             </para>
             <code language="c#">
             <![CDATA[
             ConnectionPolicy connectionPolicy = new ConnectionPolicy();
             connectionPolicy.RetryOptions.MaxRetryAttemptsOnThrottledRequests = 3;
             connectionPolicy.RetryOptions.MaxRetryWaitTimeInSeconds = 60;
            
             DocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key", connectionPolicy);
             ]]>
             </code>
             </example>
             <value>
             If this property is not set, the SDK uses the default retry policy that has <see cref="P:Microsoft.Azure.Cosmos.RetryOptions.MaxRetryAttemptsOnThrottledRequests"/>
             set to 9 and <see cref="P:Microsoft.Azure.Cosmos.RetryOptions.MaxRetryWaitTimeInSeconds"/> set to 30 seconds.
             </value>
             <remarks>
             For more information, see <see href="https://docs.microsoft.com/en-us/azure/documentdb/documentdb-performance-tips#429">Handle rate limiting/request rate too large</see>.
             </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.IdleTcpConnectionTimeout">
            <summary>
            (Direct/TCP) Controls the amount of idle time after which unused connections are closed.
            </summary>
            <value>
            By default, idle connections are kept open indefinitely. Value must be greater than or equal to 10 minutes. Recommended values are between 20 minutes and 24 hours.
            </value>
            <remarks>
            Mainly useful for sparse infrequent access to a large database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.OpenTcpConnectionTimeout">
            <summary>
            (Direct/TCP) Controls the amount of time allowed for trying to establish a connection.
            </summary>
            <value>
            The default timeout is 5 seconds. Recommended values are greater than or equal to 5 seconds.
            </value>
            <remarks>
            When the time elapses, the attempt is cancelled and an error is returned. Longer timeouts will delay retries and failures.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MaxRequestsPerTcpConnection">
            <summary>
            (Direct/TCP) Controls the number of requests allowed simultaneously over a single TCP connection. When more requests are in flight simultaneously, the direct/TCP client will open additional connections.
            </summary>
            <value>
            The default settings allow 30 simultaneous requests per connection.
            Do not set this value lower than 4 requests per connection or higher than 50-100 requests per connection. 
            The former can lead to a large number of connections to be created. 
            The latter can lead to head of line blocking, high latency and timeouts.
            </value>
            <remarks>
            Applications with a very high degree of parallelism per connection, with large requests or responses, or with very tight latency requirements might get better performance with 8-16 requests per connection.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MaxTcpConnectionsPerEndpoint">
            <summary>
            (Direct/TCP) Controls the maximum number of TCP connections that may be opened to each Cosmos DB back-end.
            Together with MaxRequestsPerTcpConnection, this setting limits the number of requests that are simultaneously sent to a single Cosmos DB back-end(MaxRequestsPerTcpConnection x MaxTcpConnectionPerEndpoint).
            </summary>
            <value>
            The default value is 65,535. Value must be greater than or equal to 16.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PortReuseMode">
            <summary>
            (Direct/TCP) Controls the client port reuse policy used by the transport stack.
            </summary>
            <value>
            The default value is PortReuseMode.ReuseUnicastPort.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.HttpClientFactory">
            <summary>
            Gets or sets a delegate to use to obtain an HttpClient instance to be used for HTTPS communication.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConnectionPolicy.MaxTcpPartitionCount">
            <summary>
            (Direct/TCP) This is an advanced setting that controls the number of TCP connections that will be opened eagerly to each Cosmos DB back-end.
            </summary>
            <value>
            Default value is 1. Applications with extreme performance requirements can set this value to 2.
            </value>
            <remarks>
            This setting must be used with caution. When used improperly, it can lead to client machine ephemeral port exhaustion <see href="https://docs.microsoft.com/en-us/azure/load-balancer/load-balancer-outbound-connections">Azure SNAT port exhaustion</see>.
            </remarks>
        </member>
        <member name="E:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferenceChanged">
            <summary>
            GlobalEndpointManager will subscribe to this event if user updates the preferredLocations list in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosClient">
            <summary>
            Provides a client-side logical representation of the Azure Cosmos DB account.
            This client can be used to configure and execute requests in the Azure Cosmos DB database service.
            
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <example>
            This example create a <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>, <see cref="T:Microsoft.Azure.Cosmos.Database"/>, and a <see cref="T:Microsoft.Azure.Cosmos.Container"/>.
            The CosmosClient is created with the connection string and configured to use "East US 2" region.
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            
            CosmosClient cosmosClient = new CosmosClient(
                        "connection-string-from-portal", 
                        new CosmosClientOptions()
                        {
                            ApplicationRegion = Regions.EastUS2,
                        });
            
            Database db = await client.CreateDatabaseAsync("database-id");
            Container container = await db.CreateContainerAsync("container-id");
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
            <example>
            This example creates a <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>, <see cref="T:Microsoft.Azure.Cosmos.Database"/>, and a <see cref="T:Microsoft.Azure.Cosmos.Container"/>.
            The CosmosClient is created with the AccountEndpoint, AccountKey or ResourceToken and configured to use "East US 2" region.
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            
            CosmosClient cosmosClient = new CosmosClient(
                        "account-endpoint-from-portal", 
                        "account-key-from-portal", 
                        new CosmosClientOptions()
                        {
                            ApplicationRegion = Regions.EastUS2,
                        });
            
            Database db = await client.CreateDatabaseAsync("database-id");
            Container container = await db.CreateContainerAsync("container-id");
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
            <example>
            This example creates a <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>, <see cref="T:Microsoft.Azure.Cosmos.Database"/>, and a <see cref="T:Microsoft.Azure.Cosmos.Container"/>.
            The CosmosClient is created through builder pattern using <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            using Microsoft.Azure.Cosmos.Fluent;
            
            CosmosClient cosmosClient = new CosmosClientBuilder("connection-string-from-portal")
                .WithApplicationRegion("East US 2")
                .Build();
            
            Database db = await client.CreateDatabaseAsync("database-id")
            Container container = await db.CreateContainerAsync("container-id");
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.CosmosClientOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">Performance Tips</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/troubleshoot-dot-net-sdk">Diagnose and troubleshoot issues</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/distribute-data-globally">Global data distribution</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/partitioning-overview">Partitioning and horizontal scaling</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.#ctor">
            <summary>
            Create a new CosmosClient used for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.#ctor(System.String,Microsoft.Azure.Cosmos.CosmosClientOptions)">
            <summary>
            Creates a new CosmosClient with the connection string.
            
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <param name="connectionString">The connection string to the cosmos account. ex: https://mycosmosaccount.documents.azure.com:443/;AccountKey=SuperSecretKey; </param>
            <param name="clientOptions">(Optional) client options</param>
            <example>
            The CosmosClient is created with the connection string and configured to use "East US 2" region.
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            
            CosmosClient cosmosClient = new CosmosClient(
                        "account-endpoint-from-portal", 
                        "account-key-from-portal", 
                        new CosmosClientOptions()
                        {
                            ApplicationRegion = Regions.EastUS2,
                        });
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.CosmosClientOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">Performance Tips</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/troubleshoot-dot-net-sdk">Diagnose and troubleshoot issues</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.#ctor(System.String,System.String,Microsoft.Azure.Cosmos.CosmosClientOptions)">
            <summary>
            Creates a new CosmosClient with the account endpoint URI string and account key.
            
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <param name="accountEndpoint">The cosmos service endpoint to use</param>
            <param name="authKeyOrResourceToken">The cosmos account key or resource token to use to create the client.</param>
            <param name="clientOptions">(Optional) client options</param>
            <example>
            The CosmosClient is created with the AccountEndpoint, AccountKey or ResourceToken and configured to use "East US 2" region.
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            
            CosmosClient cosmosClient = new CosmosClient(
                        "account-endpoint-from-portal", 
                        "account-key-from-portal", 
                        new CosmosClientOptions()
                        {
                            ApplicationRegion = Regions.EastUS2,
                        });
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.CosmosClientOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">Performance Tips</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/troubleshoot-dot-net-sdk">Diagnose and troubleshoot issues</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.#ctor(System.String,Azure.Core.TokenCredential,Microsoft.Azure.Cosmos.CosmosClientOptions)">
            <summary>
            Creates a new CosmosClient with the account endpoint URI string and TokenCredential.
            
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <param name="accountEndpoint">The cosmos service endpoint to use.</param>
            <param name="tokenCredential"><see cref="T:Azure.Core.TokenCredential"/>The token to provide AAD token for authorization.</param>
            <param name="clientOptions">(Optional) client options</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.#ctor(System.String,Microsoft.Azure.Cosmos.AuthorizationTokenProvider,Microsoft.Azure.Cosmos.CosmosClientOptions)">
            <summary>
            Used by Compute
            Creates a new CosmosClient with the AuthorizationTokenProvider
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateAndInitializeAsync(System.String,System.String,System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,System.String}},Microsoft.Azure.Cosmos.CosmosClientOptions,System.Threading.CancellationToken)">
            <summary>
            Creates a new CosmosClient with the account endpoint URI string and TokenCredential.
            In addition to that it initializes the client with containers provided i.e The SDK warms up the caches and 
            connections before the first call to the service is made. Use this to obtain lower latency while startup of your application.
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <param name="accountEndpoint">The cosmos service endpoint to use</param>
            <param name="authKeyOrResourceToken">The cosmos account key or resource token to use to create the client.</param>
            <param name="containers">Containers to be initialized identified by it's database name and container name.</param>
            <param name="cosmosClientOptions">(Optional) client options</param>
            <param name="cancellationToken">(Optional) Cancellation Token</param>
            <returns>
            A CosmosClient object.
            </returns>
            <example>
            The CosmosClient is created with the AccountEndpoint, AccountKey or ResourceToken and 2 containers in the account are initialized
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            List<(string, string)> containersToInitialize = new List<(string, string)>
            { ("DatabaseName1", "ContainerName1"), ("DatabaseName2", "ContainerName2") };
            
            CosmosClient cosmosClient = await CosmosClient.CreateAndInitializeAsync("account-endpoint-from-portal", 
                                                                                    "account-key-from-portal",
                                                                                    containersToInitialize)
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateAndInitializeAsync(System.String,System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,System.String}},Microsoft.Azure.Cosmos.CosmosClientOptions,System.Threading.CancellationToken)">
            <summary>
            Creates a new CosmosClient with the account endpoint URI string and TokenCredential.
            In addition to that it initializes the client with containers provided i.e The SDK warms up the caches and 
            connections before the first call to the service is made. Use this to obtain lower latency while startup of your application.
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <param name="connectionString">The connection string to the cosmos account. ex: https://mycosmosaccount.documents.azure.com:443/;AccountKey=SuperSecretKey; </param>
            <param name="containers">Containers to be initialized identified by it's database name and container name.</param>
            <param name="cosmosClientOptions">(Optional) client options</param>
            <param name="cancellationToken">(Optional) Cancellation Token</param>
            <returns>
            A CosmosClient object.
            </returns>
            <example>
            The CosmosClient is created with the ConnectionString and 2 containers in the account are initialized
            <code language="c#">
            <![CDATA[
            using Microsoft.Azure.Cosmos;
            List<(string, string)> containersToInitialize = new List<(string, string)>
            { ("DatabaseName1", "ContainerName1"), ("DatabaseName2", "ContainerName2") };
            
            CosmosClient cosmosClient = await CosmosClient.CreateAndInitializeAsync("connection-string-from-portal",
                                                                                    containersToInitialize)
            
            // Dispose cosmosClient at application exit
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateAndInitializeAsync(System.String,Azure.Core.TokenCredential,System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,System.String}},Microsoft.Azure.Cosmos.CosmosClientOptions,System.Threading.CancellationToken)">
            <summary>
            Creates a new CosmosClient with the account endpoint URI string and TokenCredential.
            In addition to that it initializes the client with containers provided i.e The SDK warms up the caches and 
            connections before the first call to the service is made. Use this to obtain lower latency while startup of your application.
            CosmosClient is thread-safe. Its recommended to maintain a single instance of CosmosClient per lifetime 
            of the application which enables efficient connection management and performance. Please refer to the
            <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips">performance guide</see>.
            </summary>
            <param name="accountEndpoint">The cosmos service endpoint to use.</param>
            <param name="tokenCredential"><see cref="T:Azure.Core.TokenCredential"/>The token to provide AAD token for authorization.</param>
            <param name="containers">Containers to be initialized identified by it's database name and container name.</param>
            <param name="cosmosClientOptions">(Optional) client options</param>
            <param name="cancellationToken">(Optional) Cancellation Token</param>
            <returns>
            A CosmosClient object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.#ctor(System.String,System.String,Microsoft.Azure.Cosmos.CosmosClientOptions,Microsoft.Azure.Cosmos.DocumentClient)">
            <summary>
            Used for unit testing only.
            </summary>
            <remarks>This constructor should be removed at some point. The mocking should happen in a derived class.</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClient.ClientOptions">
            <summary>
            The <see cref="T:Microsoft.Azure.Cosmos.CosmosClientOptions"/> used initialize CosmosClient.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClient.ResponseFactory">
            <summary>
            The response factory used to create CosmosClient response types.
            </summary>
            <remarks>
            This can be used for generating responses for tests, and allows users to create
            a custom container that modifies the response. For example the client encryption
            uses this to decrypt responses before returning to the caller.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClient.Endpoint">
            <summary>
            Gets the endpoint Uri for the Azure Cosmos DB service.
            </summary>
            <value>
            The Uri for the account endpoint.
            </value>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClient.AccountKey">
            <summary>
            Gets the AuthKey or resource token used by the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The AuthKey used by the client.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClient.AuthorizationTokenProvider">
            <summary>
            Gets the AuthorizationTokenProvider used to generate the authorization token
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.ReadAccountAsync">
            <summary>
            Reads the <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> for the Azure Cosmos DB account.
            </summary>
            <returns>
            A <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> wrapped in a <see cref="T:System.Threading.Tasks.Task"/> object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.GetDatabase(System.String)">
            <summary>
            Returns a proxy reference to a database. 
            </summary>
            <param name="id">The Cosmos database id</param>
            <remarks>
            <see cref="T:Microsoft.Azure.Cosmos.Database"/> proxy reference doesn't guarantee existence.
            Please ensure database exists through <see cref="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseAsync(System.String,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)"/> 
            or <see cref="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseIfNotExistsAsync(System.String,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)"/>, before
            operating on it.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            Database db = cosmosClient.GetDatabase("myDatabaseId");
            DatabaseResponse response = await db.ReadAsync();
            ]]>
            </code>
            </example>
            <returns>Cosmos database proxy</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.GetContainer(System.String,System.String)">
            <summary>
            Returns a proxy reference to a container. 
            </summary>
            <remarks>
            <see cref="T:Microsoft.Azure.Cosmos.Container"/> proxy reference doesn't guarantee existence.
            Please ensure container exists through <see cref="M:Microsoft.Azure.Cosmos.Database.CreateContainerAsync(Microsoft.Azure.Cosmos.ContainerProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)"/> 
            or <see cref="M:Microsoft.Azure.Cosmos.Database.CreateContainerIfNotExistsAsync(Microsoft.Azure.Cosmos.ContainerProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)"/>, before
            operating on it.
            </remarks>
            <param name="databaseId">Cosmos database name</param>
            <param name="containerId">Cosmos container name</param>
            <returns>Cosmos container proxy</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseAsync(System.String,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Sends a request for creating a database.
            
             A database manages users, permissions and a set of containers.
             Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
             with the database being the logical container for data.
            
             Each Database consists of one or more containers, each of which in turn contain one or more
             documents. Since databases are an administrative resource, the Service Master Key will be
             required in order to access and successfully complete any action using the User APIs.
             </summary>
             <param name="id">The database id.</param>
             <param name="throughput">(Optional) The throughput provisioned for a database in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) A set of options that can be set.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseAsync(System.String,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Sends a request for creating a database.
            
             A database manages users, permissions and a set of containers.
             Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
             with the database being the logical container for data.
            
             Each Database consists of one or more containers, each of which in turn contain one or more
             documents. Since databases are an administrative resource, the Service Master Key will be
             required in order to access and successfully complete any action using the User APIs.
             </summary>
             <param name="id">The database id.</param>
             <param name="throughputProperties">(Optional) The throughput provisioned for a database in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) A set of options that can be set.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseIfNotExistsAsync(System.String,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             <para>Check if a database exists, and if it doesn't, create it.
             Only the database id is used to verify if there is an existing database. Other database properties 
             such as throughput are not validated and can be different then the passed properties.</para>
             
             <para>A database manages users, permissions and a set of containers.
             Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
             with the database being the logical container for data.</para>
            
             <para>Each Database consists of one or more containers, each of which in turn contain one or more
             documents. Since databases are an administrative resource, the Service Master Key will be
             required in order to access and successfully complete any action using the User APIs.</para>
             </summary>
             <param name="id">The database id.</param>
             <param name="throughputProperties">The throughput provisioned for a database in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) A set of additional options that can be set.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the resource record.
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Common success StatusCodes for the CreateDatabaseIfNotExistsAsync operation</description>
                 </listheader>
                 <item>
                     <term>201</term><description>Created - New database is created.</description>
                 </item>
                 <item>
                     <term>200</term><description>OK - This means the database already exists.</description>
                 </item>
             </list>
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseIfNotExistsAsync(System.String,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             <para>Check if a database exists, and if it doesn't, create it.
             Only the database id is used to verify if there is an existing database. Other database properties 
             such as throughput are not validated and can be different then the passed properties.</para>
             
             <para>A database manages users, permissions and a set of containers.
             Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
             with the database being the logical container for data.</para>
            
             <para>Each Database consists of one or more containers, each of which in turn contain one or more
             documents. Since databases are an administrative resource, the Service Master Key will be
             required in order to access and successfully complete any action using the User APIs.</para>
             </summary>
             <param name="id">The database id.</param>
             <param name="throughput">(Optional) The throughput provisioned for a database in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) A set of additional options that can be set.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the resource record.
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Common success StatusCodes for the CreateDatabaseIfNotExistsAsync operation</description>
                 </listheader>
                 <item>
                     <term>201</term><description>Created - New database is created.</description>
                 </item>
                 <item>
                     <term>200</term><description>OK- This means the database already exists.</description>
                 </item>
             </list>
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.GetDatabaseQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for databases under an Cosmos DB Account using a SQL statement with parameterized values. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the databases.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Database.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)" /> is recommended for single database look-up.
            </para>
            </remarks>
            <example>
            This create the type feed iterator for database with queryText as input,
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM c where c.status like @status")
                .WithParameter("@status", "start%");
            using (FeedIterator<DatabaseProperties> feedIterator = this.users.GetDatabaseQueryIterator<DatabaseProperties>(queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<DatabaseProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var database in response)
                    {
                        Console.WriteLine(database);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.GetDatabaseQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for databases under an Cosmos DB Account using a SQL statement with parameterized values. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the query request.</param>
            <returns>An iterator to go through the databases</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Database.ReadStreamAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)" /> is recommended for single database look-up.
            </para>
            </remarks>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select * From c where c._rid = @rid")
                          .WithParameter("@rid", "TheRidValue");
            using (FeedIterator feedIterator = this.CosmosClient.GetDatabaseQueryStreamIterator(
                queryDefinition)
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status for errors
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario. 
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.GetDatabaseQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for databases under an Cosmos DB Account using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the databases.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Database.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)" /> is recommended for single database look-up.
            </para>
            </remarks>
            <example>
            This create the type feed iterator for database with queryText as input,
            <code language="c#">
            <![CDATA[
            string queryText = "SELECT * FROM c where c.status like 'start%'";
            using (FeedIterator<DatabaseProperties> feedIterator = this.users.GetDatabaseQueryIterator<DatabaseProperties>(queryText)
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<DatabaseProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var database in response)
                    {
                        Console.WriteLine(database);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.GetDatabaseQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for databases under an Cosmos DB Account using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the query request.</param>
            <returns>An iterator to go through the databases</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Database.ReadStreamAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)" /> is recommended for single database look-up.
            </para>
            </remarks>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            using (FeedIterator feedIterator = this.CosmosClient.GetDatabaseQueryStreamIterator(
                ("select * From c where c._rid = 'TheRidValue'")
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status for errors
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario. 
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseStreamAsync(Microsoft.Azure.Cosmos.DatabaseProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Send a request for creating a database.
            
             A database manages users, permissions and a set of containers.
             Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
             with the database being the logical container for data.
            
             Each Database consists of one or more containers, each of which in turn contain one or more
             documents. Since databases are an administrative resource, the Service Master Key will be
             required in order to access and successfully complete any action using the User APIs.
             </summary>
             <param name="databaseProperties">The database properties</param>
             <param name="throughput">(Optional) The throughput provisioned for a database in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) A set of options that can be set.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.RemoveDefaultTraceListener">
            <summary>
            Removes the DefaultTraceListener which causes locking issues which leads to avability problems. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.CreateDatabaseStreamAsync(Microsoft.Azure.Cosmos.DatabaseProperties,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Send a request for creating a database.
            
             A database manages users, permissions and a set of containers.
             Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
             with the database being the logical container for data.
            
             Each Database consists of one or more containers, each of which in turn contain one or more
             documents. Since databases are an administrative resource, the Service Master Key will be
             required in order to access and successfully complete any action using the User APIs.
             </summary>
             <param name="databaseProperties">The database properties</param>
             <param name="throughputProperties">(Optional) The throughput provisioned for a database in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) A set of options that can be set.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the resource record.</returns>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.Dispose">
            <summary>
            Dispose of cosmos client
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClient.Dispose(System.Boolean)">
            <summary>
            Dispose of cosmos client
            </summary>
            <param name="disposing">True if disposing</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosClientOptions">
            <summary>
            Defines all the configurable options that the CosmosClient requires.
            </summary>
            <example>
            An example on how to configure the serialization option to ignore null values.
            <code language="c#">
            <![CDATA[
            CosmosClientOptions clientOptions = new CosmosClientOptions()
            {
                SerializerOptions = new CosmosSerializationOptions(){
                    IgnoreNullValues = true
                },
                ConnectionMode = ConnectionMode.Gateway,
            };
            
            CosmosClient client = new CosmosClient("endpoint", "key", clientOptions);
            ]]>
            </code>
            </example>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CosmosClientOptions.DefaultConnectionMode">
            <summary>
            Default connection mode
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CosmosClientOptions.DefaultProtocol">
            <summary>
            Default Protocol mode
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CosmosClientOptions.gatewayModeMaxConnectionLimit">
            <summary>
            Default request timeout
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientOptions.#ctor">
            <summary>
            Creates a new CosmosClientOptions
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationName">
            <summary>
            Get or set user-agent suffix to include with every Azure Cosmos DB service interaction.
            </summary>
            <remarks>
            Setting this property after sending any request won't have any effect.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.SessionContainer">
            <summary>
            Get or set session container for the client
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationRegion">
            <summary>
            Gets or sets the location where the application is running. This will influence the SDK's choice for the Azure Cosmos DB service interaction.
            </summary>
            <remarks>
            When the specified region is available, the SDK will prefer it to perform operations. When the region specified is not available,
            the SDK auto-selects fallback regions based on proximity from the given region. When
            this property is not specified at all, the SDK uses the write region
            as the preferred region for all operations. See also 
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/sql/troubleshoot-sdk-availability">Diagnose
            and troubleshoot the availability of Cosmos SDKs</seealso> for more details.
            This configuration is an alternative to <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationPreferredRegions"/>, either one can be set but not both.
            </remarks>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApplicationRegion(System.String)"/>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/high-availability#high-availability-with-cosmos-db-in-the-event-of-regional-outages">High availability on regional outages</seealso>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationPreferredRegions">
            <summary>
            Gets and sets the preferred regions for geo-replicated database accounts in the Azure Cosmos DB service. 
            </summary>
            <remarks>
            When this property is specified, the SDK will use the region list in the provided order to define the endpoint failover order.
            This configuration is an alternative to <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationRegion"/>, either one can be set but not both.
            See also <seealso href="https://docs.microsoft.com/azure/cosmos-db/sql/troubleshoot-sdk-availability">Diagnose
            and troubleshoot the availability of Cosmos SDKs</seealso> for more details.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/high-availability#high-availability-with-cosmos-db-in-the-event-of-regional-outages">High availability on regional outages</seealso>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.GatewayModeMaxConnectionLimit">
            <summary>
            Get or set the maximum number of concurrent connections allowed for the target
            service endpoint in the Azure Cosmos DB service.
            </summary>
            <remarks>
            This setting is only applicable in Gateway mode.
            </remarks>
            <value>Default value is 50.</value>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConnectionModeGateway(System.Nullable{System.Int32},System.Net.IWebProxy)"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.RequestTimeout">
            <summary>
            Gets the request timeout in seconds when connecting to the Azure Cosmos DB service.
            The number specifies the time to wait for response to come back from network peer.
            </summary>
            <value>Default value is 1 minute.</value>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithRequestTimeout(System.TimeSpan)"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.TokenCredentialBackgroundRefreshInterval">
            <summary>
            The SDK does a background refresh based on the time interval set to refresh the token credentials.
            This avoids latency issues because the old token is used until the new token is retrieved.
            </summary>
            <remarks>
            The recommended minimum value is 5 minutes. The default value is 50% of the token expire time.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.CustomHandlers">
            <summary>
            Gets the handlers run before the process
            </summary>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.AddCustomHandlers(Microsoft.Azure.Cosmos.RequestHandler[])"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode">
            <summary>
            Get or set the connection mode used by the client when connecting to the Azure Cosmos DB service.
            </summary>
            <value>
            Default value is <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Direct"/>
            </value>
            <remarks>
            For more information, see <see href="https://docs.microsoft.com/azure/documentdb/documentdb-performance-tips#direct-connection">Connection policy: Use direct connection mode</see>.
            </remarks>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConnectionModeDirect"/>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConnectionModeGateway(System.Nullable{System.Int32},System.Net.IWebProxy)"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConsistencyLevel">
            <summary>
            This can be used to weaken the database account consistency level for read operations.
            If this is not set the database account consistency level will be used for all requests.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaxRetryAttemptsOnRateLimitedRequests">
             <summary>
             Gets or sets the maximum number of retries in the case where the request fails
             because the Azure Cosmos DB service has applied rate limiting on the client.
             </summary>
             <value>
             The default value is 9. This means in the case where the request is rate limited,
             the same request will be issued for a maximum of 10 times to the server before
             an error is returned to the application.
            
             If the value of this property is set to 0, there will be no automatic retry on rate
             limiting requests from the client and the exception needs to be handled at the
             application level.
             </value>
             <remarks>
             <para>
             When a client is sending requests faster than the allowed rate,
             the service will return HttpStatusCode 429 (Too Many Requests) to rate limit the client. The current
             implementation in the SDK will then wait for the amount of time the service tells it to wait and
             retry after the time has elapsed.
             </para>
             <para>
             For more information, see <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips#throughput">Handle rate limiting/request rate too large</see>.
             </para>
             </remarks>
             <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithThrottlingRetryOptions(System.TimeSpan,System.Int32)"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaxRetryWaitTimeOnRateLimitedRequests">
             <summary>
             Gets or sets the maximum retry time in seconds for the Azure Cosmos DB service.
             </summary>
             <value>
             The default value is 30 seconds. 
             </value>
             <remarks>
             <para>
             The minimum interval is seconds. Any interval that is smaller will be ignored.
             </para>
             <para>
             When a request fails due to a rate limiting error, the service sends back a response that
             contains a value indicating the client should not retry before the <see cref="P:Microsoft.Azure.Cosmos.CosmosException.RetryAfter"/> time period has
             elapsed.
            
             This property allows the application to set a maximum wait time for all retry attempts.
             If the cumulative wait time exceeds the this value, the client will stop retrying and return the error to the application.
             </para>
             <para>
             For more information, see <see href="https://docs.microsoft.com/azure/cosmos-db/performance-tips#throughput">Handle rate limiting/request rate too large</see>.
             </para>
             </remarks>
             <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithThrottlingRetryOptions(System.TimeSpan,System.Int32)"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.EnableContentResponseOnWrite">
            <summary>
            Gets or sets the boolean to only return the headers and status code in
            the Cosmos DB response for write item operation like Create, Upsert, Patch and Replace.
            Setting the option to false will cause the response to have a null resource. This reduces networking and CPU load by not sending
            the resource back over the network and serializing it on the client.
            </summary>
            <remarks>
            <para>This is optimal for workloads where the returned resource is not used.</para>
            <para>This option can be overriden by similar property in ItemRequestOptions and TransactionalBatchItemRequestOptions</para>
            </remarks>
            <seealso cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithContentResponseOnWrite(System.Boolean)"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.EnableContentResponseOnWrite"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions.EnableContentResponseOnWrite"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.IdleTcpConnectionTimeout">
            <summary>
            (Direct/TCP) Controls the amount of idle time after which unused connections are closed.
            </summary>
            <value>
            By default, idle connections are kept open indefinitely. Value must be greater than or equal to 10 minutes. Recommended values are between 20 minutes and 24 hours.
            </value>
            <remarks>
            Mainly useful for sparse infrequent access to a large database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.OpenTcpConnectionTimeout">
            <summary>
            (Direct/TCP) Controls the amount of time allowed for trying to establish a connection.
            </summary>
            <value>
            The default timeout is 5 seconds. Recommended values are greater than or equal to 5 seconds.
            </value>
            <remarks>
            When the time elapses, the attempt is cancelled and an error is returned. Longer timeouts will delay retries and failures.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaxRequestsPerTcpConnection">
            <summary>
            (Direct/TCP) Controls the number of requests allowed simultaneously over a single TCP connection. When more requests are in flight simultaneously, the direct/TCP client will open additional connections.
            </summary>
            <value>
            The default settings allow 30 simultaneous requests per connection.
            Do not set this value lower than 4 requests per connection or higher than 50-100 requests per connection.       
            The former can lead to a large number of connections to be created. 
            The latter can lead to head of line blocking, high latency and timeouts.
            </value>
            <remarks>
            Applications with a very high degree of parallelism per connection, with large requests or responses, or with very tight latency requirements might get better performance with 8-16 requests per connection.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaxTcpConnectionsPerEndpoint">
            <summary>
            (Direct/TCP) Controls the maximum number of TCP connections that may be opened to each Cosmos DB back-end.
            Together with MaxRequestsPerTcpConnection, this setting limits the number of requests that are simultaneously sent to a single Cosmos DB back-end(MaxRequestsPerTcpConnection x MaxTcpConnectionPerEndpoint).
            </summary>
            <value>
            The default value is 65,535. Value must be greater than or equal to 16.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.PortReuseMode">
            <summary>
            (Direct/TCP) Controls the client port reuse policy used by the transport stack.
            </summary>
            <value>
            The default value is PortReuseMode.ReuseUnicastPort.
            </value>
            <remarks>
            ReuseUnicastPort and PrivatePortPool are not mutually exclusive.
            When PrivatePortPool is enabled, the client first tries to reuse a port it already has.
            It falls back to allocating a new port if the initial attempts failed. If this fails, too, the client then falls back to ReuseUnicastPort.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.WebProxy">
            <summary>
            (Gateway/Https) Get or set the proxy information used for web requests.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.SerializerOptions">
            <summary>
            Get to set optional serializer options.
            </summary>
            <example>
            An example on how to configure the serialization option to ignore null values
            <code language="c#">
            <![CDATA[
            CosmosClientOptions clientOptions = new CosmosClientOptions()
            {
                SerializerOptions = new CosmosSerializationOptions(){
                    IgnoreNullValues = true
                }
            };
            
            CosmosClient client = new CosmosClient("endpoint", "key", clientOptions);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.Serializer">
            <summary>
            Get to set an optional JSON serializer. The client will use it to serialize or de-serialize user's cosmos request/responses.
            SDK owned types such as DatabaseProperties and ContainerProperties will always use the SDK default serializer.
            </summary>
            <example>
            An example on how to set a custom serializer. For basic serializer options look at CosmosSerializationOptions
            <code language="c#">
            <![CDATA[
            CosmosSerializer ignoreNullSerializer = new MyCustomIgnoreNullSerializer();
                    
            CosmosClientOptions clientOptions = new CosmosClientOptions()
            {
                Serializer = ignoreNullSerializer
            };
            
            CosmosClient client = new CosmosClient("endpoint", "key", clientOptions);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.LimitToEndpoint">
            <summary>
            Limits the operations to the provided endpoint on the CosmosClient.
            </summary>
            <value>
            Default value is false.
            </value>
            <remarks>
            When the value of this property is false, the SDK will automatically discover write and read regions, and use them when the configured application region is not available.
            When set to true, availability is limited to the endpoint specified on the CosmosClient constructor.
            Defining the <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationRegion"/> or <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationPreferredRegions"/>  is not allowed when setting the value to true.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/high-availability">High availability</seealso>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.AllowBulkExecution">
            <summary>
            Allows optimistic batching of requests to service. Setting this option might impact the latency of the operations. Hence this option is recommended for non-latency sensitive scenarios only.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.EnableTcpConnectionEndpointRediscovery">
            <summary>
            Gets or sets the flag to enable address cache refresh on TCP connection reset notification.
            </summary>
            <remarks>
            Does not apply if <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway"/> is used.
            </remarks>
            <value>
            The default value is true
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.HttpClientFactory">
            <summary>
            Gets or sets a delegate to use to obtain an HttpClient instance to be used for HTTPS communication.
            </summary>
            <remarks>
            <para>
            HTTPS communication is used when <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode"/> is set to <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway"/> for all operations and when <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode"/> is <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Direct"/> (default) for metadata operations.
            </para>
            <para>
            Useful in scenarios where the application is using a pool of HttpClient instances to be shared, like ASP.NET Core applications with IHttpClientFactory or Blazor WebAssembly applications.
            </para>
            <para>
            For .NET core applications the default GatewayConnectionLimit will be ignored. It must be set on the HttpClientHandler.MaxConnectionsPerServer to limit the number of connections
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.EnablePartitionLevelFailover">
            <summary>
            Enable partition key level failover
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionProtocol">
            <summary>
            Gets or sets the connection protocol when connecting to the Azure Cosmos service.
            </summary>
            <value>
            Default value is <see cref="F:Microsoft.Azure.Documents.Client.Protocol.Tcp"/>.
            </value>
            <remarks>
            This setting is not used when <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode"/> is set to <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway"/>.
            Gateway mode only supports HTTPS.
            For more information, see <see href="https://docs.microsoft.com/azure/documentdb/documentdb-performance-tips#use-tcp">Connection policy: Use the TCP protocol</see>.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.SendingRequestEventArgs">
            <summary>
            The event handler to be invoked before the request is sent.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.TransportClientHandlerFactory">
            <summary>
            (Optional) transport interceptor factory
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApiType">
            <summary>
            API type for the account
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.StoreClientFactory">
            <summary>
            Optional store client factory instance to use for all transport requests.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.InitialRetryForRetryWithMilliseconds">
            <summary>
            Gets or sets the initial delay retry time in milliseconds for the Azure Cosmos DB service
            for requests that hit RetryWithExceptions. This covers errors that occur due to concurrency errors in the store.
            </summary>
            <value>
            The default value is 1 second. For an example on how to set this value, please refer to <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures the client
            to delay the time specified before retrying the request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaximumRetryForRetryWithMilliseconds">
            <summary>
            Gets or sets the maximum delay retry time in milliseconds for the Azure Cosmos DB service
            for requests that hit RetryWithExceptions. This covers errors that occur due to concurrency errors in the store.
            </summary>
            <value>
            The default value is 30 seconds. For an example on how to set this value, please refer to <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures the maximum time
            the client should delay before failing the request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.RandomSaltForRetryWithMilliseconds">
            <summary>
            Gets or sets the interval to salt retry with value. This will spread the retry values from 1..n from the exponential back-off
            subscribed.
            </summary>
            <value>
            The default value is to not salt.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures the jitter on the retry attempted.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.TotalWaitTimeForRetryWithMilliseconds">
            <summary>
            Gets or sets the total time to wait before failing the request for retry with failures.
            subscribed.
            </summary>
            <value>
            The default value 30 seconds.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures total time spent waiting on the request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.EnableCpuMonitor">
            <summary>
            Flag that controls whether CPU monitoring thread is created to enrich timeout exceptions with additional diagnostic. Default value is true.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientOptions.EnableClientTelemetry">
            <summary>
            Flag to enable telemetry
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientOptions.GetRegionConfiguration">
            <summary>
            This generates a key that added to the user agent to make it 
            possible to determine if the SDK has region failover enabled.
            </summary>
            <returns>Format Reg-{D (Disabled discovery)}-S(application region)|L(List of preferred regions)|N(None, user did not configure it)</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientOptions.GetSerializedConfiguration">
            <summary>
            Serialize the current configuration into a JSON string
            </summary>
            <returns>Returns a JSON string of the current configuration.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosClientOptions.ClientOptionJsonConverter">
            <summary>
            The complex object passed in by the user can contain objects that can not be serialized. Instead just log the types.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosSqlQuerySpecJsonConverter">
            <summary>
            A custom serializer converter for SQL query spec
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosSqlQuerySpecJsonConverter.CreateSqlQuerySpecSerializer(Microsoft.Azure.Cosmos.CosmosSerializer,Microsoft.Azure.Cosmos.CosmosSerializer)">
            <summary>
            Only create a custom SQL query spec serializer if there is a customer serializer else
            use the default properties serializer
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Diagnostics.BoundedList`1">
            <summary>
             A list that can grow only up to a specified capacity.
             In the growth phase, it uses the standard List type.
             At capacity, it switches to a circular queue implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1">
            <summary>
             simple circular queue that preallocates the underlying buffer
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.Capacity">
            <summary>
            Capacity of the queue.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.Full">
            <summary>
            True if adding an element will cause one to be evicted.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.Empty">
            <summary>
            True when the queue is empty.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1"/> class.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.Add(`0)">
            <summary>
            Adds a new element to the queue. Can cause an older element to be evicted.
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a subrange of the argument to the queue depending on capacity.
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Diagnostics.CircularQueue`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosDiagnostics">
            <summary>
             Contains the cosmos diagnostic information for the current request to Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosDiagnostics.GetClientElapsedTime">
            <summary>
            This represent the end to end elapsed time of the request.
            If the request is still in progress it will return the current
            elapsed time since the start of the request.
            </summary>
            <returns>The clients end to end elapsed time of the request.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosDiagnostics.ToString">
            <summary>
            Gets the string field <see cref="T:Microsoft.Azure.Cosmos.CosmosDiagnostics"/> instance in the Azure CosmosDB database service.
            </summary>
            <returns>The string field <see cref="T:Microsoft.Azure.Cosmos.CosmosDiagnostics"/> instance in the Azure CosmosDB database service.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosDiagnostics.GetContactedRegions">
            <summary>
            Gets the list of all regions that were contacted for a request
            </summary>
            <returns>The list of tuples containing the Region name and the URI</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DocumentClient">
             <summary>
             Provides a client-side logical representation for the Azure Cosmos DB service.
             This client is used to configure and execute requests against the service.
             </summary>
             <threadSafety>
             This type is thread safe.
             </threadSafety>
             <remarks>
             The service client that encapsulates the endpoint and credentials and connection policy used to access the Azure Cosmos DB service.
             It is recommended to cache and reuse this instance within your application rather than creating a new instance for every operation.
            
             <para>
             When your app uses DocumentClient, you should call its IDisposable.Dispose implementation when you are finished using it.
             Depending on your programming technique, you can do this in one of two ways:
             </para>
            
             <para>
             1. By using a language construct such as the using statement in C#.
             The using statement is actually a syntactic convenience.
             At compile time, the language compiler implements the intermediate language (IL) for a try/catch block.
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("endpoint"), "authKey"))
             {
                 ...
             }
             ]]>
             </code>
             </para>
            
             <para>
             2. By wrapping the call to the IDisposable.Dispose implementation in a try/catch block.
             The following example replaces the using block in the previous example with a try/catch/finally block.
             <code language="c#">
             <![CDATA[
             IDocumentClient client = new DocumentClient(new Uri("endpoint"), "authKey"))
             try{
                 ...
             }
             finally{
                 if (client != null) client.Dispose();
             }
             ]]>
             </code>
             </para>
            
             </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.Security.SecureString,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified Azure Cosmos DB service endpoint, key, and connection policy for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">
            The service endpoint to use to create the client.
            </param>
            <param name="authKey">
            The list of Permission objects to use to create the client.
            </param>
            <param name="connectionPolicy">
            (Optional) The connection policy for the client. If none is passed, the default is used <see cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            </param>
            <param name="desiredConsistencyLevel">
            (Optional) This can be used to weaken the database account consistency level for read operations.
            If this is not set the database account consistency level will be used for all requests.
            </param>
            <remarks>
            The service endpoint and the authorization key can be obtained from the Azure Management Portal.
            The authKey used here is encrypted for privacy when being used, and deleted from computer memory when no longer needed
            <para>
            Using Direct connectivity, wherever possible, is recommended
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="T:System.Security.SecureString"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.Security.SecureString,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel},Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified Azure Cosmos DB service endpoint, key, connection policy and a custom JsonSerializerSettings
            for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">
            The service endpoint to use to create the client.
            </param>
            <param name="authKey">
            The list of Permission objects to use to create the client.
            </param>
            <param name="connectionPolicy">
            The connection policy for the client.
            </param>
            <param name="desiredConsistencyLevel">
            This can be used to weaken the database account consistency level for read operations.
            If this is not set the database account consistency level will be used for all requests.
            </param>
            <param name="serializerSettings">
            The custom JsonSerializer settings to be used for serialization/derialization.
            </param>
            <remarks>
            The service endpoint and the authorization key can be obtained from the Azure Management Portal.
            The authKey used here is encrypted for privacy when being used, and deleted from computer memory when no longer needed
            <para>
            Using Direct connectivity, wherever possible, is recommended
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="T:System.Security.SecureString"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
            <seealso cref="T:Newtonsoft.Json.JsonSerializerSettings"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.Security.SecureString,Newtonsoft.Json.JsonSerializerSettings,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified Azure Cosmos DB service endpoint, key, connection policy and a custom JsonSerializerSettings
            for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">
            The service endpoint to use to create the client.
            </param>
            <param name="authKey">
            The list of Permission objects to use to create the client.
            </param>
            <param name="serializerSettings">
            The custom JsonSerializer settings to be used for serialization/derialization.
            </param>
            <param name="connectionPolicy">
            (Optional) The connection policy for the client. If none is passed, the default is used <see cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            </param>
            <param name="desiredConsistencyLevel">
            (Optional) This can be used to weaken the database account consistency level for read operations.
            If this is not set the database account consistency level will be used for all requests.
            </param>
            <remarks>
            The service endpoint and the authorization key can be obtained from the Azure Management Portal.
            The authKey used here is encrypted for privacy when being used, and deleted from computer memory when no longer needed
            <para>
            Using Direct connectivity, wherever possible, is recommended
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="T:System.Security.SecureString"/>
            <seealso cref="T:Newtonsoft.Json.JsonSerializerSettings"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.String,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified service endpoint, an authorization key (or resource token) and a connection policy
            for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">The service endpoint to use to create the client.</param>
            <param name="authKeyOrResourceToken">The authorization key or resource token to use to create the client.</param>
            <param name="connectionPolicy">(Optional) The connection policy for the client.</param>
            <param name="desiredConsistencyLevel">(Optional) The default consistency policy for client operations.</param>
            <remarks>
            The service endpoint can be obtained from the Azure Management Portal.
            If you are connecting using one of the Master Keys, these can be obtained along with the endpoint from the Azure Management Portal
            If however you are connecting as a specific Azure Cosmos DB User, the value passed to <paramref name="authKeyOrResourceToken"/> is the ResourceToken obtained from the permission feed for the user.
            <para>
            Using Direct connectivity, wherever possible, is recommended.
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.String,System.Net.Http.HttpMessageHandler,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified service endpoint, an authorization key (or resource token) and a connection policy
            for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">The service endpoint to use to create the client.</param>
            <param name="authKeyOrResourceToken">The authorization key or resource token to use to create the client.</param>
            <param name="handler">The HTTP handler stack to use for sending requests (e.g., HttpClientHandler).</param>
            <param name="connectionPolicy">(Optional) The connection policy for the client.</param>
            <param name="desiredConsistencyLevel">(Optional) The default consistency policy for client operations.</param>
            <remarks>
            The service endpoint can be obtained from the Azure Management Portal.
            If you are connecting using one of the Master Keys, these can be obtained along with the endpoint from the Azure Management Portal
            If however you are connecting as a specific Azure Cosmos DB User, the value passed to <paramref name="authKeyOrResourceToken"/> is the ResourceToken obtained from the permission feed for the user.
            <para>
            Using Direct connectivity, wherever possible, is recommended.
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,Microsoft.Azure.Cosmos.AuthorizationTokenProvider,System.EventHandler{Microsoft.Azure.Documents.SendingRequestEventArgs},Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel},Newtonsoft.Json.JsonSerializerSettings,Microsoft.Azure.Documents.ApiType,System.EventHandler{Microsoft.Azure.Documents.ReceivedResponseEventArgs},System.Net.Http.HttpMessageHandler,Microsoft.Azure.Documents.ISessionContainer,System.Nullable{System.Boolean},System.Func{Microsoft.Azure.Documents.TransportClient,Microsoft.Azure.Documents.TransportClient},Microsoft.Azure.Documents.IStoreClientFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified service endpoint, an authorization key (or resource token) and a connection policy
            for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">The service endpoint to use to create the client.</param>
            <param name="cosmosAuthorization">The cosmos authorization for the client.</param>
            <param name="sendingRequestEventArgs"> The event handler to be invoked before the request is sent.</param>
            <param name="receivedResponseEventArgs"> The event handler to be invoked after a response has been received.</param>
            <param name="connectionPolicy">(Optional) The connection policy for the client.</param>
            <param name="desiredConsistencyLevel">(Optional) The default consistency policy for client operations.</param>
            <param name="serializerSettings">The custom JsonSerializer settings to be used for serialization/derialization.</param>
            <param name="apitype">Api type for the account</param>
            <param name="handler">The HTTP handler stack to use for sending requests (e.g., HttpClientHandler).</param>
            <param name="sessionContainer">The default session container with which DocumentClient is created.</param>
            <param name="enableCpuMonitor">Flag that indicates whether client-side CPU monitoring is enabled for improved troubleshooting.</param>
            <param name="transportClientHandlerFactory">Transport client handler factory.</param>
            <param name="storeClientFactory">Factory that creates store clients sharing the same transport client to optimize network resource reuse across multiple document clients in the same process.</param>
            <remarks>
            The service endpoint can be obtained from the Azure Management Portal.
            If you are connecting using one of the Master Keys, these can be obtained along with the endpoint from the Azure Management Portal
            If however you are connecting as a specific Azure Cosmos DB User, the value passed to is the ResourceToken obtained from the permission feed for the user.
            <para>
            Using Direct connectivity, wherever possible, is recommended.
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.String,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel},Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified service endpoint, an authorization key (or resource token), a connection policy
            and a custom JsonSerializerSettings for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">The service endpoint to use to create the client.</param>
            <param name="authKeyOrResourceToken">The authorization key or resource token to use to create the client.</param>
            <param name="connectionPolicy">The connection policy for the client.</param>
            <param name="desiredConsistencyLevel">The default consistency policy for client operations.</param>
            <param name="serializerSettings">The custom JsonSerializer settings to be used for serialization/derialization.</param>
            <remarks>
            The service endpoint can be obtained from the Azure Management Portal.
            If you are connecting using one of the Master Keys, these can be obtained along with the endpoint from the Azure Management Portal
            If however you are connecting as a specific Azure Cosmos DB User, the value passed to <paramref name="authKeyOrResourceToken"/> is the ResourceToken obtained from the permission feed for the user.
            <para>
            Using Direct connectivity, wherever possible, is recommended.
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
            <seealso cref="T:Newtonsoft.Json.JsonSerializerSettings"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.String,Newtonsoft.Json.JsonSerializerSettings,Microsoft.Azure.Cosmos.ConnectionPolicy,System.Nullable{Microsoft.Azure.Documents.ConsistencyLevel})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class using the
            specified service endpoint, an authorization key (or resource token), a connection policy
            and a custom JsonSerializerSettings for the Azure Cosmos DB service.
            </summary>
            <param name="serviceEndpoint">The service endpoint to use to create the client.</param>
            <param name="authKeyOrResourceToken">The authorization key or resource token to use to create the client.</param>
            <param name="serializerSettings">The custom JsonSerializer settings to be used for serialization/derialization.</param>
            <param name="connectionPolicy">(Optional) The connection policy for the client.</param>
            <param name="desiredConsistencyLevel">(Optional) The default consistency policy for client operations.</param>
            <remarks>
            The service endpoint can be obtained from the Azure Management Portal.
            If you are connecting using one of the Master Keys, these can be obtained along with the endpoint from the Azure Management Portal
            If however you are connecting as a specific Azure Cosmos DB User, the value passed to <paramref name="authKeyOrResourceToken"/> is the ResourceToken obtained from the permission feed for the user.
            <para>
            Using Direct connectivity, wherever possible, is recommended.
            </para>
            </remarks>
            <seealso cref="T:System.Uri"/>
            <seealso cref="T:Newtonsoft.Json.JsonSerializerSettings"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.#ctor(System.Uri,System.String)">
            <summary>
            Internal constructor purely for unit-testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.OpenAsync(System.Threading.CancellationToken)">
            <summary>
            Open the connection to validate that the client initialization is successful in the Azure Cosmos DB service.
            </summary>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> object.
            </returns>
            <remarks>
            This method is recommended to be called, after the constructor, but before calling any other methods on the DocumentClient instance.
            If there are any initialization exceptions, this method will throw them (set on the task).
            Alternately, calling any API will throw initialization exception at the first call.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                await client.OpenAsync();
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.Session">
            <summary>
            Gets or sets the session object used for session consistency version tracking in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <value>
            The session object used for version tracking when the consistency level is set to Session.
            </value>
            The session object can be saved and shared between two DocumentClient instances within the same AppDomain.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.GetSessionToken(System.String)">
            <summary>
            Gets or sets the session object used for session consistency version tracking for a specific collection in the Azure Cosmos DB service.
            </summary>
            <param name="collectionLink">Collection for which session token must be retrieved.</param>
            <value>
            The session token used for version tracking when the consistency level is set to Session.
            </value>
            <remarks>
            The session token can be saved and supplied to a request via <see cref="P:Microsoft.Azure.Documents.Client.RequestOptions.SessionToken"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.ApiType">
            <summary>
            Gets the Api type
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.ServiceEndpoint">
            <summary>
            Gets the endpoint Uri for the service endpoint from the Azure Cosmos DB service.
            </summary>
            <value>
            The Uri for the service endpoint.
            </value>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.WriteEndpoint">
            <summary>
            Gets the current write endpoint chosen based on availability and preference from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.ReadEndpoint">
            <summary>
            Gets the current read endpoint chosen based on availability and preference from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.ConnectionPolicy">
            <summary>
            Gets the Connection policy used by the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The Connection policy used by the client.
            </value>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.AuthKey">
            <summary>
            Gets the AuthKey used by the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The AuthKey used by the client.
            </value>
            <seealso cref="T:System.Security.SecureString"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.ConsistencyLevel">
            <summary>
            Gets the configured consistency level of the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The configured <see cref="T:Microsoft.Azure.Cosmos.ConsistencyLevel"/> of the client.
            </value>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.Dispose">
            <summary>
            Disposes the client for the Azure Cosmos DB service.
            </summary>
            <example>
            <code language="c#">
            <![CDATA[
            IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key");
            if (client != null) client.Dispose();
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.ResetSessionTokenRetryPolicy">
            <summary>
            RetryPolicy retries a request when it encounters session unavailable (see ClientRetryPolicy).
            Once it exhausts all write regions it clears the session container, then it uses ClientCollectionCache
            to resolves the request's collection name. If it differs from the session container's resource id it
            explains the session unavailable exception: somebody removed and recreated the collection. In this
            case we retry once again (with empty session token) otherwise we return the error to the client
            (see RenameCollectionAwareClientRetryPolicy)
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.StoreModel">
            <summary>
            Gets and sets the IStoreModel object.
            </summary>
            <remarks>
            Test hook to enable unit test of DocumentClient.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.GatewayStoreModel">
            <summary>
            Gets and sets the gateway IStoreModel object.
            </summary>
            <remarks>
            Test hook to enable unit test of DocumentClient.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentClient.OnExecuteScalarQueryCallback">
            <summary>
            Gets and sets on execute scalar query callback
            </summary>
            <remarks>
            Test hook to enable unit test for scalar queries
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDatabaseAsync(Microsoft.Azure.Documents.Database,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a database resource as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="database">The specification for the <see cref="T:Microsoft.Azure.Cosmos.Database"/> to create.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Database"/> that was created within a task object representing the service response for the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="database"/> is not set.</exception>
            <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Database are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>400</term><description>BadRequest - This means something was wrong with the database object supplied. It is likely that an id was not supplied for the new Database.</description>
                </item>
                <item>
                    <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an id matching the id field of <paramref name="database"/> already existed.</description>
                </item>
            </list>
            </exception>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an Id property of 'MyDatabase'
            This code snippet is intended to be used from within an asynchronous method as it uses the await keyword
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = await client.CreateDatabaseAsync(new Database { Id = "MyDatabase" });
            }
            ]]>
            </code>
            </example>
            <example>
            If you would like to construct a <see cref="T:Microsoft.Azure.Cosmos.Database"/> from within a synchronous method then you need to use the following code
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = client.CreateDatabaseAsync(new Database { Id = "MyDatabase" }).Result;
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDatabaseIfNotExistsAsync(Microsoft.Azure.Documents.Database,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates(if doesn't exist) or gets(if already exists) a database resource as an asychronous operation in the Azure Cosmos DB service.
            You can check the status code from the response to determine whether the database was newly created(201) or existing database was returned(200)
            </summary>
            <param name="database">The specification for the <see cref="T:Microsoft.Azure.Cosmos.Database"/> to create.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Database"/> that was created within a task object representing the service response for the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="database"/> is not set.</exception>
            <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property.</exception>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an Id property of 'MyDatabase'
            This code snippet is intended to be used from within an asynchronous method as it uses the await keyword
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = await client.CreateDatabaseIfNotExistsAsync(new Database { Id = "MyDatabase" });
            }
            ]]>
            </code>
            </example>
            <example>
            If you would like to construct a <see cref="T:Microsoft.Azure.Cosmos.Database"/> from within a synchronous method then you need to use the following code
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = client.CreateDatabaseIfNotExistsAsync(new Database { Id = "MyDatabase" }).Result;
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentAsync(System.String,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
             <summary>
             Creates a Document as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="documentsFeedOrDatabaseLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to create the document in. E.g. dbs/db_rid/colls/coll_rid/ </param>
             <param name="document">The document object to create.</param>
             <param name="options">(Optional) Any request options you wish to set. E.g. Specifying a Trigger to execute when creating the document. <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/></param>
             <param name="disableAutomaticIdGeneration">(Optional) Disables the automatic id generation, If this is True the system will throw an exception if the id property is missing from the Document.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.Document"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="documentsFeedOrDatabaseLink"/> or <paramref name="document"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the document supplied. It is likely that <paramref name="disableAutomaticIdGeneration"/> was true and an id was not supplied</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This likely means the collection in to which you were trying to create the document is full.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Document"/> with an id matching the id field of <paramref name="document"/> already existed</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the <see cref="T:Microsoft.Azure.Documents.Document"/> exceeds the current max entity size. Consult documentation for limits and quotas.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             Azure Cosmos DB supports a number of different ways to work with documents. A document can extend <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyObject : Resource
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyObject { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             A document can be any POCO object that can be serialized to JSON, even if it doesn't extend from <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyPOCO
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyPOCO { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             Finally, a Document can also be a dynamic object
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync("dbs/db_rid/colls/coll_rid/", new { SomeProperty = "A Value" } );
             }
             ]]>
             </code>
             </example>
             <example>
             Create a Document and execute a Pre and Post Trigger
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync(
                     "dbs/db_rid/colls/coll_rid/",
                     new { id = "DOC123213443" },
                     new RequestOptions
                     {
                         PreTriggerInclude = new List<string> { "MyPreTrigger" },
                         PostTriggerInclude = new List<string> { "MyPostTrigger" }
                     });
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a collection as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="databaseLink">The link of the database to create the collection in. E.g. dbs/db_rid/.</param>
             <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="documentCollection"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a collection are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an id was not supplied for the new collection.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This means you attempted to exceed your quota for collections. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> with an id matching the id you supplied already existed.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 //Create a new collection with an OfferThroughput set to 10000
                 //Not passing in RequestOptions.OfferThroughput will result in a collection with the default OfferThroughput set.
                 DocumentCollection coll = await client.CreateDocumentCollectionAsync(databaseLink,
                     new DocumentCollection { Id = "My Collection" },
                     new RequestOptions { OfferThroughput = 10000} );
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.OfferV2"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionIfNotExistsAsync(System.String,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates (if doesn't exist) or gets (if already exists) a collection as an asychronous operation in the Azure Cosmos DB service.
             You can check the status code from the response to determine whether the collection was newly created (201) or existing collection was returned (200).
             </summary>
             <param name="databaseLink">The link of the database to create the collection in. E.g. dbs/db_rid/.</param>
             <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="documentCollection"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a DocumentCollection are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an id was not supplied for the new collection.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This means you attempted to exceed your quota for collections. Contact support to have this quota increased.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 //Create a new collection with an OfferThroughput set to 10000
                 //Not passing in RequestOptions.OfferThroughput will result in a collection with the default OfferThroughput set.
                 DocumentCollection coll = await client.CreateDocumentCollectionIfNotExistsAsync(databaseLink,
                     new DocumentCollection { Id = "My Collection" },
                     new RequestOptions { OfferThroughput = 10000} );
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.OfferV2"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.RestoreDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.DocumentCollection,System.Nullable{System.DateTimeOffset},Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Restores a collection as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="sourceDocumentCollectionLink">The link to the source <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
            <param name="targetDocumentCollection">The target <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
            <param name="restoreTime">(optional)The point in time to restore. If null, use the latest restorable time. </param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.GetDocumentCollectionRestoreStatusAsync(System.String)">
            <summary>
            Get the status of a collection being restored in the Azure Cosmos DB service.
            </summary>
            <param name="targetDocumentCollectionLink">The link of the document collection being restored.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureAsync(System.String,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a stored procedure as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the collection to create the stored procedure in. E.g. dbs/db_rid/colls/col_rid/</param>
             <param name="storedProcedure">The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> object to create.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="storedProcedure"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the stored procedure or the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of stored procedures for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> you tried to create was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a new stored procedure called "HelloWorldSproc" that takes in a single param called "name".
             StoredProcedure sproc = await client.CreateStoredProcedureAsync(collectionLink, new StoredProcedure
             {
                Id = "HelloWorldSproc",
                Body = @"function (name){
                            var response = getContext().getResponse();
                            response.setBody('Hello ' + name);
                         }"
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerAsync(System.String,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a trigger as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to create the trigger in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="trigger">The <see cref="T:Microsoft.Azure.Documents.Trigger"/> object to create.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="trigger"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new trigger or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of triggers for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Trigger"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.Trigger"/> you tried to create was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a trigger that validates the contents of a document as it is created and adds a 'timestamp' property if one was not found.
             Trigger trig = await client.CreateTriggerAsync(collectionLink, new Trigger
             {
                 Id = "ValidateDocuments",
                 Body = @"function validate() {
                                     var context = getContext();
                                     var request = context.getRequest();                                                             
                                     var documentToCreate = request.getBody();
                                     
                                     // validate properties
                                     if (!('timestamp' in documentToCreate)) {
                                         var ts = new Date();
                                         documentToCreate['timestamp'] = ts.getTime();
                                     }
                                     
                                     // update the document that will be created
                                     request.setBody(documentToCreate);
                                   }",
                 TriggerType = TriggerType.Pre,
                 TriggerOperation = TriggerOperation.Create
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a user defined function as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to create the user defined function in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="function">The <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> object to create.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="function"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new user defined function or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of user defined functions for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> you tried to create was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a user defined function that converts a string to upper case
             UserDefinedFunction udf = client.CreateUserDefinedFunctionAsync(collectionLink, new UserDefinedFunction
             {
                Id = "ToUpper",
                Body = @"function toUpper(input) {
                                    return input.toUpperCase();
                                 }",
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeAsync(System.String,Microsoft.Azure.Documents.UserDefinedType,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a user defined type object as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="databaseLink">The link of the database to create the user defined type in. E.g. dbs/db_rid/ </param>
             <param name="userDefinedType">The <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> object to create.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>A task object representing the service response for the asynchronous operation which contains the created <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> object.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="userDefinedType"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a UserDefinedType are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of user defined type objects for this database. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> with an id matching the id you supplied already existed.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a new user defined type in the specified database
             UserDefinedType userDefinedType = await client.CreateUserDefinedTypeAsync(databaseLink, new UserDefinedType { Id = "userDefinedTypeId5" });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateSnapshotAsync(Microsoft.Azure.Documents.Snapshot,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a snapshot resource as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="snapshot">The specification for the <see cref="T:Microsoft.Azure.Documents.Snapshot"/> to create.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The <see cref="T:Microsoft.Azure.Documents.Snapshot"/> that was created within a task object representing the service response for the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="snapshot"/> is not set.</exception>
            <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Database are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>400</term><description>BadRequest - This means something was wrong with the snapshot object supplied. It is likely that the resource link specified for the Snapshot was invalid.</description>
                </item>
                <item>
                    <term>409</term>
                    <description>
                    Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> with an id matching the id field of <paramref name="snapshot"/> already existed,
                    or there is already a pending snapshot for the specified resource link.
                    </description>
                </item>
            </list>
            </exception>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Documents.Snapshot"/> with an Id property of 'MySnapshot'. The ResourceLink indicates that
            the snapshot should be created for the collection named "myContainer" in the database "myDatabase".
            This code snippet is intended to be used from within an asynchronous method as it uses the await keyword
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Snapshot snapshot = await client.CreateSnapshotAsync(new Snapshot { Id = "MySnapshot", ResourceLink = ResourceLink = "dbs/myDatabase/colls/myContainer" });
            }
            ]]>
            </code>
            </example>
            <example>
            If you would like to construct a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> from within a synchronous method then you need to use the following code
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Snapshot snapshot = client.CreateSnapshotAsync(new Snapshot { Id = "MySnapshot", ResourceLink = ResourceLink = "dbs/myDatabase/colls/myContainer" });.Result;
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Snapshot"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteDatabaseAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Database"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="databaseLink">The link of the <see cref="T:Microsoft.Azure.Documents.Database"/> to delete. E.g. dbs/db_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="databaseLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a database using its selfLink property
            //To get the databaseLink you would have to query for the Database, using CreateDatabaseQuery(),  and then refer to its .SelfLink property
            await client.DeleteDatabaseAsync(databaseLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteDocumentAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Document"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentLink">The link of the <see cref="T:Microsoft.Azure.Documents.Document"/> to delete. E.g. dbs/db_rid/colls/col_rid/docs/doc_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a document using its selfLink property
            //To get the documentLink you would have to query for the Document, using CreateDocumentQuery(),  and then refer to its .SelfLink property
            await client.DeleteDocumentAsync(documentLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentCollectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.Document"/> to delete. E.g. dbs/db_rid/colls/col_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentCollectionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a collection using its selfLink property
            //To get the collectionLink you would have to query for the Collection, using CreateDocumentCollectionQuery(),  and then refer to its .SelfLink property
            await client.DeleteDocumentCollectionAsync(collectionLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteStoredProcedureAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="storedProcedureLink">The link of the <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> to delete. E.g. dbs/db_rid/colls/col_rid/sprocs/sproc_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a stored procedure using its selfLink property.
            //To get the sprocLink you would have to query for the Stored Procedure, using CreateStoredProcedureQuery(),  and then refer to its .SelfLink property
            await client.DeleteStoredProcedureAsync(sprocLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteTriggerAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Trigger"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="triggerLink">The link of the <see cref="T:Microsoft.Azure.Documents.Trigger"/> to delete. E.g. dbs/db_rid/colls/col_rid/triggers/trigger_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="triggerLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a trigger using its selfLink property.
            //To get the triggerLink you would have to query for the Trigger, using CreateTriggerQuery(),  and then refer to its .SelfLink property
            await client.DeleteTriggerAsync(triggerLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="functionLink">The link of the <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> to delete. E.g. dbs/db_rid/colls/col_rid/udfs/udf_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="functionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a user defined function using its selfLink property.
            //To get the functionLink you would have to query for the User Defined Function, using CreateUserDefinedFunctionQuery(),  and then refer to its .SelfLink property
            await client.DeleteUserDefinedFunctionAsync(functionLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteConflictAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Conflict"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="conflictLink">The link of the <see cref="T:Microsoft.Azure.Documents.Conflict"/> to delete. E.g. dbs/db_rid/colls/coll_rid/conflicts/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="conflictLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a conflict using its selfLink property.
            //To get the conflictLink you would have to query for the Conflict object, using CreateConflictQuery(), and then refer to its .SelfLink property
            await client.DeleteConflictAsync(conflictLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteSnapshotAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="snapshotLink">The link of the <see cref="T:Microsoft.Azure.Documents.Snapshot"/> to delete. E.g. snapshots/snapshot_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="snapshotLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a snapshot using its selfLink property
            //To get the snapshot you would have to query for the Snapshot, using CreateSnapshotQuery(),  and then refer to its .SelfLink property
            await client.DeleteSnapshotAsync(snapshotLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Snapshot"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceDocumentCollectionAsync(Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a document collection in the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentCollection">the updated document collection.</param>
            <param name="options">the request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the updated resource record.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceDocumentAsync(System.String,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Document"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="documentLink">The link of the document to be updated. E.g. dbs/db_rid/colls/col_rid/docs/doc_rid/ </param>
             <param name="document">The updated <see cref="T:Microsoft.Azure.Documents.Document"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="documentLink"/> or <paramref name="document"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             In this example, instead of using a strongly typed <see cref="T:Microsoft.Azure.Documents.Document"/>, we will work with our own POCO object and not rely on the dynamic nature of the Document class.
             <code language="c#">
             <![CDATA[
             public class MyPoco
             {
                 public string Id {get; set;}
                 public string MyProperty {get; set;}
             }
            
             //Get the doc back as a Document so you have access to doc.SelfLink
             Document doc = client.CreateDocumentQuery<Document>(collectionLink)
                                    .Where(r => r.Id == "doc id")
                                    .AsEnumerable()
                                    .SingleOrDefault();
            
             //Now dynamically cast doc back to your MyPoco
             MyPoco poco = (dynamic)doc;
            
             //Update some properties of the poco object
             poco.MyProperty = "updated value";
            
             //Now persist these changes to the database using doc.SelLink and the update poco object
             Document updated = await client.ReplaceDocumentAsync(doc.SelfLink, poco);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceDocumentAsync(Microsoft.Azure.Documents.Document,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Document"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="document">The updated <see cref="T:Microsoft.Azure.Documents.Document"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="document"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             This example uses <see cref="T:Microsoft.Azure.Documents.Document"/> and takes advantage of the fact that it is a dynamic object and uses SetProperty to dynamically update properties on the document
             <code language="c#">
             <![CDATA[
             //Fetch the Document to be updated
             Document doc = client.CreateDocumentQuery<Document>(collectionLink)
                                         .Where(r => r.Id == "doc id")
                                         .AsEnumerable()
                                         .SingleOrDefault();
            
             //Update some properties on the found resource
             doc.SetPropertyValue("MyProperty", "updated value");
            
             //Now persist these changes to the database by replacing the original resource
             Document updated = await client.ReplaceDocumentAsync(doc);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceStoredProcedureAsync(Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="storedProcedure">The updated <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedure"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             StoredProcedure sproc = client.CreateStoredProcedureQuery(sprocsLink)
                                              .Where(r => r.Id == "sproc id")
                                              .AsEnumerable()
                                              .SingleOrDefault();
            
             //Update some properties on the found resource
             sproc.Body = "function () {new javascript body for sproc}";
            
             //Now persist these changes to the database by replacing the original resource
             StoredProcedure updated = await client.ReplaceStoredProcedureAsync(sproc);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceTriggerAsync(Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Trigger"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="trigger">The updated <see cref="T:Microsoft.Azure.Documents.Trigger"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="trigger"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             Trigger trigger = client.CreateTriggerQuery(sprocsLink)
                                           .Where(r => r.Id == "trigger id")
                                           .AsEnumerable()
                                           .SingleOrDefault();
            
             //Update some properties on the found resource
             trigger.Body = "function () {new javascript body for trigger}";
            
             //Now persist these changes to the database by replacing the original resource
             Trigger updated = await client.ReplaceTriggerAsync(sproc);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceUserDefinedFunctionAsync(Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="function">The updated <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="function"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(functionsLink)
                                                 .Where(r => r.Id == "udf id")
                                                 .AsEnumerable()
                                                 .SingleOrDefault();
            
             //Update some properties on the found resource
             udf.Body = "function () {new javascript body for udf}";
            
             //Now persist these changes to the database by replacing the original resource
             UserDefinedFunction updated = await client.ReplaceUserDefinedFunctionAsync(udf);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceOfferAsync(Microsoft.Azure.Documents.Offer)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Offer"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="offer">The updated <see cref="T:Microsoft.Azure.Documents.Offer"/> to replace the existing resource with.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Offer"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="offer"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
                 <item>
                    <term>429</term><description>TooManyRequests - The replace offer is throttled as the offer scale down operation is attempted within the idle timeout period of 4 hours. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             Offer offer = client.CreateOfferQuery()
                                      .Where(r => r.ResourceLink == "collection selfLink")
                                      .AsEnumerable()
                                      .SingleOrDefault();
            
             //Create a new offer with the changed throughput
             OfferV2 newOffer = new OfferV2(offer, 5000);
            
             //Now persist these changes to the database by replacing the original resource
             Offer updated = await client.ReplaceOfferAsync(newOffer);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceUserDefinedTypeAsync(Microsoft.Azure.Documents.UserDefinedType,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="userDefinedType">The updated <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="userDefinedType"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             UserDefinedType userDefinedType = client.CreateUserDefinedTypeQuery(userDefinedTypesLink)
                                      .Where(r => r.Id == "user defined type id")
                                      .AsEnumerable()
                                      .SingleOrDefault();
            
             //Now persist these changes to the database by replacing the original resource
             UserDefinedType updated = await client.ReplaceUserDefinedTypeAsync(userDefinedType);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDatabaseAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Database"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="databaseLink">The link of the Database resource to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Database"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="databaseLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Database resource where
            // - database_id is the ID property of the Database resource you wish to read.
            var dbLink = "/dbs/database_id";
            Database database = await client.ReadDatabaseAsync(dbLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Database if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="databaseLink"/> is always "/dbs/{db identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentLink">The link for the document to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a document record from a database & collection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - document_id is the ID of the document resource
            var docLink = "dbs/sample_database/colls/sample_collection/docs/document_id";
            Document doc = await client.ReadDocumentAsync(docLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Document if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentLink"/> is always "dbs/{db identifier}/colls/{coll identifier}/docs/{doc identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentAsync``1(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> as a generic type T from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentLink">The link for the document to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a document record from a database & collection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - document_id is the ID of the document resource
            var docLink = "dbs/sample_database/colls/sample_collection/docs/document_id";
            Customer customer = await client.ReadDocumentAsync<Customer>(docLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Document if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentLink"/> is always "dbs/{db identifier}/colls/{coll identifier}/docs/{doc identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentCollectionLink">The link for the DocumentCollection to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentCollectionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a DocumentCollection record from a database where
            // - sample_database is the ID of the database
            // - collection_id is the ID of the collection resource to be read
            var collLink = "/dbs/sample_database/colls/collection_id";
            DocumentCollection coll = await client.ReadDocumentCollectionAsync(collLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the DocumentCollection if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentCollectionLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadStoredProcedureAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="storedProcedureLink">The link of the stored procedure to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a StoredProcedure from a Database and DocumentCollection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - sproc_id is the ID of the stored procedure to be read
            var sprocLink = "/dbs/sample_database/colls/sample_collection/sprocs/sproc_id";
            StoredProcedure sproc = await client.ReadStoredProcedureAsync(sprocLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Stored Procedure if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="storedProcedureLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/sprocs/{sproc identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadTriggerAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Trigger"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="triggerLink">The link to the Trigger to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="triggerLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Trigger from a Database and DocumentCollection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - trigger_id is the ID of the trigger to be read
            var triggerLink = "/dbs/sample_database/colls/sample_collection/triggers/trigger_id";
            Trigger trigger = await client.ReadTriggerAsync(triggerLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Trigger if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="triggerLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/triggers/{trigger identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="functionLink">The link to the User Defined Function to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="functionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a User Defined Function from a Database and DocumentCollection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - udf_id is the ID of the user-defined function to be read
            var udfLink = "/dbs/sample_database/colls/sample_collection/udfs/udf_id";
            UserDefinedFunction udf = await client.ReadUserDefinedFunctionAsync(udfLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the User Defined Function if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="functionLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/udfs/{udf identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadConflictAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Conflict"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="conflictLink">The link to the Conflict to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Conflict"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="conflictLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Conflict resource from a Database
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - conflict_id is the ID of the conflict to be read
            var conflictLink = "/dbs/sample_database/colls/sample_collection/conflicts/conflict_id";
            Conflict conflict = await client.ReadConflictAsync(conflictLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Conflict if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="conflictLink"/> is always "/dbs/{db identifier}/colls/{collectioon identifier}/conflicts/{conflict identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadOfferAsync(System.String)">
            <summary>
            Reads an <see cref="T:Microsoft.Azure.Documents.Offer"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="offerLink">The link to the Offer to be read.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Offer"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="offerLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads an Offer resource from a Database
            // - offer_id is the ID of the offer to be read
            var offerLink = "/offers/offer_id";
            Offer offer = await client.ReadOfferAsync(offerLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            For an Offer, id is always generated internally by the system when the linked resource is created. id and _rid are always the same for Offer.
            </para>
            <para>
            Refer to https://docs.microsoft.com/en-us/azure/cosmos-db/how-to-provision-container-throughput to learn more about 
            minimum throughput of a Cosmos container (or a database)
            To retrieve the minimum throughput for a collection/database, use the following sample 
            <code language="c#">
            <![CDATA[
            // Find the offer for the collection by SelfLink
            Offer offer = client.CreateOfferQuery(
                string.Format("SELECT * FROM offers o WHERE o.resource = '{0}'", collectionSelfLink)).AsEnumerable().FirstOrDefault();
            ResourceResponse<Offer> response = await client.ReadOfferAsync(offer.SelfLink);
            string minimumRUsForCollection = readResponse.Headers["x-ms-cosmos-min-throughput"];
            ]]>
            </code>
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSchemaAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Schema"/> as an asynchronous operation.
            </summary>
            <param name="documentSchemaLink">The link for the schema to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentSchemaLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Schema are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a schema record from a database & collection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - schema_id is the ID of the document resource
            var docLink = "/dbs/sample_database/colls/sample_collection/schemas/schemas_id";
            Schema schema = await client.ReadSchemaAsync(docLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Document if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentSchemaLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/schema/{schema identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Schema"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedTypeAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="userDefinedTypeLink">The link to the UserDefinedType resource to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="userDefinedTypeLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a UserDefinedType are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a User resource from a Database
            // - sample_database is the ID of the database
            // - userDefinedType_id is the ID of the user defined type to be read
            var userDefinedTypeLink = "/dbs/sample_database/udts/userDefinedType_id";
            UserDefinedType userDefinedType = await client.ReadUserDefinedTypeAsync(userDefinedTypeLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown user defined type ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the UserDefinedType if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="userDefinedTypeLink"/> is always "/dbs/{db identifier}/udts/{user defined type identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSnapshotAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="snapshotLink">The link of the Snapshot resource to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="snapshotLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Snapshot are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Snapshot resource where
            // - snapshot_id is the ID property of the Snapshot resource you wish to read.
            var snapshotLink = "/snapshots/snapshot_id";
            Snapshot snapshot= await client.ReadSnapshotAsync(snapshotLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Azure Cosmos DB service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Snapshot if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="snapshotLink"/> is always "/snapshots/{snapshot identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Snapshot"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDatabaseFeedAsync(Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Database"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Database"/> containing the read resource record.
             </returns>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Database> response = await client.ReadDatabaseFeedAsync(new FeedOptions
                                                                             {
                                                                                 MaxItemCount = 10,
                                                                                 RequestContinuation = continuation
                                                                             });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Database"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadPartitionKeyRangeFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="partitionKeyRangesOrCollectionLink">The link of the resources to be read, or owner collection link, SelfLink or AltLink. E.g. /dbs/db_rid/colls/coll_rid/pkranges</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Database"/> containing the read resource record.
            </returns>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            DoucmentFeedResponse<PartitionKeyRange> response = null;
            List<string> ids = new List<string>();
            do
            {
                response = await client.ReadPartitionKeyRangeFeedAsync(collection.SelfLink, new FeedOptions { MaxItemCount = 1000 });
                foreach (var item in response)
                {
                    ids.Add(item.Id);
                }
            }
            while (!string.IsNullOrEmpty(response.ResponseContinuation));
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.FeedOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentFeedResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentCollectionFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> for a database from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="collectionsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="collectionsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<DocumentCollection> response = await client.ReadDocumentCollectionFeedAsync("/dbs/db_rid/colls/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadStoredProcedureFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="storedProceduresLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/col_rid/sprocs/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProceduresLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<StoredProcedure> response = await client.ReadStoredProcedureFeedAsync("/dbs/db_rid/colls/col_rid/sprocs/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadTriggerFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Trigger"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="triggersLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/col_rid/triggers/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="triggersLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Trigger> response = await client.ReadTriggerFeedAsync("/dbs/db_rid/colls/col_rid/triggers/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedFunctionFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="userDefinedFunctionsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/col_rid/udfs/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="userDefinedFunctionsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<UserDefinedFunction> response = await client.ReadUserDefinedFunctionFeedAsync("/dbs/db_rid/colls/col_rid/udfs/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Threading.CancellationToken)">
             <summary>
             Reads the feed (sequence) of documents for a specified collection from the Azure Cosmos DB service.
             This takes returns a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain an enumerable list of dynamic objects.
             </summary>
             <param name="documentsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/coll_rid/docs/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> containing dynamic objects representing the items in the feed.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="documentsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<dynamic> response = await client.ReadDocumentFeedAsync("/dbs/db_rid/colls/coll_rid/docs/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <remarks>
             Instead of DoucmentFeedResponse{Document} this method takes advantage of dynamic objects in .NET. This way a single feed result can contain any kind of Document, or POCO object.
             This is important becuse a DocumentCollection can contain different kinds of documents.
             </remarks>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadConflictFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Conflict"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="conflictsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/coll_rid/conflicts/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Conflict"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="conflictsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Conflict> response = await client.ReadConflictAsync("/dbs/db_rid/colls/coll_rid/conflicts/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadOffersFeedAsync(Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Offer"/> for a database account from the Azure Cosmos DB service
             as an asynchronous operation.
             </summary>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Offer"/> containing the read resource record.
             </returns>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Offer> response = await client.ReadOfferAsync(new FeedOptions
                                                                             {
                                                                                 MaxItemCount = 10,
                                                                                 RequestContinuation = continuation
                                                                             });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSchemaFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Schema"/> for a collection as an asynchronous operation.
             </summary>
             <param name="documentCollectionSchemaLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/coll_rid/schemas </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Schema"/> containing the read resource record.
             </returns>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<User> response = await client.ReadUserFeedAsync("/dbs/db_rid/colls/coll_rid/schemas",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Schema"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedTypeFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> for a database from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="userDefinedTypesLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/udts/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="userDefinedTypesLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a UserDefinedType are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<UserDefinedType> response = await client.ReadUserDefinedTypeFeedAsync("/dbs/db_rid/udts/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSnapshotFeedAsync(Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Snapshot"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DocumentFeedResponse`1"/> which wraps a set of <see cref="T:Microsoft.Azure.Documents.Snapshot"/> containing the read resource record.
             </returns>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DocumentFeedResponse<Snapshot> response = await client.ReadSnapshotFeedAsync(new FeedOptions
                                                                             {
                                                                                 MaxItemCount = 10,
                                                                                 RequestContinuation = continuation
                                                                             });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Snapshot"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ExecuteStoredProcedureAsync``1(System.String,System.Object[])">
             <summary>
             Executes a stored procedure against a collection as an asynchronous operation in the Azure Cosmos DB service.
             </summary>
             <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
             <param name="storedProcedureLink">The link to the stored procedure to execute.</param>
             <param name="procedureParams">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <example>
             <code language="c#">
             <![CDATA[
             //Execute a StoredProcedure with ResourceId of "sproc_rid" that takes two "Player" documents, does some stuff, and returns a bool
             StoredProcedureResponse<bool> sprocResponse = await client.ExecuteStoredProcedureAsync<bool>(
                                                                     "/dbs/db_rid/colls/col_rid/sprocs/sproc_rid/",
                                                                     new Player { id="1", name="joe" } ,
                                                                     new Player { id="2", name="john" }
                                                                 );
            
             if (sprocResponse.Response) Console.WriteLine("Congrats, the stored procedure did some stuff");
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ExecuteStoredProcedureAsync``1(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Object[])">
             <summary>
             Executes a stored procedure against a partitioned collection in the Azure Cosmos DB service as an asynchronous operation, specifiying a target partition.
             </summary>
             <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
             <param name="storedProcedureLink">The link to the stored procedure to execute.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="procedureParams">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <example>
             <code language="c#">
             <![CDATA[
             //Execute a StoredProcedure with ResourceId of "sproc_rid" that takes two "Player" documents, does some stuff, and returns a bool
             StoredProcedureResponse<bool> sprocResponse = await client.ExecuteStoredProcedureAsync<bool>(
                                                                     "/dbs/db_rid/colls/col_rid/sprocs/sproc_rid/",
                                                                     new RequestOptions { PartitionKey = new PartitionKey(1) },
                                                                     new Player { id="1", name="joe" } ,
                                                                     new Player { id="2", name="john" }
                                                                 );
            
             if (sprocResponse.Response) Console.WriteLine("Congrats, the stored procedure did some stuff");
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ExecuteStoredProcedureAsync``1(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken,System.Object[])">
             <summary>
             Executes a stored procedure against a partitioned collection in the Azure Cosmos DB service as an asynchronous operation, specifiying a target partition.
             </summary>
             <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
             <param name="storedProcedureLink">The link to the stored procedure to execute.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <param name="procedureParams">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <example>
             <code language="c#">
             <![CDATA[
             //Execute a StoredProcedure with ResourceId of "sproc_rid" that takes two "Player" documents, does some stuff, and returns a bool
             StoredProcedureResponse<bool> sprocResponse = await client.ExecuteStoredProcedureAsync<bool>(
                                                                     "/dbs/db_rid/colls/col_rid/sprocs/sproc_rid/",
                                                                     new RequestOptions { PartitionKey = new PartitionKey(1) },
                                                                     new Player { id="1", name="joe" } ,
                                                                     new Player { id="2", name="john" }
                                                                 );
            
             if (sprocResponse.Response) Console.WriteLine("Congrats, the stored procedure did some stuff");
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertDatabaseAsync(Microsoft.Azure.Documents.Database,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a database resource as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="database">The specification for the <see cref="T:Microsoft.Azure.Cosmos.Database"/> to upsert.</param>
             <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
             <returns>The <see cref="T:Microsoft.Azure.Cosmos.Database"/> that was upserted within a task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="database"/> is not set</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Database are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the database object supplied. It is likely that an id was not supplied for the new Database.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an id matching the id field of <paramref name="database"/> already existed</description>
                 </item>
             </list>
             </exception>
             <example>
             The example below upserts a new <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an Id property of 'MyDatabase'
             This code snippet is intended to be used from within an Asynchronous method as it uses the await keyword
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Database db = await client.UpsertDatabaseAsync(new Database { Id = "MyDatabase" });
             }
             ]]>
             </code>
            
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Database"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertDocumentAsync(System.String,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
             <summary>
             Upserts a Document as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="documentsFeedOrDatabaseLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to upsert the document in. E.g. dbs/db_rid/colls/coll_rid/ </param>
             <param name="document">The document object to upsert.</param>
             <param name="options">(Optional) Any request options you wish to set. E.g. Specifying a Trigger to execute when creating the document. <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/></param>
             <param name="disableAutomaticIdGeneration">(Optional) Disables the automatic id generation, If this is True the system will throw an exception if the id property is missing from the Document.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.Document"/> that was upserted contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="documentsFeedOrDatabaseLink"/> or <paramref name="document"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the document supplied. It is likely that <paramref name="disableAutomaticIdGeneration"/> was true and an id was not supplied</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This likely means the collection in to which you were trying to upsert the document is full.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Document"/> with an id matching the id field of <paramref name="document"/> already existed</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the <see cref="T:Microsoft.Azure.Documents.Document"/> exceeds the current max entity size. Consult documentation for limits and quotas.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             Azure Cosmos DB supports a number of different ways to work with documents. A document can extend <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyObject : Resource
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyObject { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             A document can be any POCO object that can be serialized to JSON, even if it doesn't extend from <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyPOCO
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyPOCO { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             A Document can also be a dynamic object
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync("dbs/db_rid/colls/coll_rid/", new { SomeProperty = "A Value" } );
             }
             ]]>
             </code>
             </example>
             <example>
             Upsert a Document and execute a Pre and Post Trigger
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync(
                     "dbs/db_rid/colls/coll_rid/",
                     new { id = "DOC123213443" },
                     new RequestOptions
                     {
                         PreTriggerInclude = new List<string> { "MyPreTrigger" },
                         PostTriggerInclude = new List<string> { "MyPostTrigger" }
                     });
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a collection as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="databaseLink">The link of the database to upsert the collection in. E.g. dbs/db_rid/</param>
             <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was upserted contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="documentCollection"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an id was not supplied for the new collection.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This means you attempted to exceed your quota for collections. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> with an id matching the id you supplied already existed.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 //Upsert a new collection with an OfferThroughput set to 10000
                 //Not passing in RequestOptions.OfferThroughput will result in a collection with the default OfferThroughput set.
                 DocumentCollection coll = await client.UpsertDocumentCollectionAsync(databaseLink,
                     new DocumentCollection { Id = "My Collection" },
                     new RequestOptions { OfferThroughput = 10000} );
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertStoredProcedureAsync(System.String,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a stored procedure as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the collection to upsert the stored procedure in. E.g. dbs/db_rid/colls/col_rid/</param>
             <param name="storedProcedure">The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> object to upsert.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> that was upserted contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="storedProcedure"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the stored procedure or the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of stored procedures for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> you tried to upsert was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a new stored procedure called "HelloWorldSproc" that takes in a single param called "name".
             StoredProcedure sproc = await client.UpsertStoredProcedureAsync(collectionLink, new StoredProcedure
             {
                Id = "HelloWorldSproc",
                Body = @"function (name){
                            var response = getContext().getResponse();
                            response.setBody('Hello ' + name);
                         }"
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertTriggerAsync(System.String,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a trigger as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to upsert the trigger in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="trigger">The <see cref="T:Microsoft.Azure.Documents.Trigger"/> object to upsert.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="trigger"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new trigger or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of triggers for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Trigger"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.Trigger"/> you tried to upsert was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a trigger that validates the contents of a document as it is created and adds a 'timestamp' property if one was not found.
             Trigger trig = await client.UpsertTriggerAsync(collectionLink, new Trigger
             {
                 Id = "ValidateDocuments",
                 Body = @"function validate() {
                                     var context = getContext();
                                     var request = context.getRequest();                                                             
                                     var documentToCreate = request.getBody();
                                     
                                     // validate properties
                                     if (!('timestamp' in documentToCreate)) {
                                         var ts = new Date();
                                         documentToCreate['timestamp'] = ts.getTime();
                                     }
                                     
                                     // update the document that will be created
                                     request.setBody(documentToCreate);
                                   }",
                 TriggerType = TriggerType.Pre,
                 TriggerOperation = TriggerOperation.Create
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a user defined function as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to upsert the user defined function in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="function">The <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> object to upsert.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="function"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new user defined function or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of user defined functions for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> you tried to upsert was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a user defined function that converts a string to upper case
             UserDefinedFunction udf = client.UpsertUserDefinedFunctionAsync(collectionLink, new UserDefinedFunction
             {
                Id = "ToUpper",
                Body = @"function toUpper(input) {
                                    return input.toUpperCase();
                                 }",
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertUserDefinedTypeAsync(System.String,Microsoft.Azure.Documents.UserDefinedType,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a user defined type object in the Azure Cosmos DB service as an asychronous operation.
             </summary>
             <param name="databaseLink">The link of the database to upsert the user defined type in. E.g. dbs/db_rid/ </param>
             <param name="userDefinedType">The <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> object to upsert.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>A task object representing the service response for the asynchronous operation which contains the upserted <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> object.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="userDefinedType"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of user defined type objects for this database. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> with an id matching the id you supplied already existed.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a new user defined type in the specified database
             UserDefinedType userDefinedType = await client.UpsertUserDefinedTypeAsync(databaseLink, new UserDefinedType { Id = "userDefinedTypeId5" });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.GetDatabaseAccountAsync">
            <summary>
            Read the <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <returns>
            A <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> wrapped in a <see cref="T:System.Threading.Tasks.Task"/> object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.Microsoft#Azure#Cosmos#IDocumentClientInternal#GetDatabaseAccountInternalAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Read the <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> as an asynchronous operation
            given a specific reginal endpoint url.
            </summary>
            <param name="serviceEndpoint">The reginal url of the serice endpoint.</param>
            <param name="cancellationToken">The CancellationToken</param>
            <returns>
            A <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> wrapped in a <see cref="T:System.Threading.Tasks.Task"/> object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.GetStoreProxy(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Certain requests must be routed through gateway even when the client connectivity mode is direct.
            For e.g., DocumentCollection creation. This method returns the <see cref="T:Microsoft.Azure.Documents.IStoreModel"/> based
            on the input <paramref name="request"/>.
            </summary>
            <returns>Returns <see cref="T:Microsoft.Azure.Documents.IStoreModel"/> to which the request must be sent</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.GetLinkForRouting(Microsoft.Azure.Documents.Resource)">
            <summary>
            The preferred link used in replace operation in SDK.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentAsync(System.Uri,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a document as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to create the document in.</param>
            <param name="document">the document object.</param>
            <param name="options">The request options for the request.</param>
            <param name="disableAutomaticIdGeneration">Disables the automatic id generation, will throw an exception if id is missing.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a collection as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI of the database to create the collection in.</param>
            <param name="documentCollection">the Microsoft.Azure.Documents.DocumentCollection object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionIfNotExistsAsync(System.Uri,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates(if doesn't exist) or gets(if already exists) a collection as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI of the database to create the collection in.</param>
            <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
            <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
            <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a stored procedure as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to create the stored procedure in.</param>
            <param name="storedProcedure">the Microsoft.Azure.Documents.StoredProcedure object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerAsync(System.Uri,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a trigger as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to create the trigger in.</param>
            <param name="trigger">the Microsoft.Azure.Documents.Trigger object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a user defined function as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to create the user defined function in.</param>
            <param name="function">the Microsoft.Azure.Documents.UserDefinedFunction object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedType,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a user defined type as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI of the database to create the user defined type in.</param>
            <param name="userDefinedType">the Microsoft.Azure.Documents.UserDefinedType object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertDocumentAsync(System.Uri,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Upserts a document as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to upsert the document in.</param>
            <param name="document">the document object.</param>
            <param name="options">The request options for the request.</param>
            <param name="disableAutomaticIdGeneration">Disables the automatic id generation, will throw an exception if id is missing.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a stored procedure as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to upsert the stored procedure in.</param>
            <param name="storedProcedure">the Microsoft.Azure.Documents.StoredProcedure object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertTriggerAsync(System.Uri,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a trigger as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to upsert the trigger in.</param>
            <param name="trigger">the Microsoft.Azure.Documents.Trigger object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a user defined function as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to upsert the user defined function in.</param>
            <param name="function">the Microsoft.Azure.Documents.UserDefinedFunction object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.UpsertUserDefinedTypeAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedType,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a user defined type as an asynchronous operation  in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI of the database to upsert the user defined type in.</param>
            <param name="userDefinedType">the Microsoft.Azure.Documents.UserDefinedType object.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteDatabaseAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a database as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI of the database to delete.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteDocumentAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a document as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentUri">the URI of the document to delete.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to delete.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a stored procedure as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="storedProcedureUri">the URI of the stored procedure to delete.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteTriggerAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a trigger as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="triggerUri">the URI of the trigger to delete.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a user defined function as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="functionUri">the URI of the user defined function to delete.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.DeleteConflictAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a conflict as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="conflictUri">the URI of the conflict to delete.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceDocumentAsync(System.Uri,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replaces a document as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentUri">the URI of the document to be updated.</param>
            <param name="document">the updated document.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a document collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">the URI of the document collection to be updated.</param>
            <param name="documentCollection">the updated document collection.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replace the specified stored procedure in the Azure Cosmos DB service.
            </summary>
            <param name="storedProcedureUri">the URI for the stored procedure to be updated.</param>
            <param name="storedProcedure">the updated stored procedure.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceTriggerAsync(System.Uri,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a trigger as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="triggerUri">the URI for the trigger to be updated.</param>
            <param name="trigger">the updated trigger.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a user defined function as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedFunctionUri">the URI for the user defined function to be updated.</param>
            <param name="function">the updated user defined function.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReplaceUserDefinedTypeAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedType,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a user defined type as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedTypeUri">the URI for the user defined type to be updated.</param>
            <param name="userDefinedType">the updated user defined type.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDatabaseAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.Database"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">A URI to the Database resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Database"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="databaseUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Database resource where 
            // - db_id is the ID property of the Database you wish to read. 
            var dbLink = UriFactory.CreateDatabaseUri("db_id");
            Database database = await client.ReadDatabaseAsync(dbLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentUri">A URI to the Document resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - doc_id is the ID property of the Document you wish to read. 
            var docUri = UriFactory.CreateDocumentUri("db_id", "coll_id", "doc_id");
            Document document = await client.ReadDocumentAsync(docUri);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentAsync``1(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> as a generic type T from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentUri">A URI to the Document resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - doc_id is the ID property of the Document you wish to read. 
            var docUri = UriFactory.CreateDocumentUri("db_id", "coll_id", "doc_id");
            Customer customer = await client.ReadDocumentAsync<Customer>(docUri);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">A URI to the DocumentCollection resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentCollectionUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection you wish to read. 
            var collLink = UriFactory.CreateCollectionUri("db_id", "coll_id");
            DocumentCollection coll = await client.ReadDocumentCollectionAsync(collLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="storedProcedureUri">A URI to the StoredProcedure resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a StoredProcedure resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection 
            // - sproc_id is the ID property of the StoredProcedure you wish to read. 
            var sprocLink = UriFactory.CreateStoredProcedureUri("db_id", "coll_id", "sproc_id");
            StoredProcedure sproc = await client.ReadStoredProcedureAsync(sprocLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadTriggerAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Trigger"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="triggerUri">A URI to the Trigger resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="triggerUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Trigger resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection 
            // - trigger_id is the ID property of the Trigger you wish to read. 
            var triggerLink = UriFactory.CreateTriggerUri("db_id", "coll_id", "trigger_id");
            Trigger trigger = await client.ReadTriggerAsync(triggerLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="functionUri">A URI to the User Defined Function resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="functionUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a UserDefinedFunction resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection 
            // - udf_id is the ID property of the UserDefinedFunction you wish to read. 
            var udfLink = UriFactory.CreateUserDefinedFunctionUri("db_id", "coll_id", "udf_id");
            UserDefinedFunction udf = await client.ReadUserDefinedFunctionAsync(udfLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadConflictAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Conflict"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="conflictUri">A URI to the Conflict resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Conflict"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="conflictUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Conflict resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - conflict_id is the ID property of the Conflict you wish to read. 
            var conflictLink = UriFactory.CreateConflictUri("db_id", "coll_id", "conflict_id");
            Conflict conflict = await client.ReadConflictAsync(conflictLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSchemaAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Schema"/> as an asynchronous operation.
            </summary>
            <param name="schemaUri">A URI to the Schema resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Schema"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="schemaUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Schema are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - schema_id is the ID property of the Document you wish to read. 
            var docLink = UriFactory.CreateDocumentUri("db_id", "coll_id", "schema_id");
            Schema schema = await client.ReadSchemaAsync(schemaLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Schema"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedTypeAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedTypeUri">A URI to the UserDefinedType resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="userDefinedTypeUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a UserDefinedType resource where 
            // - db_id is the ID property of the Database
            // - userDefinedType_id is the ID property of the UserDefinedType you wish to read. 
            var userDefinedTypeLink = UriFactory.CreateUserDefinedTypeUri("db_id", "userDefinedType_id");
            UserDefinedType userDefinedType = await client.ReadUserDefinedTypeAsync(userDefinedTypeLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/> 
            <seealso cref="T:Microsoft.Azure.Cosmos.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSnapshotAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="snapshotUri">A URI to the Snapshot resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Snapshot"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="snapshotUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Snapshot are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Snapshot resource where 
            // - snapshot_id is the ID property of the Snapshot you wish to read. 
            var snapshotLink = UriFactory.CreateSnapshotUri("snapshot_id");
            Snapshot snapshot = await client.ReadSnapshotAsync(snapshotLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Snapshot"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentCollectionFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of collections for a database as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionsUri">the URI for the document collections.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadStoredProcedureFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of stored procedures for a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="storedProceduresUri">the URI for the stored procedures.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadTriggerFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of triggers for a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="triggersUri">the URI for the triggers.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedFunctionFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of user defined functions for a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedFunctionsUri">the URI for the user defined functions.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadDocumentFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions,System.Threading.CancellationToken)">
            <summary>
            Reads the feed (sequence) of documents for a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentsUri">the URI for the documents.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadConflictFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of conflicts for a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="conflictsUri">the URI for the conflicts.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadPartitionKeyRangeFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="partitionKeyRangesOrCollectionUri">The Uri for partition key ranges, or owner collection.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> containing the read resource record.
            </returns>
            <example>
            <code language="c#">
            <![CDATA[
            Uri partitionKeyRangesUri = UriFactory.CreatePartitionKeyRangesUri(database.Id, collection.Id);
            DoucmentFeedResponse<PartitionKeyRange> response = null;
            List<string> ids = new List<string>();
            do
            {
                response = await client.ReadPartitionKeyRangeFeedAsync(partitionKeyRangesUri, new FeedOptions { MaxItemCount = 1000 });
                foreach (var item in response)
                {
                    ids.Add(item.Id);
                }
            }
            while (!string.IsNullOrEmpty(response.ResponseContinuation));
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.FeedOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentFeedResponse`1"/>
            <seealso cref="M:Microsoft.Azure.Cosmos.UriFactory.CreatePartitionKeyRangesUri(System.String,System.String)"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadUserDefinedTypeFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of user defined types for a database as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedTypesUri">the URI for the user defined types.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ExecuteStoredProcedureAsync``1(System.Uri,System.Object[])">
            <summary>
            Executes a stored procedure against a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">the type of the stored procedure's return value.</typeparam>
            <param name="storedProcedureUri">the URI of the stored procedure to be executed.</param>
            <param name="procedureParams">the parameters for the stored procedure execution.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ExecuteStoredProcedureAsync``1(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Object[])">
            <summary>
            Executes a stored procedure against a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">the type of the stored procedure's return value.</typeparam>
            <param name="storedProcedureUri">the URI of the stored procedure to be executed.</param>
            <param name="options">The request options for the request.</param>
            <param name="procedureParams">the parameters for the stored procedure execution.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ExecuteStoredProcedureAsync``1(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Executes a stored procedure against a collection as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">the type of the stored procedure's return value.</typeparam>
            <param name="storedProcedureUri">the URI of the stored procedure to be executed.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <param name="procedureParams">the parameters for the stored procedure execution.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.ReadSchemaFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of schemas for a collection as an asynchronous operation.
            </summary>
            <param name="schemasUri">the link for the schemas.</param>
            <param name="options">The request options for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for document collections in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI to the database.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for document collections in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI to the database.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for document collections in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI to the database.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionChangeFeedQuery(System.Uri,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for collections under an Azure Cosmos DB database account
            in an Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">Specifies the database to read collections from.</param>
            <param name="feedOptions">Specifies the options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create query for stored procedures in the Azure Cosmos DB service.
            </summary>
            <param name="storedProceduresUri">the URI to the stored procedures.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create query for stored procedures in the Azure Cosmos DB service.
            </summary>
            <param name="storedProceduresUri">the URI to the stored procedures.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create query for stored procedures in the Azure Cosmos DB service.
            </summary>
            <param name="storedProceduresUri">the URI to the stored procedures.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create query for triggers in the Azure Cosmos DB service.
            </summary>
            <param name="triggersUri">the URI to the triggers.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create query for triggers in the Azure Cosmos DB service.
            </summary>
            <param name="triggersUri">the URI to the triggers.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create query for triggers in the Azure Cosmos DB service.
            </summary>
            <param name="triggersUri">the URI to the triggers.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for user-defined functions in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedFunctionsUri">the URI to the user-defined functions.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for user-defined functions in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedFunctionsUri">the URI to the user-defined functions.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for user-defined functions in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedFunctionsUri">the URI to the user-defined functions.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateConflictQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for conflicts in the Azure Cosmos DB service.
            </summary>
            <param name="conflictsUri">the URI to the conflicts.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateConflictQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for conflicts in the Azure Cosmos DB service.
            </summary>
            <param name="conflictsUri">the URI to the conflicts.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateConflictQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for conflicts in the Azure Cosmos DB service.
            </summary>
            <param name="conflictsUri">the URI to the conflicts.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">the type of object to query.</typeparam>
            <param name="documentCollectionUri">The URI of the document collection.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.Uri,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">the type of object to query.</typeparam>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection, e.g. dbs/db_rid/colls/coll_rid/. 
            Alternatively, this can be a URI of the database when using an <see cref="T:Microsoft.Azure.Documents.Client.IPartitionResolver"/>, e.g. dbs/db_rid/</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>The query result set.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">the type of object to query.</typeparam>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection, e.g. dbs/db_rid/colls/coll_rid/. 
            Alternatively, this can be a URI of the database when using an <see cref="T:Microsoft.Azure.Documents.Client.IPartitionResolver"/>, e.g. dbs/db_rid/</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>The query result set.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Extension method to create a query for documents for the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection, e.g. dbs/db_rid/colls/coll_rid/. 
            Alternatively, this can be a URI of the database when using an <see cref="T:Microsoft.Azure.Documents.Client.IPartitionResolver"/>, e.g. dbs/db_rid/</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>The query result set.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection, e.g. dbs/db_rid/colls/coll_rid/. 
            Alternatively, this can be a URI of the database when using an <see cref="T:Microsoft.Azure.Documents.Client.IPartitionResolver"/>, e.g. dbs/db_rid/</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>The query result set.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection, e.g. dbs/db_rid/colls/coll_rid/. 
            Alternatively, this can be a URI of the database when using an <see cref="T:Microsoft.Azure.Documents.Client.IPartitionResolver"/>, e.g. dbs/db_rid/</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>The query result set.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Extension method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionOrDatabaseUri">The URI of the document collection, e.g. dbs/db_rid/colls/coll_rid/. 
            Alternatively, this can be a URI of the database when using an <see cref="T:Microsoft.Azure.Documents.Client.IPartitionResolver"/>, e.g. dbs/db_rid/</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>The query result set.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentChangeFeedQuery(System.Uri,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Extension method to create a change feed query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="collectionLink">Specifies the collection to read documents from.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for user defined types in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedTypesUri">the URI to the user defined types.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for user defined types in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedTypesUri">the URI to the user defined types.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Extension method to create a query for user defined types in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedTypesUri">the URI to the user defined types.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeChangeFeedQuery(System.Uri,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for user defined types under an Azure Cosmos DB database account
            in an Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">Specifies the database to read user defined types from.</param>
            <param name="feedOptions">Specifies the options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDatabaseQuery(Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for database resources under an account in the Azure Cosmos DB service. It returns An IOrderedQueryable{Database}.
            </summary>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Database} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for databases by id.
            <code language="c#">
            <![CDATA[
            Database database = client.CreateDatabaseQuery().Where(d => d.Id == "mydb").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDatabaseQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for database resources under an Azure Cosmos DB database account by using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for databases by id.
            <code language="c#">
            <![CDATA[
            Database database = client.CreateDatabaseQuery("SELECT * FROM dbs d WHERE d.id = 'mydb'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDatabaseQuery(Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for database resources under an Azure Cosmos DB database account by using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for databases by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM dbs d WHERE d.id = @id",
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "mydb" }}));
            dynamic database = client.CreateDatabaseQuery<dynamic>(query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDatabaseChangeFeedQuery(Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for databases under an Azure Cosmos DB database account
            in an Azure Cosmos DB service.
            </summary>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for collections under an Azure Cosmos DB database. It returns An IOrderedQueryable{DocumentCollection}.
            </summary>
            <param name="databaseLink">The link to the parent database resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{DocumentCollection} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for collections by id.
            <code language="c#">
            <![CDATA[
            DocumentCollection collection = client.CreateDocumentCollectionQuery(databaseLink).Where(c => c.Id == "myColl").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for collections under an Azure Cosmos DB database using a SQL statement.   It returns an IQueryable{DocumentCollection}.
            </summary>
            <param name="databaseLink">The link to the parent database resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for collections by id.
            <code language="c#">
            <![CDATA[
            DocumentCollection collection = client.CreateDocumentCollectionQuery(databaseLink, "SELECT * FROM colls c WHERE c.id = 'mycoll'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for collections under an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="databaseLink">The link to the parent database resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for collections by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM colls c WHERE c.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "mycoll" }}));
            DocumentCollection collection = client.CreateDocumentCollectionQuery(databaseLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentCollectionChangeFeedQuery(System.String,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for collections under an Azure Cosmos DB database account
            in an Azure Cosmos DB service.
            </summary>
            <param name="databaseLink">Specifies the database to read collections from.</param>
            <param name="feedOptions">Specifies the options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for stored procedures under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{StoredProcedure}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{StoredProcedure} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for stored procedures by id.
            <code language="c#">
            <![CDATA[
            StoredProcedure storedProcedure = client.CreateStoredProcedureQuery(collectionLink).Where(c => c.Id == "helloWorld").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for stored procedures under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for stored procedures by id.
            <code language="c#">
            <![CDATA[
            StoredProcedure storedProcedure = client.CreateStoredProcedureQuery(collectionLink, "SELECT * FROM sprocs s WHERE s.id = 'HelloWorld'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateStoredProcedureQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for stored procedures under a collection in an Azure Cosmos DB database using a SQL statement using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for stored procedures by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM sprocs s WHERE s.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "HelloWorld" }}));
            StoredProcedure storedProcedure = client.CreateStoredProcedureQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for triggers under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{Trigger}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Trigger} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for triggers by id.
            <code language="c#">
            <![CDATA[
            Trigger trigger = client.CreateTriggerQuery(collectionLink).Where(t => t.Id == "validate").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for triggers under a collection in an Azure Cosmos DB service. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for triggers by id.
            <code language="c#">
            <![CDATA[
            Trigger trigger = client.CreateTriggerQuery(collectionLink, "SELECT * FROM triggers t WHERE t.id = 'validate'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateTriggerQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for triggers under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{Trigger} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for triggers by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM triggers t WHERE t.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "HelloWorld" }}));
            Trigger trigger = client.CreateTriggerQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for udfs under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{UserDefinedFunction}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{UserDefinedFunction} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for user-defined functions by id.
            <code language="c#">
            <![CDATA[
            UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(collectionLink).Where(u => u.Id == "sqrt").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for udfs under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for user-defined functions by id.
            <code language="c#">
            <![CDATA[
            UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(collectionLink, "SELECT * FROM udfs u WHERE u.id = 'sqrt'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedFunctionQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for udfs under a collection in an Azure Cosmos DB database with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for user-defined functions by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM udfs u WHERE u.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "sqrt" }}));
            UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateConflictQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for conflicts under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{Conflict}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Conflict} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for conflicts by id.
            <code language="c#">
            <![CDATA[
            Conflict conflict = client.CreateConflictQuery(collectionLink).Where(c => c.Id == "summary").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateConflictQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for conflicts under a collection in an Azure Cosmos DB service. It returns an IQueryable{Conflict}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the the provided SQL statement.</returns>
            <example>
            This example below queries for conflicts by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM conflicts c WHERE c.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "summary" }}));
            Conflict conflict = client.CreateConflictQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateConflictQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for conflicts under a collection in an Azure Cosmos DB database with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for conflicts by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM conflicts c WHERE c.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "summary" }}));
            dynamic conflict = client.CreateConflictQuery<dynamic>(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{T} that can evaluate the query.</returns>
            <example>
            This example below queries for some book documents.
            <code language="c#">
            <![CDATA[
            public class Book 
            {
                [JsonProperty("title")]
                public string Title {get; set;}
                
                public Author Author {get; set;}
                
                public int Price {get; set;}
            }
            
            public class Author
            {
                public string FirstName {get; set;}
                public string LastName {get; set;}
            }
             
            // Query by the Title property
            Book book = client.CreateDocumentQuery<Book>(collectionLink).Where(b => b.Title == "War and Peace").AsEnumerable().FirstOrDefault();
            
            // Query a nested property
            Book otherBook = client.CreateDocumentQuery<Book>(collectionLink).Where(b => b.Author.FirstName == "Leo").AsEnumerable().FirstOrDefault();
            
            // Perform a range query (needs an IndexType.Range on price or FeedOptions.EnableScansInQuery)
            foreach (Book matchingBook in client.CreateDocumentQuery<Book>(collectionLink).Where(b => b.Price > 100))
            {
                // Iterate through books
            }
            
            // Query asychronously. Optionally set FeedOptions.MaxItemCount to control page size
            using (var queryable = client.CreateDocumentQuery<Book>(
                collectionLink,
                new FeedOptions { MaxItemCount = 10 })
                .Where(b => b.Title == "War and Peace")
                .AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            The Azure Cosmos DB LINQ provider compiles LINQ to SQL statements. Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started#linq-to-documentdb-sql for the list of expressions supported by the Azure Cosmos DB LINQ provider. ToString() on the generated IQueryable returns the translated SQL statement. The Azure Cosmos DB provider translates JSON.NET and DataContract serialization attributes for members to their JSON property names.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentsFeedOrDatabaseLink">The path link for the documents under a collection, e.g. dbs/db_rid/colls/coll_rid/docs/. 
            Alternatively, this can be a path link to the database when using an IPartitionResolver, e.g. dbs/db_rid/</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>An IOrderedQueryable{T} that can evaluate the query.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{T}.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent collection.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{T} that can evaluate the query.</returns>
            <example>
            This example below queries for some book documents.
            <code language="c#">
            <![CDATA[
            public class Book 
            {
                [JsonProperty("title")]
                public string Title {get; set;}
                
                public Author Author {get; set;}
                
                public int Price {get; set;}
            }
            
            public class Author
            {
                public string FirstName {get; set;}
                public string LastName {get; set;}
            }
            
            // Query by the Title property
            Book book = client.CreateDocumentQuery<Book>(collectionLink, 
                "SELECT * FROM books b WHERE b.title  = 'War and Peace'").AsEnumerable().FirstOrDefault();
            
            // Query a nested property
            Book otherBook = client.CreateDocumentQuery<Book>(collectionLink,
                "SELECT * FROM books b WHERE b.Author.FirstName = 'Leo'").AsEnumerable().FirstOrDefault();
            
            // Perform a range query (needs an IndexType.Range on price or FeedOptions.EnableScansInQuery)
            foreach (Book matchingBook in client.CreateDocumentQuery<Book>(
                collectionLink, "SELECT * FROM books b where b.Price > 1000"))
            {
                // Iterate through books
            }
            
            // Query asychronously. Optionally set FeedOptions.MaxItemCount to control page size
            using (var queryable = client.CreateDocumentQuery<Book>(collectionLink, 
                "SELECT * FROM books b WHERE b.title  = 'War and Peace'", 
                new FeedOptions { MaxItemCount = 10 }).AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{T}.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The path link for the documents under a collection, e.g. dbs/db_rid/colls/coll_rid/docs/. 
            Alternatively, this can be a path link to the database when using an IPartitionResolver, e.g. dbs/db_rid/</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>An IQueryable{T} that can evaluate the query.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{T}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent document collection.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{T} that can evaluate the query.</returns>
            <example>
            This example below queries for some book documents.
            <code language="c#">
            <![CDATA[
            public class Book 
            {
                [JsonProperty("title")]
                public string Title {get; set;}
                
                public Author Author {get; set;}
                
                public int Price {get; set;}
            }
            
            public class Author
            {
                public string FirstName {get; set;}
                public string LastName {get; set;}
            }
            
            // Query using Title
            Book book, otherBook;
            
            var query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.title = @title", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@title", Value = "War and Peace" }}));
            book = client.CreateDocumentQuery<Book>(collectionLink, query).AsEnumerable().FirstOrDefault();
            
            // Query a nested property
            query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.Author.FirstName = @firstName", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@firstName", Value = "Leo" }}));
            otherBook = client.CreateDocumentQuery<Book>(collectionLink, query).AsEnumerable().FirstOrDefault();
            
            // Perform a range query (needs an IndexType.Range on price or FeedOptions.EnableScansInQuery)
            query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.Price > @minPrice", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@minPrice", Value = 1000 }}));
            foreach (Book b in client.CreateDocumentQuery<Book>(
                collectionLink, query))
            {
                // Iterate through books
            }
            
            // Query asychronously. Optionally set FeedOptions.MaxItemCount to control page size
            query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.title = @title", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@title", Value = "War and Peace" }}));
                
            using (var queryable = client.CreateDocumentQuery<Book>(collectionLink, query, 
                new FeedOptions { MaxItemCount = 10 }).AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery``1(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{T}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent document collection.
            Alternatively, this can be a path link to the database when using an IPartitionResolver.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>An IQueryable{T} that can evaluate the query.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB service. It returns IOrderedQueryable{Document}.
             </summary>
             <param name="collectionLink">The link to the parent document collection.</param>
             <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
             <returns>An IOrderedQueryable{Document} that can evaluate the query.</returns>
             <example>
             This example below queries for documents by id.
             <code language="c#">
             <![CDATA[
             Document document = client.CreateDocumentQuery<Document>(collectionLink)
                 .Where(d => d.Id == "War and Peace").AsEnumerable().FirstOrDefault();
            
             ]]>
             </code>
             </example>
             <remarks>
             This overload should be used when the schema of the queried documents is unknown or when querying by ID and replacing/deleting documents.
             Since Document is a DynamicObject, it can be dynamically cast back to the original C# object.
             </remarks>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB service. It returns IOrderedQueryable{Document}.
            </summary>
            <param name="collectionLink">The link to the parent document collection.
            Alternatively, this can be a path link to the database when using an IPartitionResolver.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <param name="partitionKey">Optional partition key that can be used with an IPartitionResolver.</param>
            <returns>An IOrderedQueryable{Document} that can evaluate the query.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent document collection.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic> that can evaluate the query.</returns>
            <example>
            This example below queries for book documents.
            <code language="c#">
            <![CDATA[
            // SQL querying allows dynamic property access
            dynamic document = client.CreateDocumentQuery<dynamic>(collectionLink,
                "SELECT * FROM books b WHERE b.title == 'War and Peace'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link of the parent document collection.
            Alternatively, this can be a path link to the database when using an IPartitionResolver, e.g. dbs/db_rid/</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>an IQueryable{dynamic> that can evaluate the query.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent document collection.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic> that can evaluate the query.</returns>
            <example>
            This example below queries for book documents.
            <code language="c#">
            <![CDATA[
            // SQL querying allows dynamic property access
            var query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.title = @title", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@title", Value = "War and Peace" }}));
                
            dynamic document = client.CreateDocumentQuery<dynamic>(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent document collection.
            Alternatively, this can be a path link to the database when using an IPartitionResolver, e.g. dbs/db_rid/</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <param name="partitionKey">The partition key that can be used with an IPartitionResolver.</param>
            <returns>an IQueryable{dynamic> that can evaluate the query.</returns>
            <remarks>
            Support for IPartitionResolver based method overloads is now obsolete. It's recommended that you use 
            <a href="https://azure.microsoft.com/documentation/articles/documentdb-partition-data">Partitioned Collections</a> for higher storage and throughput.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentChangeFeedQuery(System.String,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for documents under a collection in an Azure Cosmos DB service.
            </summary>
            <param name="collectionLink">Specifies the collection to read documents from.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>the query result set.</returns>
            <remarks>ChangeFeedOptions.PartitionKeyRangeId must be provided.</remarks>
            <example>
            <code language="c#">
            <![CDATA[
            string partitionKeyRangeId = "0";   // Use client.ReadPartitionKeyRangeFeedAsync() to obtain the ranges.
            string checkpointContinuation = null;
            ChangeFeedOptions options = new ChangeFeedOptions
            {
                PartitionKeyRangeId = partitionKeyRangeId,
                RequestContinuation = checkpointContinuation,
                StartFromBeginning = true,
            };
            using(var query = client.CreateDocumentChangeFeedQuery(collection.SelfLink, options))
            {
                while (true)
                {
                    do
                    {
                        var response = await query.ExecuteNextAsync<Document>();
                        if (response.Count > 0)
                        {
                            var docs = new List<Document>();
                            docs.AddRange(response);
                            // Process the documents.
                            // Checkpoint response.ResponseContinuation.
                        }
                    }
                    while (query.HasMoreResults);
                    Task.Delay(TimeSpan.FromMilliseconds(500)); // Or break here and use checkpointed continuation token later.
                }       
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.ChangeFeedOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateOfferQuery(Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for offers under an Azure Cosmos DB database account. It returns IOrderedQueryable{Offer}.
            </summary>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Offer} that can evaluate the query.</returns>
            <example>
            This example below queries for offers
            <code language="c#">
            <![CDATA[
            // Find the offer for the collection by SelfLink
            Offer offer = client.CreateOfferQuery().Where(o => o.Resource == collectionSelfLink).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateOfferQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for offers under an Azure Cosmos DB database account using a SQL statement. It returns IQueryable{dynamic}.
            </summary>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic} that can evaluate the query.</returns>
            <example>
            This example below queries for offers
            <code language="c#">
            <![CDATA[
            // Find the offer for the collection by SelfLink
            Offer offer = client.CreateOfferQuery(
                string.Format("SELECT * FROM offers o WHERE o.resource = '{0}'", collectionSelfLink)).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateOfferQuery(Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for offers under an Azure Cosmos DB database account using a SQL statement with parameterized values. It returns IQueryable{dynamic}.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic} that can evaluate the query.</returns>
            <example>
            This example below queries for offers
            <code language="c#">
            <![CDATA[
            // Find the offer for the collection by SelfLink
            Offer offer = client.CreateOfferQuery("SELECT * FROM offers o WHERE o.resource = @collectionSelfLink",
            new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@collectionSelfLink", Value = collection.SelfLink }}))
            .AsEnumerable().FirstOrDefault();
            
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for user defined types under an Azure Cosmos DB service. It returns IOrderedQueryable{UserDefinedType}.
            </summary>
            <param name="userDefinedTypesLink">The path link for the user defined types under a database, e.g. dbs/db_rid/udts/.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{UserDefinedType} that can evaluate the query.</returns>
            <example>
            This example below queries for user defined types by id.
            <code language="c#">
            <![CDATA[
            UserDefinedType userDefinedTypes = client.CreateUserDefinedTypeQuery(userDefinedTypesLink).Where(u => u.Id == "userDefinedTypeId5").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for user defined types under an Azure Cosmos DB service. It returns IQueryable{dynamic}.
            </summary>
            <param name="userDefinedTypesLink">The path link for the user defined types under a database, e.g. dbs/db_rid/udts/.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic} that can evaluate the query.</returns>
            <example>
            This example below queries for user defined types by id.
            <code language="c#">
            <![CDATA[
            UserDefinedType userDefinedTypes = client.CreateUserDefinedTypeQuery(userDefinedTypesLink, "SELECT * FROM userDefinedTypes u WHERE u.id = 'userDefinedTypeId5'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for user defined types under an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="userDefinedTypesLink">The path link for the user defined types under a database, e.g. dbs/db_rid/udts/.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic} that can evaluate the query.</returns>
            <example>
            This example below queries for user defined types by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec(
                "SELECT * FROM userDefinedTypes u WHERE u.id = @id", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "userDefinedTypeId5" }}));
                
            UserDefinedType userDefinedType = client.CreateUserDefinedTypeQuery(userDefinedTypesLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedType"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentClient.CreateUserDefinedTypeChangeFeedQuery(System.String,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for user defined types under an Azure Cosmos DB database account
            in an Azure Cosmos DB service.
            </summary>
            <param name="databaseLink">Specifies the database to read user defined types from.</param>
            <param name="feedOptions">Specifies the options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DocumentCollectionRestoreStatus">
            <summary>
            Provides status for a documention collection restore.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentCollectionRestoreStatus.State">
            <summary>
            Gets the <see cref="P:Microsoft.Azure.Cosmos.DocumentCollectionRestoreStatus.State"/> from the Azure Cosmos DB service. 
            </summary>
            <value>
            The state of the restore process.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EnvironmentInformation.DirectVersion">
            <summary>
            Version of the current direct package.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EnvironmentInformation.ClientVersion">
            <summary>
            Version of the current client.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EnvironmentInformation.OperatingSystem">
            <summary>
            Identifier of the Operating System.
            </summary>
            <seealso cref="P:System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EnvironmentInformation.RuntimeFramework">
            <summary>
            Identifier of the Framework.
            </summary>
            <seealso cref="P:System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EnvironmentInformation.ProcessArchitecture">
            <summary>
            Type of architecture being used.
            </summary>
            <seealso cref="P:System.Runtime.InteropServices.RuntimeInformation.ProcessArchitecture"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedOptions">
            <summary>
            Specifies the options associated with feed methods (enumeration operations) in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Used to manage query and ReadFeed execution. Can use FeedOptions to set page size (MaxItemCount)
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedOptions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.MaxItemCount">
            <summary>
            Gets or sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum number of items to be returned in the enumeration operation.
            </value> 
            <remarks>
            Used for query pagination.
            '-1' Used for dynamic page size.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            // Fetch query results 10 at a time.
            using (var queryable = client.CreateDocumentQuery<Book>(collectionLink, new FeedOptions { MaxItemCount = 10 }))
            {
                while (queryable.HasResults)
                {
                    DoucmentFeedResponse<Book> response = await queryable.ExecuteNext<Book>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.RequestContinuationToken">
            <summary>
            Gets or sets the request continuation token in the Azure Cosmos DB service.
            </summary>
            <value>
            The request continuation token.
            </value>
            <example>
            <code language="c#">
            <![CDATA[
            // Resume query execution using the continuation from the previous query
            var queryable = client.CreateDocumentQuery<Book>(collectionLink, new FeedOptions { RequestContinuation = prevQuery.ResponseContinuation });
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.SessionToken">
            <summary>
            Gets or sets the session token for use with session consistency in the Azure Cosmos DB service.
            </summary>
            <value>
            The session token for use with session consistency.
            </value>
            <remarks>
            Useful for applications that are load balanced across multiple Microsoft.Azure.Documents.Client.DocumentClient instances. 
            In this case, round-trip the token from end user to the application and then back to Azure Cosmos DB so that a session
            can be preserved across servers.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            var queryable = client.CreateDocumentQuery<Book>(
                collectionLink, new FeedOptions { SessionToken = lastSessionToken });
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EnableScanInQuery">
            <summary>
            Gets or sets the option to enable scans on the queries which couldn't be served
            as indexing was opted out on the requested paths in the Azure Cosmos DB service.
            </summary>
            <value>
            Option is true if scan on queries is enabled; otherwise, false.
            </value>
            <example>
            <code language="c#">
            <![CDATA[
            // Enable scan when Range index is not specified.
            var queryable = client.CreateDocumentQuery<Book>(
                collectionLink, new FeedOptions { EnableScanInQuery = true }).Where(b => b.Price > 1000);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EnableCrossPartitionQuery">
            <summary>
            Gets or sets a value indicating whether users are enabled to send more than one request to execute
            the query in the Azure Cosmos DB service. More than one request is necessary if the query 
            is not scoped to single partition key value.
            </summary>
            <value>
            Option is true if cross-partition query execution is enabled; otherwise, false.
            </value>
            <remarks>
            <para>
            This option only applies to queries on documents and document attachments.
            </para>
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            // Enable cross partition query.
            var queryable = client.CreateDocumentQuery<Book>(
                collectionLink, new FeedOptions { EnableCrossPartitionQuery = true }).Where(b => b.Price > 1000);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EnableLowPrecisionOrderBy">
            <summary>
            Gets or sets the option to enable low precision order by in the Azure Cosmos DB service.
            </summary>
            <value>
            The option to enable low-precision order by.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.PartitionKey">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Azure.Documents.PartitionKey"/> for the current request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para>
            Partition key is required when read documents or attachments feed in a partitioned collection. 
            Specifically Partition key is required for :
                <see cref="M:Microsoft.Azure.Cosmos.DocumentClient.ReadConflictFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)"/>.  
            Only documents in partitions containing the <see cref="T:Microsoft.Azure.Documents.PartitionKey"/> is returned in the result.
            </para>
            </remarks>
            <example>
            The following example shows how to read a document feed in a partitioned collection using <see cref="T:Microsoft.Azure.Documents.PartitionKey"/>.
            The example assumes the collection is created with a <see cref="T:Microsoft.Azure.Documents.PartitionKeyDefinition"/> on the 'country' property in all the documents.
            <code language="c#">
            <![CDATA[
            await client.ReadDocumentFeedAsync(
                collection.SelfLink, 
                new RequestOptions { PartitionKey = new PartitionKey("USA") } );
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyDefinition"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.PartitionKeyRangeId">
            <summary>
            Gets or sets the partition key range id for the current request.
            </summary>
            <remarks>
            <para>
            ReadFeed requests can use this to forward request to specific range.
            This is usefull in case of bulk export scenarios.
            </para>
            </remarks>
            <example>
            The following example shows how to read a document feed in a partitioned collection from partition key range "20".
            <code language="c#">
            <![CDATA[
            await client.ReadDocumentFeedAsync(
                collection.SelfLink, 
                new RequestOptions { PartitionKeyRangeId = "20" } );
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.MaxDegreeOfParallelism">
            <summary>
            Gets or sets the number of concurrent operations run client side during 
            parallel query execution in the Azure Cosmos DB service. 
            A positive property value limits the number of 
            concurrent operations to the set value. If it is set to less than 0, the 
            system automatically decides the number of concurrent operations to run.
            </summary>
            <value>
            The maximum number of concurrent operations during parallel execution. Defaults to 0.
            </value> 
            <example>
            <code language="c#">
            <![CDATA[
            var queryable = client.CreateDocumentQuery<Book>(collectionLink, new FeedOptions { 
            MaxDegreeOfParallelism = 5});
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.MaxBufferedItemCount">
            <summary>
            Gets or sets the maximum number of items that can be buffered client side during 
            parallel query execution in the Azure Cosmos DB service. 
            A positive property value limits the number of buffered 
            items to the set value. If it is set to less than 0, the system automatically 
            decides the number of items to buffer.
            </summary>
            <value>
            The maximum count of items that can be buffered during parallel query execution.
            </value> 
            <remarks>
            This is only suggestive and cannot be abided by in certain cases.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            var queryable = client.CreateDocumentQuery<Book>(collectionLink, new FeedOptions { 
            MaximumBufferSize = 10, MaxDegreeOfParallelism = 2 });
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EmitVerboseTracesInQuery">
            <summary>
            Gets or sets the option to allow queries to emit out verbose traces 
            for investigation in the Azure Cosmos DB service.
            </summary>
            <value>
            Option is true if query tracing is enabled; otherwise, false.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.FilterBySchemaResourceId">
            <summary>
            Gets or sets the schema rid which could be used to filter the document feed response
            in order to focus on the documents for a particular schema.
            </summary>
            <value>
            By default, it is <c>null</c> which means no filtering will be applied.
            Otherwise, it must be a valid resource id of Schema resource.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.PopulateQueryMetrics">
            <summary>
             Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.FeedOptions.PopulateQueryMetrics"/> request option for document query requests in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para> 
            PopulateQueryMetrics is used to enable/disable getting metrics relating to query execution on document query requests.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.ResponseContinuationTokenLimitInKb">
            <summary>
             Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.FeedOptions.ResponseContinuationTokenLimitInKb"/> request option for document query requests in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para> 
            ResponseContinuationTokenLimitInKb is used to limit the length of continuation token in the query response. Valid values are >= 0.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.DisableRUPerMinuteUsage">
            <summary>
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.FeedOptions.DisableRUPerMinuteUsage"/> option for the current query in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para> 
            DisableRUPerMinuteUsage is used to enable/disable Request Units(RUs)/minute capacity to serve the query if regular provisioned RUs/second is exhausted.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.JsonSerializerSettings">
            <summary>
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.FeedOptions.JsonSerializerSettings"/> for the current request used to deserialize the document.
            If null, uses the default serializer settings set up in the DocumentClient.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.ConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the feed (query/read feed) operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            Azure Cosmos DB offers 5 different consistency levels. Strong, Bounded Staleness, Session, Consistent Prefix and Eventual - in order of strongest to weakest consistency. <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
            
            Azure Cosmos query/DB feed operations may be retrieved from many partitions, each accessed across many round trips. The consistency level is honored only within a partition and round trip. 
            <para>
            While this is set at a database account level, Azure Cosmos DB allows a developer to override the default consistency level
            for each individual request. 
            </para>
            </remarks>
            <example>
            This example uses FeedOptions to override the consistency level to Eventual. 
            <code language="c#">
            <![CDATA[
            Document doc = client.ReadDocumentFeedAsync(documentLink, new FeedOptions { ConsistencyLevel = ConsistencyLevel.Eventual });
            ]]>
            </code>
            </example>
            <seealso cref="P:Microsoft.Azure.Cosmos.FeedOptions.ConsistencyLevel"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.ForceQueryScan">
            <summary>
            Gets or sets the flag that tells the backend to forces the query to perform a scan (at a request level).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EnumerationDirection">
            <summary>
            Gets or sets the EnumerationDirection
            To be used along with Read feed operation
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.ReadFeedKeyType">
            <summary>
            Gets or sets the ReadFeedKeyType
            To be used along with Read feed operation
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.StartId">
            <summary>
            Gets or sets the StartId
            To be used along with Read feed operation
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EndId">
            <summary>
            Gets or sets the EndId
            To be used along with Read feed operation
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.StartEpk">
            <summary>
            Gets or sets the StartEpk
            To be used along with Read feed operation
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.EndEpk">
            <summary>
            Gets or sets the EndEpk
            To be used along with Read feed operation
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.ContentSerializationFormat">
            <summary>
            Gets or sets the ContentSerializationFormat for the feed (query/read feed) operation in the Azure Cosmos DB service.
            </summary>
            <remarks>
            If the document is stored in a different serialization format then the one requested, then there will be a rewrite over the wire, but the source document will be untouched.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.MergeStaticId">
            <summary>
            Gets or sets the MergeStaticId.
            To be used along with Read feed operation when Static Column merge is desired.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedOptions.CosmosSerializationFormatOptions">
            <summary>
            Gets or sets the custom serialization options for query
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangeCompositeContinuation">
            <summary>
            FeedRangeContinuation using Composite Continuation Tokens and split proof.
            It uses a breath-first approach to transverse Composite Continuation Tokens.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedRangeCompositeContinuation.#ctor(System.String,Microsoft.Azure.Cosmos.FeedRangeInternal,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Routing.CompositeContinuationToken})">
            <summary>
            Used for deserialization only
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedRangeCompositeContinuation.IsDone">
            <summary>
            The concept of Done is only for ReadFeed. Change Feed is never done, it is an infinite stream.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangeContinuationVersion">
            <summary>
            Used to future-proof token versions
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRange">
            <summary>
            Represents a unit of feed consumption that can be used as unit of parallelism.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedRange.ToJsonString">
            <summary>
            Gets a string representation of the current range.
            </summary>
            <returns>A string representation of the current token.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedRange.FromJsonString(System.String)">
            <summary>
            Creates a range from a previously obtained string representation.
            </summary>
            <param name="toStringValue">A string representation obtained from <see cref="M:Microsoft.Azure.Cosmos.FeedRange.ToJsonString" />.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.FeedRange" />.</returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="toStringValue"/> does not represent a valid value.</exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedRange.FromPartitionKey(Microsoft.Azure.Cosmos.PartitionKey)">
            <summary>
            Creates a feed range that span only a single <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> value.
            </summary>
            <param name="partitionKey">The partition key value to create a feed range from.</param>
            <returns>The feed range that spans the partition.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangeContinuation">
            <summary>
            Represents the continuation for an operation using FeedRange.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedRangeContinuation.#ctor">
            <summary>
            For mocking
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangeResponse">
            <summary>
            ResponseMessage to promote the FeedRangeContinuation as Continuation.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangeEpk">
            <summary>
            FeedRange that represents an effective partition key range.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangePartitionKey">
            <summary>
            FeedRange that represents an exact Partition Key value.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedRangePartitionKeyRange">
            <summary>
            FeedRange that represents a Partition Key Range.
            Backward compatibility implementation to transition from V2 SDK queries that were filtering by PKRangeId.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedResponseBinder.ConvertCosmosElementFeed``1(Microsoft.Azure.Cosmos.DocumentFeedResponse{Microsoft.Azure.Cosmos.CosmosElements.CosmosElement},Microsoft.Azure.Documents.ResourceType,Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            DEVNOTE: Need to refactor to use CosmosJsonSerializer
            Todo: This method can be optimized by not writing the result out to text.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder">
            <summary>
            This is a Builder class that creates a cosmos client
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.#ctor(System.String,System.String)">
            <summary>
            Initialize a new CosmosConfiguration class that holds all the properties the CosmosClient requires.
            </summary>
            <param name="accountEndpoint">The Uri to the Cosmos Account. Example: https://{Cosmos Account Name}.documents.azure.com:443/ </param>
            <param name="authKeyOrResourceToken">The key to the account or resource token.</param>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>
            <code language="c#">
            <![CDATA[
            CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder(
                accountEndpoint: "https://testcosmos.documents.azure.com:443/",
                authKeyOrResourceToken: "SuperSecretKey");
            CosmosClient client = cosmosClientBuilder.Build();
            ]]>
            </code>
            </example>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> with a ConsistencyLevel and a list of preferred locations.
            <code language="c#">
            <![CDATA[
            CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder(
                accountEndpoint: "https://testcosmos.documents.azure.com:443/",
                authKeyOrResourceToken: "SuperSecretKey")
            .WithConsistencyLevel(ConsistencyLevel.Strong)
            .WithApplicationRegion("East US 2");
            CosmosClient client = cosmosClientBuilder.Build();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.#ctor(System.String)">
            <summary>
            Extracts the account endpoint and key from the connection string.
            </summary>
            <example>"AccountEndpoint=https://mytestcosmosaccount.documents.azure.com:443/;AccountKey={SecretAccountKey};"</example>
            <param name="connectionString">The connection string must contain AccountEndpoint and AccountKey or ResourceToken.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.#ctor(System.String,Azure.Core.TokenCredential)">
            <summary>
            Initializes a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> with a <see cref="T:Azure.Core.TokenCredential"/> instance.
            </summary>
            <param name="accountEndpoint">The Uri to the Cosmos Account. Example: https://{Cosmos Account Name}.documents.azure.com:443/ </param>
            <param name="tokenCredential">An instance of <see cref="T:Azure.Core.TokenCredential"/></param>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> using a <see cref="T:Azure.Core.TokenCredential"/>.
            <code language="c#">
            <![CDATA[
            CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder(
                accountEndpoint: "https://testcosmos.documents.azure.com:443/",
                tokenCredential: new DefaultAzureCredential());
            CosmosClient client = cosmosClientBuilder.Build();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.Build">
            <summary>
            A method to create the cosmos client
            </summary>
            <remarks>
            Setting this property after sending any request won't have any effect.
            </remarks>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.Build(Microsoft.Azure.Cosmos.DocumentClient)">
            <summary>
            A method to create the cosmos client
            </summary>
            <remarks>
            Setting this property after sending any request won't have any effect.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApplicationName(System.String)">
            <summary>
            A suffix to be added to the default user-agent for the Azure Cosmos DB service.
            </summary>
            <param name="applicationName">A string to use as suffix in the User Agent.</param>
            <remarks>
            Setting this property after sending any request won't have any effect.
            </remarks>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApplicationRegion(System.String)">
            <summary>
            Set the preferred geo-replicated region to be used in the Azure Cosmos DB service. 
            </summary>
            <param name="applicationRegion">Azure region where application is running. <see cref="T:Microsoft.Azure.Cosmos.Regions"/> lists valid Cosmos DB regions.</param>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> with a of preferred region.
            <code language="c#">
            <![CDATA[
            CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder(
                accountEndpoint: "https://testcosmos.documents.azure.com:443/",
                authKeyOrResourceToken: "SuperSecretKey")
            .WithApplicationRegion("East US 2");
            CosmosClient client = cosmosClientBuilder.Build();
            ]]>
            </code>
            </example>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationRegion"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApplicationPreferredRegions(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Set the preferred regions for geo-replicated database accounts in the Azure Cosmos DB service.
            </summary>
            <param name="applicationPreferredRegions">A list of preferred Azure regions used for SDK to define failover order.</param>
            <remarks>
             This function is an alternative to <see cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApplicationRegion(System.String)"/>, either one can be set but not both.
            </remarks>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> with a of preferred regions.
            <code language="c#">
            <![CDATA[
            CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder(
                accountEndpoint: "https://testcosmos.documents.azure.com:443/",
                authKeyOrResourceToken: "SuperSecretKey")
            .WithApplicationPreferredRegions(new[] {Regions.EastUS, Regions.EastUS2});
            CosmosClient client = cosmosClientBuilder.Build();
            ]]>
            </code>
            </example>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ApplicationPreferredRegions"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithLimitToEndpoint(System.Boolean)">
            <summary>
            Limits the operations to the provided endpoint on the CosmosClientBuilder constructor.
            </summary>
            <param name="limitToEndpoint">Whether operations are limited to the endpoint or not.</param>
            <value>Default value is false.</value>
            <remarks>
            When the value of <paramref name="limitToEndpoint"/> is false, the SDK will automatically discover all account write and read regions, and use them when the configured application region is not available.
            When set to true, availability is limited to the endpoint specified on the CosmosClientBuilder constructor.
            Using <see cref="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApplicationRegion(System.String)"/> is not allowed when the value is true. </remarks>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> to limit the endpoint to East US.
            <code language="c#">
            <![CDATA[
            CosmosClientBuilder cosmosClientBuilder = new CosmosClientBuilder(
                accountEndpoint: "https://testcosmos-eastus.documents.azure.com:443/",
                authKeyOrResourceToken: "SuperSecretKey")
            .WithLimitToEndpoint(true);
            CosmosClient client = cosmosClientBuilder.Build();
            ]]>
            </code>
            </example>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/high-availability">High availability</seealso>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.LimitToEndpoint"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithRequestTimeout(System.TimeSpan)">
            <summary>
            Sets the request timeout in seconds when connecting to the Azure Cosmos DB service.
            </summary>
            <param name="requestTimeout">A time to use as timeout for operations.</param>
            <value>Default value is 60 seconds.</value>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.RequestTimeout"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConnectionModeDirect">
            <summary>
            Sets the connection mode to Direct. This is used by the client when connecting to the Azure Cosmos DB service.
            </summary>
            <remarks>
            For more information, see <see href="https://docs.microsoft.com/azure/documentdb/documentdb-performance-tips#direct-connection">Connection policy: Use direct connection mode</see>.
            </remarks>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConnectionModeDirect(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{Microsoft.Azure.Cosmos.PortReuseMode},System.Nullable{System.Boolean})">
            <summary>
            Sets the connection mode to Direct. This is used by the client when connecting to the Azure Cosmos DB service.
            </summary>
            <param name="idleTcpConnectionTimeout">
            Controls the amount of idle time after which unused connections are closed.
            By default, idle connections are kept open indefinitely. Value must be greater than or equal to 10 minutes. Recommended values are between 20 minutes and 24 hours.
            Mainly useful for sparse infrequent access to a large database account.
            </param>
            <param name="openTcpConnectionTimeout">
            Controls the amount of time allowed for trying to establish a connection.
            The default timeout is 5 seconds. Recommended values are greater than or equal to 5 seconds.
            When the time elapses, the attempt is cancelled and an error is returned. Longer timeouts will delay retries and failures.
            </param>
            <param name="maxRequestsPerTcpConnection">
            Controls the number of requests allowed simultaneously over a single TCP connection. When more requests are in flight simultaneously, the direct/TCP client will open additional connections.
            The default settings allow 30 simultaneous requests per connection.
            Do not set this value lower than 4 requests per connection or higher than 50-100 requests per connection.       
            The former can lead to a large number of connections to be created. 
            The latter can lead to head of line blocking, high latency and timeouts.
            Applications with a very high degree of parallelism per connection, with large requests or responses, or with very tight latency requirements might get better performance with 8-16 requests per connection.
            </param>
            <param name="maxTcpConnectionsPerEndpoint">
            Controls the maximum number of TCP connections that may be opened to each Cosmos DB back-end.
            Together with MaxRequestsPerTcpConnection, this setting limits the number of requests that are simultaneously sent to a single Cosmos DB back-end(MaxRequestsPerTcpConnection x MaxTcpConnectionPerEndpoint).
            The default value is 65,535. Value must be greater than or equal to 16.
            </param>
            <param name="portReuseMode">
            (Direct/TCP) Controls the client port reuse policy used by the transport stack.
            The default value is PortReuseMode.ReuseUnicastPort.
            </param>
            /// <param name="enableTcpConnectionEndpointRediscovery">
            (Direct/TCP) Controls the address cache refresh on TCP connection reset notification.
            The default value is false.
            </param>
            <remarks>
            For more information, see <see href="https://docs.microsoft.com/azure/documentdb/documentdb-performance-tips#direct-connection">Connection policy: Use direct connection mode</see>.
            </remarks>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConsistencyLevel(Microsoft.Azure.Cosmos.ConsistencyLevel)">
            <summary>
            This can be used to weaken the database account consistency level for read operations.
            If this is not set the database account consistency level will be used for all requests.
            </summary>
            <param name="consistencyLevel">The desired consistency level for the client.</param>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithConnectionModeGateway(System.Nullable{System.Int32},System.Net.IWebProxy)">
            <summary>
            Sets the connection mode to Gateway. This is used by the client when connecting to the Azure Cosmos DB service.
            </summary>
            <param name="maxConnectionLimit">The number specifies the time to wait for response to come back from network peer. Default is 60 connections</param>
            <param name="webProxy">Get or set the proxy information used for web requests.</param>
            <remarks>
            For more information, see <see href="https://docs.microsoft.com/azure/documentdb/documentdb-performance-tips#direct-connection">Connection policy: Use direct connection mode</see>.
            </remarks>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.ConnectionMode"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.GatewayModeMaxConnectionLimit"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.AddCustomHandlers(Microsoft.Azure.Cosmos.RequestHandler[])">
            <summary>
            Sets an array of custom handlers to the request. The handlers will be chained in
            the order listed. The InvokerHandler.InnerHandler is required to be null to allow the
            pipeline to chain the handlers.
            </summary>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <param name="customHandlers">A list of <see cref="T:Microsoft.Azure.Cosmos.RequestHandler"/> instaces to add to the pipeline.</param>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.CustomHandlers"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithThrottlingRetryOptions(System.TimeSpan,System.Int32)">
            <summary>
            Sets the maximum time to wait between retry and the max number of times to retry on throttled requests.
            </summary>
            <param name="maxRetryWaitTimeOnThrottledRequests">The maximum retry time in seconds for the Azure Cosmos DB service. Any interval that is smaller than a second will be ignored.</param>
            <param name="maxRetryAttemptsOnThrottledRequests">The number specifies the times retry requests for throttled requests.</param>
            <para>
            When a request fails due to a rate limiting error, the service sends back a response that
            contains a value indicating the client should not retry before the time period has
            elapsed. This property allows the application to set a maximum wait time for all retry attempts.
            If the cumulative wait time exceeds the this value, the client will stop retrying and return the error to the application.
            </para>
            <para>
            For more information, see <see href="https://docs.microsoft.com/azure/documentdb/documentdb-performance-tips#429">Handle rate limiting/request rate too large</see>.
            </para>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/>.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaxRetryWaitTimeOnRateLimitedRequests"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.MaxRetryAttemptsOnRateLimitedRequests"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithSerializerOptions(Microsoft.Azure.Cosmos.CosmosSerializationOptions)">
            <summary>
            Set a custom serializer option. 
            </summary>
            <param name="cosmosSerializerOptions">The custom class that implements <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> </param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.SerializerOptions"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithCustomSerializer(Microsoft.Azure.Cosmos.CosmosSerializer)">
            <summary>
            Set a custom JSON serializer. 
            </summary>
            <param name="cosmosJsonSerializer">The custom class that implements <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> </param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.Serializer"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithBulkExecution(System.Boolean)">
            <summary>
            Allows optimistic batching of requests to service. Setting this option might impact the latency of the operations. Hence this option is recommended for non-latency sensitive scenarios only.
            </summary>
            <param name="enabled">Whether <see cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.AllowBulkExecution"/> is enabled.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.AllowBulkExecution"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithHttpClientFactory(System.Func{System.Net.Http.HttpClient})">
            <summary>
            Sets a delegate to use to obtain an HttpClient instance to be used for HTTPS communication.
            </summary>
            <param name="httpClientFactory">A delegate function to generate instances of HttpClient.</param>
            <remarks>
            <para>
            HTTPS communication is used when <see cref="T:Microsoft.Azure.Cosmos.ConnectionMode"/> is set to <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Gateway"/> for all operations and when <see cref="T:Microsoft.Azure.Cosmos.ConnectionMode"/> is <see cref="F:Microsoft.Azure.Cosmos.ConnectionMode.Direct"/> (default) for metadata operations.
            </para>
            <para>
            Useful in scenarios where the application is using a pool of HttpClient instances to be shared, like ASP.NET Core applications with IHttpClientFactory or Blazor WebAssembly applications.
            </para>
            </remarks>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.CosmosClientOptions.HttpClientFactory"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithContentResponseOnWrite(System.Boolean)">
            <summary>
            Gets or sets the boolean to only return the headers and status code in
            the Cosmos DB response for write item operation like Create, Upsert, Patch and Replace.
            Setting the option to false will cause the response to have a null resource. This reduces networking and CPU load by not sending
            the resource back over the network and serializing it on the client.
            </summary>
            <param name="contentResponseOnWrite">a boolean indicating whether payload will be included in the response or not.</param>
            <remarks>
            <para>
            This option can be overriden by similar property in ItemRequestOptions and TransactionalBatchItemRequestOptions
            </para>
            </remarks>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.EnableContentResponseOnWrite"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.TransactionalBatchItemRequestOptions.EnableContentResponseOnWrite"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithSendingRequestEventArgs(System.EventHandler{Microsoft.Azure.Documents.SendingRequestEventArgs})">
            <summary>
            The event handler to be invoked before the request is sent.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithSessionContainer(Microsoft.Azure.Documents.ISessionContainer)">
            <summary>
            Sets the ambient Session Container to use for this CosmosClient.
            This is used to track session tokens per client for requests made to the store.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithTransportClientHandlerFactory(System.Func{Microsoft.Azure.Documents.TransportClient,Microsoft.Azure.Documents.TransportClient})">
            <summary>
            (Optional) transport interceptor factory
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithApiType(Microsoft.Azure.Documents.ApiType)">
            <summary>
            ApiType for the account
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithStoreClientFactory(Microsoft.Azure.Documents.IStoreClientFactory)">
            <summary>
            Specify a store client factory to use for all transport requests for cosmos client.
            </summary>
            <remarks>
            This method enables transport client sharing among multiple cosmos client instances inside a single process.
            </remarks>
            <param name="storeClientFactory">Instance of store client factory to use to create transport client for an instance of cosmos client.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithCpuMonitorDisabled">
            <summary>
            Disables CPU monitoring for transport client which will inhibit troubleshooting of timeout exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithTelemetryDisabled">
            <summary>
            Disable Telemetry if enabled using environment properties
            </summary>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithTelemetryEnabled">
            <summary>
            To enable Telemetry, set COSMOS.CLIENT_TELEMETRY_ENABLED environment property. 
            This function is used by Test only.
            </summary>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder"/> object</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CosmosClientBuilder.WithPartitionLevelFailoverEnabled">
            <summary>
            Enabled partition level failover in the SDK
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.ChangeFeedPolicyDefinition">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedPolicy"/> fluent definition.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ChangeFeedPolicyDefinition.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.ClientEncryptionPolicyDefinition">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionPolicy"/> fluent definition.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ClientEncryptionPolicyDefinition.WithIncludedPath(Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath)">
            <summary>
            Adds a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath"/> to the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.ClientEncryptionPolicyDefinition"/>.
            </summary>
            <param name="path">ClientEncryptionIncludedPath to add.</param>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.ClientEncryptionPolicyDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ClientEncryptionPolicyDefinition.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1">
            <summary>
            Composite Index fluent definition.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.CompositePath"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1.Path(System.String)">
            <summary>
            Add a path to the current <see cref="T:Microsoft.Azure.Cosmos.CompositePath"/> definition.
            </summary>
            <param name="path">Property path for the current definition. Example: /property</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1.Path(System.String,Microsoft.Azure.Cosmos.CompositePathSortOrder)">
            <summary>
            Add a path to the current <see cref="T:Microsoft.Azure.Cosmos.CompositePath"/> definition with a particular <see cref="T:Microsoft.Azure.Cosmos.CompositePathSortOrder"/>.
            </summary>
            <param name="path">Property path for the current definition. Example: /property</param>
            <param name="sortOrder"><see cref="T:Microsoft.Azure.Cosmos.CompositePathSortOrder"/> to apply on the path.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionPolicy"/> fluent definition.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition.WithLastWriterWinsResolution(System.String)">
            <summary>
            Defines the path used to resolve LastWrtierWins resolution mode <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionPolicy"/>.
            </summary>
            <param name="conflictResolutionPath"> sets the path which is present in each item in the Azure Cosmos DB service for last writer wins conflict-resolution. <see cref="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.ResolutionPath"/>.</param>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition.WithCustomStoredProcedureResolution(System.String)">
            <summary>
            Defines the stored procedure to be used as custom conflict resolution mode <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionPolicy"/>.
            </summary>
            <param name="conflictResolutionProcedure"> Sets the stored procedure's name to be used for conflict-resolution.</param>
            <remarks>The stored procedure can be created later on, but needs to honor the name specified here.</remarks>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition"/>.</returns>
            <example>
            This example below creates a <see cref="T:Microsoft.Azure.Cosmos.Container"/> with a Conflict Resolution policy that uses a stored procedure to resolve conflicts:
            <code language="c#">
            <![CDATA[
            await databaseForConflicts.DefineContainer("myContainer", "/id")
                .WithConflictResolution()
                    .WithCustomStoredProcedureResolution("myStoredProcedure")
                    .Attach()
                .CreateAsync();
            </example>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.Container"/> fluent definition for creation flows.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.#ctor">
            <summary>
            Creates an instance for unit-testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.#ctor(Microsoft.Azure.Cosmos.Database,System.String,System.String)">
            <summary>
            Creates an instance of ContainerBuilder .
            </summary>
            <param name="database"> The Microsoft.Azure.Cosmos.Database object.</param>
            <param name="name"> Azure Cosmos container name to create. </param>
            <param name="partitionKeyPath"> The path to the partition key. Example: /partitionKey </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.WithUniqueKey">
            <summary>
            Defines a Unique Key policy for this Azure Cosmos container.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.WithConflictResolution">
            <summary>
            Defined the conflict resolution for Azure Cosmos container
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.ConflictResolutionDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.WithChangeFeedPolicy(System.TimeSpan)">
            <summary>
            Defined the change feed policy for this Azure Cosmos container
            </summary>
            <param name="retention"> Indicates for how long operation logs have to be retained. <see cref="P:Microsoft.Azure.Cosmos.ChangeFeedPolicy.FullFidelityRetention"/>.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.ChangeFeedPolicyDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.WithClientEncryptionPolicy">
            <summary>
            Defines the ClientEncryptionPolicy for Azure Cosmos container
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.ClientEncryptionPolicyDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.CreateAsync(Microsoft.Azure.Cosmos.ThroughputProperties,System.Threading.CancellationToken)">
            <summary>
            Creates a container with the current fluent definition.
            </summary>
            <param name="throughputProperties">Desired throughput for the container expressed in Request Units per second.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>An asynchronous Task representing the creation of a <see cref="T:Microsoft.Azure.Cosmos.Container"/> based on the Fluent definition.</returns>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.CreateIfNotExistsAsync(Microsoft.Azure.Cosmos.ThroughputProperties,System.Threading.CancellationToken)">
            <summary>
            Creates a container if it does not exist with the current fluent definition.
            </summary>
            <param name="throughputProperties">Desired throughput for the container expressed in Request Units per second.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>An asynchronous Task representing the creation of a <see cref="T:Microsoft.Azure.Cosmos.Container"/> based on the Fluent definition.</returns>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.CreateAsync(System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Creates a container with the current fluent definition.
            </summary>
            <param name="throughput">Desired throughput for the container expressed in Request Units per second.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>An asynchronous Task representing the creation of a <see cref="T:Microsoft.Azure.Cosmos.Container"/> based on the Fluent definition.</returns>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.CreateIfNotExistsAsync(System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Creates a container if it does not exist with the current fluent definition.
            </summary>
            <param name="throughput">Desired throughput for the container expressed in Request Units per second.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>An asynchronous Task representing the creation of a <see cref="T:Microsoft.Azure.Cosmos.Container"/> based on the Fluent definition.</returns>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerBuilder.Build">
            <summary>
            Applies the current Fluent definition and creates a container configuration.
            </summary>
            <returns>Builds the current Fluent configuration into an instance of <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1">
            <summary>
            Azure Cosmos container fluent definition.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Container"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.#ctor">
            <summary>
            Creates an instance for unit-testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.WithPartitionKeyDefinitionVersion(Microsoft.Azure.Cosmos.PartitionKeyDefinitionVersion)">
             <summary>
             Sets the <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyDefinitionVersion"/>
            
             The partition key definition version 1 uses a hash function that computes
             hash based on the first 100 bytes of the partition key. This can cause
             conflicts for documents with partition keys greater than 100 bytes.
             
             The partition key definition version 2 uses a hash function that computes
             hash based on the first 2 KB of the partition key.
             </summary>
             <param name="partitionKeyDefinitionVersion">The partition key definition version</param>
             <returns>An instance of the current Fluent builder.</returns>
             <seealso cref="P:Microsoft.Azure.Cosmos.ContainerProperties.PartitionKeyDefinitionVersion"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.WithDefaultTimeToLive(System.TimeSpan)">
            <summary>
            <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> will be applied to all the items in the container as the default time-to-live policy.
            The individual item could override the default time-to-live policy by setting its time to live.
            </summary>
            <param name="defaultTtlTimeSpan">The default Time To Live.</param>
            <returns>An instance of the current Fluent builder.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.WithDefaultTimeToLive(System.Int32)">
            <summary>
            <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> will be applied to all the items in the container as the default time-to-live policy.
            The individual item could override the default time-to-live policy by setting its time to live.
            </summary>
            <param name="defaultTtlInSeconds">The default Time To Live.</param>
            <returns>An instance of the current Fluent builder.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.WithTimeToLivePropertyPath(System.String)">
            <summary>
            Sets the time to live base timestamp property path.
            </summary>
            <param name="propertyPath">This property should be only present when DefaultTimeToLive is set. When this property is present, time to live for a item is decided based on the value of this property in an item. By default, time to live is based on the _ts property in an item. Example: /property</param>
            <returns>An instance of the current Fluent builder.</returns>
            <seealso cref="P:Microsoft.Azure.Cosmos.ContainerProperties.TimeToLivePropertyPath"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.WithIndexingPolicy">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.IndexingPolicy"/> definition for the current Azure Cosmos container.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.ContainerDefinition`1.Build">
            <summary>
            Applies the current Fluent definition and creates a container configuration.
            </summary>
            <returns>Builds the current Fluent configuration into an instance of <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1">
            <summary>
            Indexing Policy fluent definition.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.IndexingPolicy"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.#ctor">
            <summary>
            Creates an instance for unit-testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.WithIndexingMode(Microsoft.Azure.Cosmos.IndexingMode)">
            <summary>
            Defines the <see cref="T:Microsoft.Azure.Cosmos.Container"/>'s <see cref="T:Microsoft.Azure.Cosmos.IndexingMode"/>.
            </summary>
            <param name="indexingMode">An <see cref="T:Microsoft.Azure.Cosmos.IndexingMode"/></param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1"/>.</returns>
            <remarks>
            If multiple calls are made to this method within the same <see cref="T:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1"/>, the last one will apply.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.WithAutomaticIndexing(System.Boolean)">
            <summary>
            Defines the <see cref="T:Microsoft.Azure.Cosmos.Container"/>'s automatic indexing.
            </summary>
            <param name="enabled">Defines whether Automatic Indexing is enabled or not.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.WithIncludedPaths">
            <summary>
            Defines the <see cref="T:Microsoft.Azure.Cosmos.Container"/>'s <see cref="P:Microsoft.Azure.Cosmos.IndexingPolicy.IncludedPaths"/>.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.WithExcludedPaths">
            <summary>
            Defines the <see cref="T:Microsoft.Azure.Cosmos.Container"/>'s <see cref="P:Microsoft.Azure.Cosmos.IndexingPolicy.ExcludedPaths"/>.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.WithCompositeIndex">
            <summary>
            Defines a Composite Index in the current <see cref="T:Microsoft.Azure.Cosmos.Container"/>'s definition.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.CompositeIndexDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.WithSpatialIndex">
            <summary>
            Defines a <see cref="T:Microsoft.Azure.Cosmos.SpatialIndex"/> in the current <see cref="T:Microsoft.Azure.Cosmos.Container"/>'s definition.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.IndexingPolicyDefinition`1.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1">
            <summary>
            Fluent definition to specify paths.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1.Path(System.String)">
            <summary>
            Adds a path to the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1"/>.
            </summary>
            <param name="path">Property path for the current definition. Example: /path/*</param>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.PathsDefinition`1.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1">
            <summary>
            Spatial index fluent definition.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.SpatialPath"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1.Path(System.String)">
            <summary>
            Adds a path to the current <see cref="T:Microsoft.Azure.Cosmos.SpatialPath"/> definition.
            </summary>
            <param name="path">Property path for the current definition. Example: /property</param>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1.Path(System.String,Microsoft.Azure.Cosmos.SpatialType[])">
            <summary>
            Add a path to the current <see cref="T:Microsoft.Azure.Cosmos.SpatialPath"/> definition with a particular set of <see cref="T:Microsoft.Azure.Cosmos.SpatialType"/>s.
            </summary>
            <param name="path">Property path for the current definition. Example: /property</param>
            <param name="spatialTypes">Set of <see cref="T:Microsoft.Azure.Cosmos.SpatialType"/> to apply to the path.</param>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.SpatialIndexDefinition`1.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.UniqueKeyPolicy"/> fluent definition.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition.Path(System.String)">
            <summary>
            Adds a path to the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition"/>.
            </summary>
            <param name="path">Path for the property to add to the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition"/>. Example: /property</param>
            <returns>An instance of the current <see cref="T:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Fluent.UniqueKeyDefinition.Attach">
            <summary>
            Applies the current definition to the parent.
            </summary>
            <returns>An instance of the parent.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handlers.DiagnosticsHandler">
            <summary>
            Handler which add process level info like CPU usage to the
            diagnostics. This is a best effort scenario. It will not
            add or attempt to add it if an exception occurs to avoid
            impacting users.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handlers.NamedCacheRetryHandler">
            <summary>
            Refreshed named cache in-case of Gone with NameCacheIsStale
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handlers.PartitionKeyRangeHandler">
            <summary>
            Handler which manages the continuation token and partition-key-range-id selection depending on a provided start and end epk and direction. 
            By default start is 00, end is FF and direction is forward. 
            It doesn't participates in split logic directly but on split retry, will select the new 
            appropriate partition-key-range id after a forced refresh of the CollectionRoutingMap.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handlers.RequestInvokerHandler">
            <summary>
            HttpMessageHandler can only be invoked by derived classed or internal classes inside http assembly
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handlers.RetryHandler">
            <summary>
            Handler to wrap the pipeline into a retry mechanism defined by a <see cref="T:Microsoft.Azure.Cosmos.IDocumentClientRetryPolicy"/>
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handlers.RouterHandler">
            <summary>
            Handler which selects the pipeline for the requested resource operation
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Handlers.TelemetryHandler.GetPayloadSize(Microsoft.Azure.Cosmos.ResponseMessage)">
            <summary>
            It returns the payload size after reading it from the Response content stream. 
            To avoid blocking IO calls to get the stream length, it will return response content length if stream is of Memory Type
            otherwise it will return the content length from the response header (if it is there)
            </summary>
            <param name="response"></param>
            <returns>Size of Payload</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientPipelineBuilder.Build">
            <summary>
            This is the cosmos pipeline logic for the operations. 
            
                                               +-----------------------------+
                                               |                             |
                                               |    RequestInvokerHandler    |
                                               |                             |
                                               +-----------------------------+
                                                            |
                                                            |
                                                            |
                                               +-----------------------------+
                                               |                             |
                                               |       UserHandlers          |
                                               |                             |
                                               +-----------------------------+
                                                            |
                                                            |
                                                            |
                                               +-----------------------------+
                                               |                             |
                                               |       DiagnosticHandler     |
                                               |                             |
                                               +-----------------------------+
                                                            |
                                                            |
                                                            |
                                               +-----------------------------+
                                               |                             |
                                               |       TelemetryHandler      |-> Trigger a thread to monitor system usage/operation information and sends to an API
                                               |                             |
                                               +-----------------------------+
                                                            |
                                                            |
                                                            |
                                               +-----------------------------+
                                               |                             |
                                               |       RetryHandler          |-> RetryPolicy -> ResetSessionTokenRetryPolicyFactory -> ClientRetryPolicy -> ResourceThrottleRetryPolicy
                                               |                             |
                                               +-----------------------------+
                                                            |
                                                            |
                                                            |
                                               +-----------------------------+
                                               |                             |
                                               |       RouteHandler          | 
                                               |                             |
                                               +-----------------------------+
                                               |                             |
                                               |                             |
                                               |                             |
                             +-----------------------------+         +---------------------------------------+
                             | !IsPartitionedFeedOperation |         |    IsPartitionedFeedOperation         |
                             |      TransportHandler       |         | invalidPartitionExceptionRetryHandler |
                             |                             |         |                                       |
                             +-----------------------------+         +---------------------------------------+
                                                                                     |
                                                                                     |
                                                                                     |
                                                                     +---------------------------------------+
                                                                     |                                       |
                                                                     |     PartitionKeyRangeHandler          |
                                                                     |                                       |
                                                                     +---------------------------------------+
                                                                                     |
                                                                                     |
                                                                                     |
                                                                     +---------------------------------------+
                                                                     |                                       |
                                                                     |         TransportHandler              |
                                                                     |                                       |
                                                                     +---------------------------------------+
            </summary>
            <returns>The request invoker handler used to do calls to Cosmos DB</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Handler.DiagnosticsHandlerHelper">
            <summary>
            This is a helper class that creates a single static instance to avoid each
            client instance from creating a new System Usage monitor with Diagnostics and Telemetry Recorders(if enabled).
            The diagnostics should never block a request, and is a best attempt
            If the CPU load history fails then don't try it in the future.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Handler.DiagnosticsHandlerHelper.Instance">
            <summary>
            Singleton to make sure only one instance of DiagnosticHandlerHelper is there.
            The system usage collection is disabled for internal builds so it is set to null to avoid
            compute for accidentally creating an instance or trying to use it.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Handler.DiagnosticsHandlerHelper.#ctor">
            <summary>
            Start System Usage Monitor with Diagnostic and Telemetry Recorder if Telemetry is enabled 
            Otherwise Start System Usage Monitor with only Diagnostic Recorder
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Handler.DiagnosticsHandlerHelper.GetDiagnosticsSystemHistory">
            <summary>
            This method will give CPU Usage(%), Memory Usage(kb) and ThreadPool Information from Diagnostic recorder, 
            It will return null if Diagnostic Monitoring is not enabled or throws any error while reading data from the recorder.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Handler.DiagnosticsHandlerHelper.GetClientTelemetrySystemHistory">
            <summary>
            This method will give CPU Usage(%), Memory Usage(kb) and ThreadPool Information from Client Telemetry recorder.
            It will return null if Diagnostic Monitoring is not enabled or throws any error while reading data from the recorder.
            </summary>
            <returns> CpuAndMemoryUsageRecorder</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RequestHandler">
            <summary>
            Abstraction which allows defining of custom message handlers.
            </summary>
            <remarks>
            Custom implementations are required to be stateless.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestHandler.InnerHandler">
            <summary>
            Defines a next handler to be called in the chain.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestHandler.#ctor">
            <summary>
            The default constructor for the RequestHandler
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestHandler.SendAsync(Microsoft.Azure.Cosmos.RequestMessage,System.Threading.CancellationToken)">
            <summary>
            Processes the current <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> in the current handler and sends the current <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> to the next handler in the chain.
            </summary>
            <param name="request"><see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> received by the handler.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> received by the handler.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RequestMessage">
            <summary>
            Represents a request in the processing pipeline of the Azure Cosmos DB SDK.
            </summary>
            <remarks>
            It is expected that direct property access is used for properties that will be read and used within the Azure Cosmos SDK pipeline, for example <see cref="P:Microsoft.Azure.Cosmos.RequestMessage.OperationType"/>.
            <see cref="P:Microsoft.Azure.Cosmos.RequestMessage.Properties"/> should be used for any other property that needs to be sent to the backend but will not be read nor used within the Azure Cosmos DB SDK pipeline.
            <see cref="P:Microsoft.Azure.Cosmos.RequestMessage.Headers"/> should be used for HTTP headers that need to be passed down and sent to the backend.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestMessage.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestMessage.#ctor(System.Net.Http.HttpMethod,System.Uri)">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/>
            </summary>
            <param name="method">The http method</param>
            <param name="requestUri">The requested URI</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestMessage.#ctor(System.Net.Http.HttpMethod,System.String,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/>
            </summary>
            <param name="method">The http method</param>
            <param name="requestUriString">The requested URI</param>
            /// <param name="trace">The trace node to append traces to.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.Method">
            <summary>
            Gets the <see cref="T:System.Net.Http.HttpMethod"/> for the current request.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.RequestUri">
            <summary>
            Gets the <see cref="T:System.Uri"/> for the current request.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.Headers">
            <summary>
            Gets the current <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> HTTP headers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.Content">
            <summary>
            Gets or sets the current <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> payload.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.UseGatewayMode">
            <summary>
            Used to override the client default. This is used for scenarios
            in query where the service interop is not present.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.IsPartitionKeyRangeHandlerRequired">
            <summary>
            The partition key range handler is only needed for read feed on partitioned resources 
            where the partition key range needs to be computed. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestMessage.Properties">
            <summary>
            Request properties Per request context available to handlers. 
            These will not be automatically included into the wire.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestMessage.Dispose">
            <summary>
            Disposes the current <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestMessage.Dispose(System.Boolean)">
            <summary>
            Disposes of the request message content
            </summary>
            <param name="disposing">True to dispose content</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ResponseMessage">
            <summary>
            Represents a response from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.RequestMessage,System.String)">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>
            </summary>
            <param name="statusCode">The HttpStatusCode of the response</param>
            <param name="requestMessage">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> object</param>
            <param name="errorMessage">The reason for failures if any.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.RequestMessage,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.CosmosException,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>
            </summary>
            <param name="statusCode">The HttpStatusCode of the response</param>
            <param name="requestMessage">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/> object</param>
            <param name="headers">The headers for the response.</param>
            <param name="cosmosException">The exception if the response is from an error.</param>
            <param name="trace">The trace for the request</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.StatusCode">
            <summary>
            Gets the <see cref="T:System.Net.HttpStatusCode"/> of the current response.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.Content">
            <summary>
            Gets the content as a <see cref="T:System.IO.Stream"/>, if any, of the current response.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.ErrorMessage">
            <summary>
            Gets the reason for a failure in the current response.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.Headers">
            <summary>
            Gets the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> HTTP headers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.ContinuationToken">
            <summary>
            Gets the Continuation Token in the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
            <remarks>
            This is only used in feed operations like query and change feed
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.IndexMetrics">
            <summary>
            Gets the Index Metrics in the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> to be used for debugging purposes. 
            It's applicable to query response only. Other feed response will return null for this field.
            This result is only available if QueryRequestOptions.PopulateIndexMetrics is set to true.
            </summary>
            <value>
            The index utilization metrics.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.RequestMessage">
            <summary>
            Gets the original request message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.Diagnostics">
            <summary>
            Gets the cosmos diagnostic information for the current request to Azure Cosmos DB service
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResponseMessage.IsSuccessStatusCode">
            <summary>
            Asserts if the current <see cref="T:System.Net.HttpStatusCode"/> is a success.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.EnsureSuccessStatusCode">
            <summary>
            Checks if the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> has a successful status code, otherwise, throws.
            </summary>
            <exception cref="T:Microsoft.Azure.Cosmos.CosmosException">An instance of <see cref="T:Microsoft.Azure.Cosmos.CosmosException"/> representing the error state.</exception>
            <returns>The current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.Dispose">
            <summary>
            Disposes the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.Dispose(System.Boolean)">
            <summary>
            Dispose of the response message content
            </summary>
            <param name="disposing">True to dispose of content</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResponseMessage.DecodeIndexMetrics(Microsoft.Azure.Cosmos.Headers)">
            <summary>
            Decode the Index Metrics from the response headers, if exists.
            </summary>
            <param name="responseMessageHeaders">The response headers</param>
            <returns>Lazy implementation of the pretty-printed IndexMetrics</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosQueryResponseMessageHeaders">
            <summary>
            HTTP headers in a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Headers">
            <summary>
            Header implementation used for Request and Responses
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.RequestMessage"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.ContinuationToken">
            <summary>
            Gets the Continuation Token in the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.RequestCharge">
            <summary>
            Gets the request charge for this request from the Azure Cosmos DB service.
            </summary>
            <value>
            The request charge measured in request units.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.ActivityId">
            <summary>
            Gets the activity ID for the request from the Azure Cosmos DB service.
            </summary>
            <value>
            The activity ID for the request.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.ContentType">
            <summary>
            Gets the Content Type for the current content in the <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.Session">
            <summary>
            Gets the Session Token for the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
            <remarks>
            Session Token is used along with Session Consistency.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.ContentLength">
            <summary>
            Gets the Content Length for the current content in the <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.Location">
            <summary>
            Gets the Location for the current content in the <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.Azure.Cosmos.Headers"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Headers.Item(System.String)">
            <summary>
            Gets the value of a particular header.
            </summary>
            <param name="headerName">Header name to look for.</param>
            <returns>The header value.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.GetEnumerator">
            <summary>
            Enumerates all the HTTP headers names in the <see cref="T:Microsoft.Azure.Cosmos.Headers"/>.
            </summary>
            <returns>An enumerator for all headers.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.Add(System.String,System.String)">
            <summary>
            Adds a header to the Header collection.
            </summary>
            <param name="headerName">Header name.</param>
            <param name="value">Header value.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.Add(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds a header to the Header collection.
            </summary>
            <param name="headerName">Header name.</param>
            <param name="values">List of values to be added as a comma-separated list.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.Set(System.String,System.String)">
            <summary>
            Adds or updates a header in the Header collection.
            </summary>
            <param name="headerName">Header name.</param>
            <param name="value">Header value.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.Get(System.String)">
            <summary>
            Gets the value of a particular header.
            </summary>
            <param name="headerName">Header name.</param>
            <returns>The header value.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.TryGetValue(System.String,System.String@)">
            <summary>
            Tries to get the value for a particular header.
            </summary>
            <param name="headerName">Header name.</param>
            <param name="value">Header value.</param>
            <returns>True or false if the header name existed in the header collection.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.GetValueOrDefault(System.String)">
            <summary>
            Returns the header value or the default(string)
            </summary>
            <param name="headerName">Header Name</param>
            <returns>Returns the header value or the default(string).</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.Remove(System.String)">
            <summary>
            Removes a header from the header collection.
            </summary>
            <param name="headerName">Header name.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.AllKeys">
            <summary>
            Obtains a list of all header names.
            </summary>
            <returns>An array with all the header names.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.GetHeaderValue``1(System.String)">
            <summary>
            Gets a header value with a particular type.
            </summary>
            <typeparam name="T">Type of the header value.</typeparam>
            <param name="headerName">Header name.</param>
            <returns>The header value parsed for a particular type.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Headers.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates all the HTTP headers names in the <see cref="T:Microsoft.Azure.Cosmos.Headers"/>.
            </summary>
            <returns>An enumerator for all headers.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.HttpResponseHeadersWrapper.#ctor(System.Net.Http.Headers.HttpResponseHeaders,System.Net.Http.Headers.HttpContentHeaders)">
            <summary>
            HttpResponse can have 2 headers. These headers have restrictions on what values are allowed.
            This optimizes to combine the 2 headers without iterating overall of them to duplicate it into a new
            header object.
            </summary>
            <param name="responseHeaders"></param>
            <param name="httpContentHeaders"></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.NameValueResponseHeaders">
            <summary>
            Header implementation used for Responses
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.StoreResponseHeaders">
            <summary>
            Header implementation used for Responses
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IDocumentClient">
            <summary>
            The IDocumentClient interface captures the API signatures of the Azure Cosmos DB service .NET SDK.
            See <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> for implementation details.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.Session">
            <summary>
            Gets or sets the session object used for session consistency version tracking in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <value>
            The session object used for version tracking when the consistency level is set to Session.
            </value>
            The session object can be saved and shared between two DocumentClient instances within the same AppDomain.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.ServiceEndpoint">
            <summary>
            Gets the endpoint Uri for the service endpoint from the Azure Cosmos DB service.
            </summary>
            <value>
            The Uri for the service endpoint.
            </value>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.WriteEndpoint">
            <summary>
            Gets the current write endpoint chosen based on availability and preference in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.ReadEndpoint">
            <summary>
            Gets the current read endpoint chosen based on availability and preference in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.ConnectionPolicy">
            <summary>
            Gets the Connection policy used by the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The Connection policy used by the client.
            </value>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.AuthKey">
            <summary>
            Gets the AuthKey used by the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The AuthKey used by the client.
            </value>
            <seealso cref="T:System.Security.SecureString"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentClient.ConsistencyLevel">
            <summary>
            Gets the configured consistency level of the client from the Azure Cosmos DB service.
            </summary>
            <value>
            The configured <see cref="T:Microsoft.Azure.Cosmos.ConsistencyLevel"/> of the client.
            </value>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConsistencyLevel"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.GetDatabaseAccountAsync">
            <summary>
            Read the <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <returns>
            A <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> wrapped in a <see cref="T:System.Threading.Tasks.Task"/> object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDatabaseAsync(Microsoft.Azure.Documents.Database,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a database resource as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="database">The specification for the <see cref="T:Microsoft.Azure.Cosmos.Database"/> to create.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Database"/> that was created within a task object representing the service response for the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="database"/> is not set.</exception>
            <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Database are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>400</term><description>BadRequest - This means something was wrong with the database object supplied. It is likely that an id was not supplied for the new Database.</description>
                </item>
                <item>
                    <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an id matching the id field of <paramref name="database"/> already existed.</description>
                </item>
            </list>
            </exception>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an Id property of 'MyDatabase'
            This code snippet is intended to be used from within an asynchronous method as it uses the await keyword
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = await client.CreateDatabaseAsync(new Database { Id = "MyDatabase" });
            }
            ]]>
            </code>
            </example>
            <example>
            If you would like to construct a <see cref="T:Microsoft.Azure.Cosmos.Database"/> from within a synchronous method then you need to use the following code
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = client.CreateDatabaseAsync(new Database { Id = "MyDatabase" }).Result;
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDatabaseIfNotExistsAsync(Microsoft.Azure.Documents.Database,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates(if doesn't exist) or gets(if already exists) a database resource as an asychronous operation in the Azure Cosmos DB service.
            You can check the status code from the response to determine whether the database was newly created(201) or existing database was returned(200)
            </summary>
            <param name="database">The specification for the <see cref="T:Microsoft.Azure.Cosmos.Database"/> to create.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Database"/> that was created within a task object representing the service response for the asynchronous operation.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="database"/> is not set.</exception>
            <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property.</exception>
            <example>
            The example below creates a new <see cref="T:Microsoft.Azure.Cosmos.Database"/> with an Id property of 'MyDatabase'
            This code snippet is intended to be used from within an asynchronous method as it uses the await keyword
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = await client.CreateDatabaseIfNotExistsAsync(new Database { Id = "MyDatabase" });
            }
            ]]>
            </code>
            </example>
            <example>
            If you would like to construct a <see cref="T:Microsoft.Azure.Cosmos.Database"/> from within a synchronous method then you need to use the following code
            <code language="c#">
            <![CDATA[
            using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
            {
                Database db = client.CreateDatabaseIfNotExistsAsync(new Database { Id = "MyDatabase" }).Result;
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a collection as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="databaseLink">The link of the database to create the collection in. E.g. dbs/db_rid/.</param>
             <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="documentCollection"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a collection are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an id was not supplied for the new collection.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This means you attempted to exceed your quota for collections. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> with an id matching the id you supplied already existed.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 //Create a new collection with an OfferThroughput set to 10000
                 //Not passing in RequestOptions.OfferThroughput will result in a collection with the default OfferThroughput set.
                 DocumentCollection coll = await client.CreateDocumentCollectionAsync(databaseLink,
                     new DocumentCollection { Id = "My Collection" },
                     new RequestOptions { OfferThroughput = 10000} );
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionIfNotExistsAsync(System.String,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates (if doesn't exist) or gets (if already exists) a collection as an asychronous operation in the Azure Cosmos DB service.
             You can check the status code from the response to determine whether the collection was newly created (201) or existing collection was returned (200).
             </summary>
             <param name="databaseLink">The link of the database to create the collection in. E.g. dbs/db_rid/.</param>
             <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="databaseLink"/> or <paramref name="documentCollection"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s).</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a DocumentCollection are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an id was not supplied for the new collection.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This means you attempted to exceed your quota for collections. Contact support to have this quota increased.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 //Create a new collection with an OfferThroughput set to 10000
                 //Not passing in RequestOptions.OfferThroughput will result in a collection with the default OfferThroughput set.
                 DocumentCollection coll = await client.CreateDocumentCollectionIfNotExistsAsync(databaseLink,
                     new DocumentCollection { Id = "My Collection" },
                     new RequestOptions { OfferThroughput = 10000} );
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a collection as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">The URI of the database to create the collection in.</param>
            <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionIfNotExistsAsync(System.Uri,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates (if doesn't exist) or gets (if already exists) a collection as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">the URI of the database to create the collection in.</param>
            <param name="documentCollection">The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> object.</param>
            <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> you wish to provide when creating a Collection. E.g. RequestOptions.OfferThroughput = 400. </param>
            <returns>The <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentAsync(System.String,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
             <summary>
             Creates a Document as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to create the document in. E.g. dbs/db_rid/colls/coll_rid/ </param>
             <param name="document">The document object to create.</param>
             <param name="options">(Optional) Any request options you wish to set. E.g. Specifying a Trigger to execute when creating the document. <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/></param>
             <param name="disableAutomaticIdGeneration">(Optional) Disables the automatic id generation, If this is True the system will throw an exception if the id property is missing from the Document.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.Document"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="document"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the document supplied. It is likely that <paramref name="disableAutomaticIdGeneration"/> was true and an id was not supplied</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This likely means the collection in to which you were trying to create the document is full.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Document"/> with an id matching the id field of <paramref name="document"/> already existed</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the <see cref="T:Microsoft.Azure.Documents.Document"/> exceeds the current max entity size. Consult documentation for limits and quotas.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             Azure Cosmos DB supports a number of different ways to work with documents. A document can extend <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyObject : Resource
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyObject { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             A document can be any POCO object that can be serialized to JSON, even if it doesn't extend from <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyPOCO
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyPOCO { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             Finally, a Document can also be a dynamic object
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync("dbs/db_rid/colls/coll_rid/", new { SomeProperty = "A Value" } );
             }
             ]]>
             </code>
             </example>
             <example>
             Create a Document and execute a Pre and Post Trigger
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.CreateDocumentAsync(
                     "dbs/db_rid/colls/coll_rid/",
                     new { id = "DOC123213443" },
                     new RequestOptions
                     {
                         PreTriggerInclude = new List<string> { "MyPreTrigger" },
                         PostTriggerInclude = new List<string> { "MyPostTrigger" }
                     });
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentAsync(System.Uri,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a document as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to create the document in.</param>
            <param name="document">The document object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <param name="disableAutomaticIdGeneration">A flag to disable automatic id generation.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureAsync(System.String,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a stored procedure as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the collection to create the stored procedure in. E.g. dbs/db_rid/colls/col_rid/</param>
             <param name="storedProcedure">The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> object to create.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="storedProcedure"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the stored procedure or the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of stored procedures for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> you tried to create was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a new stored procedure called "HelloWorldSproc" that takes in a single param called "name".
             StoredProcedure sproc = await client.CreateStoredProcedureAsync(collectionLink, new StoredProcedure
             {
                Id = "HelloWorldSproc",
                Body = @"function (name){
                            var response = getContext().getResponse();
                            response.setBody('Hello ' + name);
                         }"
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a stored procedure as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to create the stored procedure in.</param>
            <param name="storedProcedure">The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerAsync(System.String,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a trigger as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to create the trigger in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="trigger">The <see cref="T:Microsoft.Azure.Documents.Trigger"/> object to create.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="trigger"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new trigger or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of triggers for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Trigger"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.Trigger"/> you tried to create was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a trigger that validates the contents of a document as it is created and adds a 'timestamp' property if one was not found.
             Trigger trig = await client.CreateTriggerAsync(collectionLink, new Trigger
             {
                 Id = "ValidateDocuments",
                 Body = @"function validate() {
                                     var context = getContext();
                                     var request = context.getRequest();                                                             
                                     var documentToCreate = request.getBody();
                                     
                                     // validate properties
                                     if (!('timestamp' in documentToCreate)) {
                                         var ts = new Date();
                                         documentToCreate['timestamp'] = ts.getTime();
                                     }
                                     
                                     // update the document that will be created
                                     request.setBody(documentToCreate);
                                   }",
                 TriggerType = TriggerType.Pre,
                 TriggerOperation = TriggerOperation.Create
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerAsync(System.Uri,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a trigger as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to create the trigger in.</param>
            <param name="trigger">The <see cref="T:Microsoft.Azure.Documents.Trigger"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Creates a user defined function as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to create the user defined function in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="function">The <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> object to create.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="function"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new user defined function or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of user defined functions for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> you tried to create was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Create a user defined function that converts a string to upper case
             UserDefinedFunction udf = client.CreateUserDefinedFunctionAsync(collectionLink, new UserDefinedFunction
             {
                Id = "ToUpper",
                Body = @"function toUpper(input) {
                                    return input.toUpperCase();
                                 }",
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Creates a user defined function as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to create the user defined function in.</param>
            <param name="function">The <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteDatabaseAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.Database"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="databaseLink">The link of the <see cref="T:Microsoft.Azure.Cosmos.Database"/> to delete. E.g. dbs/db_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="databaseLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a database using its selfLink property
            //To get the databaseLink you would have to query for the Database, using CreateDatabaseQuery(),  and then refer to its .SelfLink property
            await client.DeleteDatabaseAsync(databaseLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteDatabaseAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a database as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">The URI of the database to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentCollectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.Document"/> to delete. E.g. dbs/db_rid/colls/col_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentCollectionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a collection using its selfLink property
            //To get the collectionLink you would have to query for the Collection, using CreateDocumentCollectionQuery(),  and then refer to its .SelfLink property
            await client.DeleteDocumentCollectionAsync(collectionLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteDocumentAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Document"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentLink">The link of the <see cref="T:Microsoft.Azure.Documents.Document"/> to delete. E.g. dbs/db_rid/colls/col_rid/docs/doc_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a document using its selfLink property
            //To get the documentLink you would have to query for the Document, using CreateDocumentQuery(),  and then refer to its .SelfLink property
            await client.DeleteDocumentAsync(documentLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteDocumentAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a document as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentUri">The URI of the document to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteStoredProcedureAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="storedProcedureLink">The link of the <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> to delete. E.g. dbs/db_rid/colls/col_rid/sprocs/sproc_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a stored procedure using its selfLink property.
            //To get the sprocLink you would have to query for the Stored Procedure, using CreateStoredProcedureQuery(),  and then refer to its .SelfLink property
            await client.DeleteStoredProcedureAsync(sprocLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a stored procedure as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="storedProcedureUri">The URI of the stored procedure to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteTriggerAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Trigger"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="triggerLink">The link of the <see cref="T:Microsoft.Azure.Documents.Trigger"/> to delete. E.g. dbs/db_rid/colls/col_rid/triggers/trigger_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="triggerLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a trigger using its selfLink property.
            //To get the triggerLink you would have to query for the Trigger, using CreateTriggerQuery(),  and then refer to its .SelfLink property
            await client.DeleteTriggerAsync(triggerLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteTriggerAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a trigger as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="triggerUri">The URI of the trigger to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="functionLink">The link of the <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> to delete. E.g. dbs/db_rid/colls/col_rid/udfs/udf_rid/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="functionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a user defined function using its selfLink property.
            //To get the functionLink you would have to query for the User Defined Function, using CreateUserDefinedFunctionQuery(),  and then refer to its .SelfLink property
            await client.DeleteUserDefinedFunctionAsync(functionLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a user defined function as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="functionUri">The URI of the user defined function to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteConflictAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Documents.Conflict"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="conflictLink">The link of the <see cref="T:Microsoft.Azure.Documents.Conflict"/> to delete. E.g. dbs/db_rid/colls/coll_rid/conflicts/ </param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain information about the request issued.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="conflictLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Delete a conflict using its selfLink property.
            //To get the conflictLink you would have to query for the Conflict object, using CreateConflictQuery(), and then refer to its .SelfLink property
            await client.DeleteConflictAsync(conflictLink);
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.DeleteConflictAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Delete a conflict as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="conflictUri">The URI of the conflict to delete.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceDocumentCollectionAsync(Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a document collection in the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentCollection">the updated document collection.</param>
            <param name="options">the request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the updated resource record.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.DocumentCollection,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a document collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to be updated.</param>
            <param name="documentCollection">The updated document collection.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceDocumentAsync(System.String,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Document"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="documentLink">The link of the document to be updated. E.g. dbs/db_rid/colls/col_rid/docs/doc_rid/ </param>
             <param name="document">The updated <see cref="T:Microsoft.Azure.Documents.Document"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="documentLink"/> or <paramref name="document"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             In this example, instead of using a strongly typed <see cref="T:Microsoft.Azure.Documents.Document"/>, we will work with our own POCO object and not rely on the dynamic nature of the Document class.
             <code language="c#">
             <![CDATA[
             public class MyPoco
             {
                 public string Id {get; set;}
                 public string MyProperty {get; set;}
             }
            
             //Get the doc back as a Document so you have access to doc.SelfLink
             Document doc = client.CreateDocumentQuery<Document>(collectionLink)
                                    .Where(r => r.Id == "doc id")
                                    .AsEnumerable()
                                    .SingleOrDefault();
            
             //Now dynamically cast doc back to your MyPoco
             MyPoco poco = (dynamic)doc;
            
             //Update some properties of the poco object
             poco.MyProperty = "updated value";
            
             //Now persist these changes to the database using doc.SelLink and the update poco object
             Document updated = await client.ReplaceDocumentAsync(doc.SelfLink, poco);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceDocumentAsync(System.Uri,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replaces a document as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentUri">The URI of the document to be updated.</param>
            <param name="document">The updated document.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceDocumentAsync(Microsoft.Azure.Documents.Document,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Document"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="document">The updated <see cref="T:Microsoft.Azure.Documents.Document"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="document"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             This example uses <see cref="T:Microsoft.Azure.Documents.Document"/> and takes advantage of the fact that it is a dynamic object and uses SetProperty to dynamically update properties on the document
             <code language="c#">
             <![CDATA[
             //Fetch the Document to be updated
             Document doc = client.CreateDocumentQuery<Document>(collectionLink)
                                         .Where(r => r.Id == "doc id")
                                         .AsEnumerable()
                                         .SingleOrDefault();
            
             //Update some properties on the found resource
             doc.SetPropertyValue("MyProperty", "updated value");
            
             //Now persist these changes to the database by replacing the original resource
             Document updated = await client.ReplaceDocumentAsync(doc);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceStoredProcedureAsync(Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="storedProcedure">The updated <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedure"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             StoredProcedure sproc = client.CreateStoredProcedureQuery(sprocsLink)
                                              .Where(r => r.Id == "sproc id")
                                              .AsEnumerable()
                                              .SingleOrDefault();
            
             //Update some properties on the found resource
             sproc.Body = "function () {new javascript body for sproc}";
            
             //Now persist these changes to the database by replacing the original resource
             StoredProcedure updated = await client.ReplaceStoredProcedureAsync(sproc);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replace the specified stored procedure in the Azure Cosmos DB service.
            </summary>
            <param name="storedProcedureUri">The URI for the stored procedure to be updated.</param>
            <param name="storedProcedure">The updated stored procedure.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceTriggerAsync(Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Trigger"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="trigger">The updated <see cref="T:Microsoft.Azure.Documents.Trigger"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="trigger"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             Trigger trigger = client.CreateTriggerQuery(sprocsLink)
                                           .Where(r => r.Id == "trigger id")
                                           .AsEnumerable()
                                           .SingleOrDefault();
            
             //Update some properties on the found resource
             trigger.Body = "function () {new javascript body for trigger}";
            
             //Now persist these changes to the database by replacing the original resource
             Trigger updated = await client.ReplaceTriggerAsync(sproc);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceTriggerAsync(System.Uri,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a trigger as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="triggerUri">The URI for the trigger to be updated.</param>
            <param name="trigger">The updated trigger.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceUserDefinedFunctionAsync(Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="function">The updated <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> to replace the existing resource with.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="function"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(functionsLink)
                                                 .Where(r => r.Id == "udf id")
                                                 .AsEnumerable()
                                                 .SingleOrDefault();
            
             //Update some properties on the found resource
             udf.Body = "function () {new javascript body for udf}";
            
             //Now persist these changes to the database by replacing the original resource
             UserDefinedFunction updated = await client.ReplaceUserDefinedFunctionAsync(udf);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Replaces a user defined function as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="userDefinedFunctionUri">The URI for the user defined function to be updated.</param>
            <param name="function">The updated user defined function.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReplaceOfferAsync(Microsoft.Azure.Documents.Offer)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Documents.Offer"/> in the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="offer">The updated <see cref="T:Microsoft.Azure.Documents.Offer"/> to replace the existing resource with.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Offer"/> containing the updated resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="offer"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource you tried to delete did not exist.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             //Fetch the resource to be updated
             Offer offer = client.CreateOfferQuery()
                                      .Where(r => r.ResourceLink == "collection selfLink")
                                      .AsEnumerable()
                                      .SingleOrDefault();
            
             //Change the user mode to All
             offer.OfferType = "S3";
            
             //Now persist these changes to the database by replacing the original resource
             Offer updated = await client.ReplaceOfferAsync(offer);
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDatabaseAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.Database"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="databaseLink">The link of the Database resource to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Database"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="databaseLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Database resource where
            // - database_id is the ID property of the Database resource you wish to read.
            var dbLink = "/dbs/database_id";
            Database database = await client.ReadDatabaseAsync(dbLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Database if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="databaseLink"/> is always "/dbs/{db identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDatabaseAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.Database"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">A URI to the Database resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Database"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="databaseUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Database resource where 
            // - db_id is the ID property of the Database you wish to read. 
            var dbLink = UriFactory.CreateDatabaseUri("db_id");
            Database database = await client.ReadDatabaseAsync(dbLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentCollectionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentCollectionLink">The link for the DocumentCollection to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentCollectionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a DocumentCollection record from a database where
            // - sample_database is the ID of the database
            // - collection_id is the ID of the collection resource to be read
            var collLink = "/dbs/sample_database/colls/collection_id";
            DocumentCollection coll = await client.ReadDocumentCollectionAsync(collLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the DocumentCollection if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentCollectionLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentCollectionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">A URI to the DocumentCollection resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentCollectionUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection you wish to read. 
            var collLink = UriFactory.CreateCollectionUri("db_id", "coll_id");
            DocumentCollection coll = await client.ReadDocumentCollectionAsync(collLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentLink">The link for the document to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a document record from a database & collection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - document_id is the ID of the document resource
            var docLink = "dbs/sample_database/colls/sample_collection/docs/document_id";
            Document doc = await client.ReadDocumentAsync(docLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Document if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentLink"/> is always "dbs/{db identifier}/colls/{coll identifier}/docs/{doc identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="documentUri">A URI to the Document resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - doc_id is the ID property of the Document you wish to read. 
            var docUri = UriFactory.CreateDocumentUri("db_id", "coll_id", "doc_id");
            Document document = await client.ReadDocumentAsync(docUri);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentAsync``1(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> as a generic type T from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentLink">The link for the document to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //This reads a document record from a database & collection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - document_id is the ID of the document resource
            var docLink = "dbs/sample_database/colls/sample_collection/docs/document_id";
            Customer customer = await client.ReadDocumentAsync<Customer>(docLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Document if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="documentLink"/> is always "dbs/{db identifier}/colls/{coll identifier}/docs/{doc identifier}" only
            the values within the {} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentAsync``1(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Document"/> as a generic type T from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="documentUri">A URI to the Document resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Document"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="documentUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when reading a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Document resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - doc_id is the ID property of the Document you wish to read. 
            var docUri = UriFactory.CreateDocumentUri("db_id", "coll_id", "doc_id");
            Customer customer = await client.ReadDocumentAsync<Customer>(docUri);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.DocumentResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadStoredProcedureAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="storedProcedureLink">The link of the stored procedure to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a StoredProcedure from a Database and DocumentCollection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - sproc_id is the ID of the stored procedure to be read
            var sprocLink = "/dbs/sample_database/colls/sample_collection/sprocs/sproc_id";
            StoredProcedure sproc = await client.ReadStoredProcedureAsync(sprocLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Stored Procedure if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="storedProcedureLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/sprocs/{sproc identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="storedProcedureUri">A URI to the StoredProcedure resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a StoredProcedure resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection 
            // - sproc_id is the ID property of the StoredProcedure you wish to read. 
            var sprocLink = UriFactory.CreateStoredProcedureUri("db_id", "coll_id", "sproc_id");
            StoredProcedure sproc = await client.ReadStoredProcedureAsync(sprocLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadTriggerAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Trigger"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="triggerLink">The link to the Trigger to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="triggerLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Trigger from a Database and DocumentCollection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - trigger_id is the ID of the trigger to be read
            var triggerLink = "/dbs/sample_database/colls/sample_collection/triggers/trigger_id";
            Trigger trigger = await client.ReadTriggerAsync(triggerLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Trigger if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="triggerLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/triggers/{trigger identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadTriggerAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Trigger"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="triggerUri">A URI to the Trigger resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="triggerUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Trigger resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection 
            // - trigger_id is the ID property of the Trigger you wish to read. 
            var triggerLink = UriFactory.CreateTriggerUri("db_id", "coll_id", "trigger_id");
            Trigger trigger = await client.ReadTriggerAsync(triggerLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="functionLink">The link to the User Defined Function to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="functionLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a User Defined Function from a Database and DocumentCollection where
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - udf_id is the ID of the user-defined function to be read
            var udfLink = "/dbs/sample_database/colls/sample_collection/udfs/udf_id";
            UserDefinedFunction udf = await client.ReadUserDefinedFunctionAsync(udfLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the User Defined Function if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="functionLink"/> is always "/dbs/{db identifier}/colls/{coll identifier}/udfs/{udf identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="functionUri">A URI to the User Defined Function resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="functionUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a UserDefinedFunction resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection 
            // - udf_id is the ID property of the UserDefinedFunction you wish to read. 
            var udfLink = UriFactory.CreateUserDefinedFunctionUri("db_id", "coll_id", "udf_id");
            UserDefinedFunction udf = await client.ReadUserDefinedFunctionAsync(udfLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadConflictAsync(System.String,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Conflict"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="conflictLink">The link to the Conflict to be read.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Conflict"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="conflictLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Conflict resource from a Database
            // - sample_database is the ID of the database
            // - sample_collection is the ID of the collection
            // - conflict_id is the ID of the conflict to be read
            var conflictLink = "/dbs/sample_database/colls/sample_collection/conflicts/conflict_id";
            Conflict conflict = await client.ReadConflictAsync(conflictLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            The example shown uses ID-based links, where the link is composed of the ID properties used when the resources were created.
            You can still use the <see cref="P:Microsoft.Azure.Documents.Resource.SelfLink"/> property of the Conflict if you prefer. A self-link is a URI for a resource that is made up of Resource Identifiers  (or the _rid properties).
            ID-based links and SelfLink will both work.
            The format for <paramref name="conflictLink"/> is always "/dbs/{db identifier}/colls/{collectioon identifier}/conflicts/{conflict identifier}"
            only the values within the {...} change depending on which method you wish to use to address the resource.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadConflictAsync(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Documents.Conflict"/> as an asynchronous operation from the Azure Cosmos DB service.
            </summary>
            <param name="conflictUri">A URI to the Conflict resource to be read.</param>
            <param name="options">The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Conflict"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="conflictUri"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads a Conflict resource where 
            // - db_id is the ID property of the Database
            // - coll_id is the ID property of the DocumentCollection
            // - conflict_id is the ID property of the Conflict you wish to read. 
            var conflictLink = UriFactory.CreateConflictUri("db_id", "coll_id", "conflict_id");
            Conflict conflict = await client.ReadConflictAsync(conflictLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the service. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/> 
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadOfferAsync(System.String)">
            <summary>
            Reads an <see cref="T:Microsoft.Azure.Documents.Offer"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="offerLink">The link to the Offer to be read.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Offer"/> containing the read resource record.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="offerLink"/> is not set.</exception>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term><description>NotFound - This means the resource you tried to read did not exist.</description>
                </item>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            //Reads an Offer resource from a Database
            // - offer_id is the ID of the conflict to be read
            var offerLink = "/offers/offer_id";
            Offer offer = await client.ReadOfferAsync(offerLink);
            ]]>
            </code>
            </example>
            <remarks>
            <para>
            Doing a read of a resource is the most efficient way to get a resource from the Database. If you know the resource's ID, do a read instead of a query by ID.
            </para>
            <para>
            For an Offer, id is always generated internally by the system when the linked resource is created. id and _rid are always the same for Offer.
            </para>
            <para>
            The format for <paramref name="offerLink"/> is always "/offers/{offer identifier}"
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
            <seealso cref="T:System.Uri"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDatabaseFeedAsync(Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Cosmos.Database"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Database"/> containing the read resource record.
             </returns>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Database> response = await client.ReadDatabaseFeedAsync(new FeedOptions
                                                                             {
                                                                                 MaxItemCount = 10,
                                                                                 RequestContinuation = continuation
                                                                             });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadPartitionKeyRangeFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="partitionKeyRangesOrCollectionLink">The link of the resources to be read, or owner collection link, SelfLink or AltLink. E.g. /dbs/db_rid/colls/coll_rid/pkranges</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Database"/> containing the read resource record.
            </returns>
            <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term><description>Reason for exception</description>
                </listheader>
                <item>
                    <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                </item>
            </list>
            </exception>
            <example>
            <code language="c#">
            <![CDATA[
            DoucmentFeedResponse<PartitionKeyRange> response = null;
            List<string> ids = new List<string>();
            do
            {
                response = await client.ReadPartitionKeyRangeFeedAsync(collection.SelfLink, new FeedOptions { MaxItemCount = 1000 });
                foreach (var item in response)
                {
                    ids.Add(item.Id);
                }
            }
            while (!string.IsNullOrEmpty(response.ResponseContinuation));
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.FeedOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentFeedResponse`1"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadPartitionKeyRangeFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> for a database account from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="partitionKeyRangesOrCollectionUri">The Uri for partition key ranges, or owner collection.</param>
            <param name="options">(Optional) The request options for the request.</param>
            <returns>
            A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> containing the read resource record.
            </returns>
            <example>
            <code language="c#">
            <![CDATA[
            Uri partitionKeyRangesUri = UriFactory.CreatePartitionKeyRangesUri(database.Id, collection.Id);
            DoucmentFeedResponse<PartitionKeyRange> response = null;
            List<string> ids = new List<string>();
            do
            {
                response = await client.ReadPartitionKeyRangeFeedAsync(partitionKeyRangesUri, new FeedOptions { MaxItemCount = 1000 });
                foreach (var item in response)
                {
                    ids.Add(item.Id);
                }
            }
            while (!string.IsNullOrEmpty(response.ResponseContinuation));
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.FeedOptions"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentFeedResponse`1"/>
            <seealso cref="M:Microsoft.Azure.Cosmos.UriFactory.CreatePartitionKeyRangesUri(System.String,System.String)"/>
            <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentCollectionFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> for a database from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="collectionsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="collectionsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<DocumentCollection> response = await client.ReadDocumentCollectionFeedAsync("/dbs/db_rid/colls/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentCollectionFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of collections for a database as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">The URI of the parent Database.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Threading.CancellationToken)">
             <summary>
             Reads the feed (sequence) of documents for a specified collection from the Azure Cosmos DB service.
             This takes returns a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which will contain an enumerable list of dynamic objects.
             </summary>
             <param name="documentsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/coll_rid/docs/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> containing dynamic objects representing the items in the feed.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="documentsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<dynamic> response = await client.ReadDocumentFeedAsync("/dbs/db_rid/colls/coll_rid/docs/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <remarks>
             Instead of DoucmentFeedResponse{Document} this method takes advantage of dynamic objects in .NET. This way a single feed result can contain any kind of Document, or POCO object.
             This is important becuse a DocumentCollection can contain different kinds of documents.
             </remarks>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadDocumentFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions,System.Threading.CancellationToken)">
            <summary>
            Reads the feed (sequence) of documents for a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadStoredProcedureFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="storedProceduresLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/col_rid/sprocs/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProceduresLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<StoredProcedure> response = await client.ReadStoredProcedureFeedAsync("/dbs/db_rid/colls/col_rid/sprocs/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadStoredProcedureFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of stored procedures for a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadTriggerFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Trigger"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="triggersLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/col_rid/triggers/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Trigger"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="triggersLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Trigger> response = await client.ReadTriggerFeedAsync("/dbs/db_rid/colls/col_rid/triggers/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadTriggerFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of triggers for a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadUserDefinedFunctionFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="userDefinedFunctionsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/col_rid/udfs/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="userDefinedFunctionsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<UserDefinedFunction> response = await client.ReadUserDefinedFunctionFeedAsync("/dbs/db_rid/colls/col_rid/udfs/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadUserDefinedFunctionFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of user defined functions for a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadConflictFeedAsync(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Conflict"/> for a collection from the Azure Cosmos DB service as an asynchronous operation.
             </summary>
             <param name="conflictsLink">The SelfLink of the resources to be read. E.g. /dbs/db_rid/colls/coll_rid/conflicts/ </param>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Conflict"/> containing the read resource record.
             </returns>
             <exception cref="T:System.ArgumentNullException">If <paramref name="conflictsLink"/> is not set.</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>404</term><description>NotFound - This means the resource feed you tried to read did not exist. Check the parent rids are correct.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Conflict> response = await client.ReadConflictAsync("/dbs/db_rid/colls/coll_rid/conflicts/",
                                                                 new FeedOptions
                                                                 {
                                                                     MaxItemCount = 10,
                                                                     RequestContinuation = continuation
                                                                 });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadConflictFeedAsync(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Reads the feed (sequence) of conflicts for a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ReadOffersFeedAsync(Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Reads the feed (sequence) of <see cref="T:Microsoft.Azure.Documents.Offer"/> for a database account from the Azure Cosmos DB service
             as an asynchronous operation.
             </summary>
             <param name="options">(Optional) The request options for the request.</param>
             <returns>
             A <see cref="N:System.Threading.Tasks"/> containing a <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> which wraps a <see cref="T:Microsoft.Azure.Documents.Offer"/> containing the read resource record.
             </returns>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             <code language="c#">
             <![CDATA[
             int count = 0;
             string continuation = string.Empty;
             do
             {
                 // Read the feed 10 items at a time until there are no more items to read
                 DoucmentFeedResponse<Offer> response = await client.ReadOfferAsync(new FeedOptions
                                                                             {
                                                                                 MaxItemCount = 10,
                                                                                 RequestContinuation = continuation
                                                                             });
            
                 // Append the item count
                 count += response.Count;
            
                 // Get the continuation so that we know when to stop.
                  continuation = response.ResponseContinuation;
             } while (!string.IsNullOrEmpty(continuation));
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ExecuteStoredProcedureAsync``1(System.String,System.Object[])">
             <summary>
             Executes a stored procedure against a collection as an asynchronous operation in the Azure Cosmos DB service.
             </summary>
             <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
             <param name="storedProcedureLink">The link to the stored procedure to execute.</param>
             <param name="procedureParams">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <example>
             <code language="c#">
             <![CDATA[
             //Execute a StoredProcedure with ResourceId of "sproc_rid" that takes two "Player" documents, does some stuff, and returns a bool
             StoredProcedureResponse<bool> sprocResponse = await client.ExecuteStoredProcedureAsync<bool>(
                                                                     "/dbs/db_rid/colls/col_rid/sprocs/sproc_rid/",
                                                                     new Player { id="1", name="joe" } ,
                                                                     new Player { id="2", name="john" }
                                                                 );
            
             if (sprocResponse.Response) Console.WriteLine("Congrats, the stored procedure did some stuff");
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ExecuteStoredProcedureAsync``1(System.Uri,System.Object[])">
            <summary>
            Executes a stored procedure against a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
            <param name="storedProcedureUri">The URI of the stored procedure to be executed.</param>
            <param name="procedureParams">The parameters for the stored procedure execution.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ExecuteStoredProcedureAsync``1(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Object[])">
             <summary>
             Executes a stored procedure against a partitioned collection in the Azure Cosmos DB service as an asynchronous operation, specifiying a target partition.
             </summary>
             <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
             <param name="storedProcedureLink">The link to the stored procedure to execute.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="procedureParams">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <example>
             <code language="c#">
             <![CDATA[
             //Execute a StoredProcedure with ResourceId of "sproc_rid" that takes two "Player" documents, does some stuff, and returns a bool
             StoredProcedureResponse<bool> sprocResponse = await client.ExecuteStoredProcedureAsync<bool>(
                                                                     "/dbs/db_rid/colls/col_rid/sprocs/sproc_rid/",
                                                                     new RequestOptions { PartitionKey = new PartitionKey(1) },
                                                                     new Player { id="1", name="joe" } ,
                                                                     new Player { id="2", name="john" }
                                                                 );
            
             if (sprocResponse.Response) Console.WriteLine("Congrats, the stored procedure did some stuff");
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ExecuteStoredProcedureAsync``1(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Object[])">
            <summary>
            Executes a stored procedure against a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
            <param name="storedProcedureUri">The URI of the stored procedure to be executed.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <param name="procedureParams">The parameters for the stored procedure execution.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ExecuteStoredProcedureAsync``1(System.String,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken,System.Object[])">
             <summary>
             Executes a stored procedure against a partitioned collection in the Azure Cosmos DB service as an asynchronous operation, specifiying a target partition.
             </summary>
             <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
             <param name="storedProcedureLink">The link to the stored procedure to execute.</param>
             <param name="options">(Optional) The request options for the request.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <param name="procedureParams">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <exception cref="T:System.ArgumentNullException">If <paramref name="storedProcedureLink"/> is not set.</exception>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <example>
             <code language="c#">
             <![CDATA[
             //Execute a StoredProcedure with ResourceId of "sproc_rid" that takes two "Player" documents, does some stuff, and returns a bool
             StoredProcedureResponse<bool> sprocResponse = await client.ExecuteStoredProcedureAsync<bool>(
                                                                     "/dbs/db_rid/colls/col_rid/sprocs/sproc_rid/",
                                                                     new RequestOptions { PartitionKey = new PartitionKey(1) },
                                                                     new Player { id="1", name="joe" } ,
                                                                     new Player { id="2", name="john" }
                                                                 );
            
             if (sprocResponse.Response) Console.WriteLine("Congrats, the stored procedure did some stuff");
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.ExecuteStoredProcedureAsync``1(System.Uri,Microsoft.Azure.Documents.Client.RequestOptions,System.Threading.CancellationToken,System.Object[])">
            <summary>
            Executes a stored procedure against a collection as an asynchronous operation in the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">The type of the stored procedure's return value.</typeparam>
            <param name="storedProcedureUri">The URI of the stored procedure to be executed.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <param name="procedureParams">The parameters for the stored procedure execution.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertDocumentAsync(System.String,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
             <summary>
             Upserts a Document as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to upsert the document in. E.g. dbs/db_rid/colls/coll_rid/ </param>
             <param name="document">The document object to upsert.</param>
             <param name="options">(Optional) Any request options you wish to set. E.g. Specifying a Trigger to execute when creating the document. <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/></param>
             <param name="disableAutomaticIdGeneration">(Optional) Disables the automatic id generation, If this is True the system will throw an exception if the id property is missing from the Document.</param>
             <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.Document"/> that was upserted contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="document"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the document supplied. It is likely that <paramref name="disableAutomaticIdGeneration"/> was true and an id was not supplied</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - This likely means the collection in to which you were trying to upsert the document is full.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Document"/> with an id matching the id field of <paramref name="document"/> already existed</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the <see cref="T:Microsoft.Azure.Documents.Document"/> exceeds the current max entity size. Consult documentation for limits and quotas.</description>
                 </item>
                 <item>
                     <term>429</term><description>TooManyRequests - This means you have exceeded the number of request units per second. Consult the DocumentClientException.RetryAfter value to see how long you should wait before retrying this operation.</description>
                 </item>
             </list>
             </exception>
             <example>
             Azure Cosmos DB supports a number of different ways to work with documents. A document can extend <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyObject : Resource
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyObject { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             A document can be any POCO object that can be serialized to JSON, even if it doesn't extend from <see cref="N:Microsoft.Azure.Cosmos.Resource"/>
             <code language="c#">
             <![CDATA[
             public class MyPOCO
             {
                 public string MyProperty {get; set;}
             }
            
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync("dbs/db_rid/colls/coll_rid/", new MyPOCO { MyProperty = "A Value" });
             }
             ]]>
             </code>
             </example>
             <example>
             A Document can also be a dynamic object
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync("dbs/db_rid/colls/coll_rid/", new { SomeProperty = "A Value" } );
             }
             ]]>
             </code>
             </example>
             <example>
             Upsert a Document and execute a Pre and Post Trigger
             <code language="c#">
             <![CDATA[
             using (IDocumentClient client = new DocumentClient(new Uri("service endpoint"), "auth key"))
             {
                 Document doc = await client.UpsertDocumentAsync(
                     "dbs/db_rid/colls/coll_rid/",
                     new { id = "DOC123213443" },
                     new RequestOptions
                     {
                         PreTriggerInclude = new List<string> { "MyPreTrigger" },
                         PostTriggerInclude = new List<string> { "MyPostTrigger" }
                     });
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertDocumentAsync(System.Uri,System.Object,Microsoft.Azure.Documents.Client.RequestOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Upserts a document as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to upsert the document in.</param>
            <param name="document">The document object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <param name="disableAutomaticIdGeneration">A flag to disable the automatic id generation.</param>
            <param name="cancellationToken">(Optional) A <see cref="T:System.Threading.CancellationToken"/> that can be used by other objects or threads to receive notice of cancellation.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertStoredProcedureAsync(System.String,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a stored procedure as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the collection to upsert the stored procedure in. E.g. dbs/db_rid/colls/col_rid/</param>
             <param name="storedProcedure">The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> object to upsert.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> that was upserted contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="storedProcedure"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the stored procedure or the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of stored procedures for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> you tried to upsert was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a new stored procedure called "HelloWorldSproc" that takes in a single param called "name".
             StoredProcedure sproc = await client.UpsertStoredProcedureAsync(collectionLink, new StoredProcedure
             {
                Id = "HelloWorldSproc",
                Body = @"function (name){
                            var response = getContext().getResponse();
                            response.setBody('Hello ' + name);
                         }"
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertStoredProcedureAsync(System.Uri,Microsoft.Azure.Documents.StoredProcedure,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a stored procedure as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to upsert the stored procedure in.</param>
            <param name="storedProcedure">The <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertTriggerAsync(System.String,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a trigger as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to upsert the trigger in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="trigger">The <see cref="T:Microsoft.Azure.Documents.Trigger"/> object to upsert.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="trigger"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new trigger or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of triggers for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.Trigger"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.Trigger"/> you tried to upsert was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a trigger that validates the contents of a document as it is created and adds a 'timestamp' property if one was not found.
             Trigger trig = await client.UpsertTriggerAsync(collectionLink, new Trigger
             {
                 Id = "ValidateDocuments",
                 Body = @"function validate() {
                                     var context = getContext();
                                     var request = context.getRequest();                                                             
                                     var documentToCreate = request.getBody();
                                     
                                     // validate properties
                                     if (!('timestamp' in documentToCreate)) {
                                         var ts = new Date();
                                         documentToCreate['timestamp'] = ts.getTime();
                                     }
                                     
                                     // update the document that will be created
                                     request.setBody(documentToCreate);
                                   }",
                 TriggerType = TriggerType.Pre,
                 TriggerOperation = TriggerOperation.Create
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertTriggerAsync(System.Uri,Microsoft.Azure.Documents.Trigger,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a trigger as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to upsert the trigger in.</param>
            <param name="trigger">The <see cref="T:Microsoft.Azure.Documents.Trigger"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertUserDefinedFunctionAsync(System.String,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
             <summary>
             Upserts a user defined function as an asychronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="collectionLink">The link of the <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> to upsert the user defined function in. E.g. dbs/db_rid/colls/col_rid/ </param>
             <param name="function">The <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> object to upsert.</param>
             <param name="options">(Optional) Any <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>for this request.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception cref="T:System.ArgumentNullException">If either <paramref name="collectionLink"/> or <paramref name="function"/> is not set.</exception>
             <exception cref="T:System.AggregateException">Represents a consolidation of failures that occured during async processing. Look within InnerExceptions to find the actual exception(s)</exception>
             <exception cref="T:Microsoft.Azure.Documents.DocumentClientException">This exception can encapsulate many different types of errors. To determine the specific error always look at the StatusCode property. Some common codes you may get when creating a Document are:
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Reason for exception</description>
                 </listheader>
                 <item>
                     <term>400</term><description>BadRequest - This means something was wrong with the request supplied. It is likely that an Id was not supplied for the new user defined function or that the Body was malformed.</description>
                 </item>
                 <item>
                     <term>403</term><description>Forbidden - You have reached your quota of user defined functions for the collection supplied. Contact support to have this quota increased.</description>
                 </item>
                 <item>
                     <term>409</term><description>Conflict - This means a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> with an id matching the id you supplied already existed.</description>
                 </item>
                 <item>
                     <term>413</term><description>RequestEntityTooLarge - This means the body of the <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> you tried to upsert was too large.</description>
                 </item>
             </list>
             </exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             //Upsert a user defined function that converts a string to upper case
             UserDefinedFunction udf = client.UpsertUserDefinedFunctionAsync(collectionLink, new UserDefinedFunction
             {
                Id = "ToUpper",
                Body = @"function toUpper(input) {
                                    return input.toUpperCase();
                                 }",
             });
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>
             <seealso cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/>
             <seealso cref="T:System.Threading.Tasks.Task"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.UpsertUserDefinedFunctionAsync(System.Uri,Microsoft.Azure.Documents.UserDefinedFunction,Microsoft.Azure.Documents.Client.RequestOptions)">
            <summary>
            Upserts a user defined function as an asychronous operation in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection to upsert the user defined function in.</param>
            <param name="function">The <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> object.</param>
            <param name="options">(Optional) The <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/> for the request.</param>
            <returns>The task object representing the service response for the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for document collections in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">The URI of the parent database.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for document collections in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">The URI to the database.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for document collections in the Azure Cosmos DB service.
            </summary>
            <param name="databaseUri">The URI to the database.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create query for stored procedures in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create query for stored procedures in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create query for stored procedures in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create query for triggers in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create query for triggers in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create query for triggers in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for user-defined functions in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for user-defined functions in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for user-defined functions in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateConflictQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for conflicts in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateConflictQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for conflicts in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateConflictQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for conflicts in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery``1(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentCollectionUri">The URI of the parent document collection.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery``1(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentCollectionUri">The URI of the document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery``1(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="documentCollectionUri">The URI of the document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery(System.Uri,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery(System.Uri,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection.</param>
            <param name="sqlExpression">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery(System.Uri,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Method to create a query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="documentCollectionUri">The URI of the document collection.</param>
            <param name="querySpec">The sql query.</param>
            <param name="feedOptions">(Optional) The <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> for processing the query results feed.</param>
            <returns>The query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentChangeFeedQuery(System.Uri,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Extension method to create a change feed query for documents in the Azure Cosmos DB service.
            </summary>
            <param name="collectionLink">Specifies the collection to read documents from.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>the query result set.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDatabaseQuery(Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for database resources under an account in the Azure Cosmos DB service. It returns An IOrderedQueryable{Database}.
            </summary>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Database} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for databases by id.
            <code language="c#">
            <![CDATA[
            Database database = client.CreateDatabaseQuery().Where(d => d.Id == "mydb").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDatabaseQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for database resources under an Azure Cosmos DB database account by using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for databases by id.
            <code language="c#">
            <![CDATA[
            Database database = client.CreateDatabaseQuery("SELECT * FROM dbs d WHERE d.id = 'mydb'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Database"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDatabaseQuery(Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for database resources under an Azure Cosmos DB database account by using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for databases by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM dbs d WHERE d.id = @id",
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "mydb" }}));
            dynamic database = client.CreateDatabaseQuery<dynamic>(query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.Database"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for collections under an Azure Cosmos DB database. It returns An IOrderedQueryable{DocumentCollection}.
            </summary>
            <param name="databaseLink">The link to the parent database resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{DocumentCollection} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for collections by id.
            <code language="c#">
            <![CDATA[
            DocumentCollection collection = client.CreateDocumentCollectionQuery(databaseLink).Where(c => c.Id == "myColl").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for collections under an Azure Cosmos DB database using a SQL statement.   It returns an IQueryable{DocumentCollection}.
            </summary>
            <param name="databaseLink">The link to the parent database resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for collections by id.
            <code language="c#">
            <![CDATA[
            DocumentCollection collection = client.CreateDocumentCollectionQuery(databaseLink, "SELECT * FROM colls c WHERE c.id = 'mycoll'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentCollectionQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for collections under an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="databaseLink">The link to the parent database resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for collections by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM colls c WHERE c.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "mycoll" }}));
            DocumentCollection collection = client.CreateDocumentCollectionQuery(databaseLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.DocumentCollection"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for stored procedures under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{StoredProcedure}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{StoredProcedure} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for stored procedures by id.
            <code language="c#">
            <![CDATA[
            StoredProcedure storedProcedure = client.CreateStoredProcedureQuery(collectionLink).Where(c => c.Id == "helloWorld").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for stored procedures under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for stored procedures by id.
            <code language="c#">
            <![CDATA[
            StoredProcedure storedProcedure = client.CreateStoredProcedureQuery(collectionLink, "SELECT * FROM sprocs s WHERE s.id = 'HelloWorld'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateStoredProcedureQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for stored procedures under a collection in an Azure Cosmos DB database using a SQL statement using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for stored procedures by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM sprocs s WHERE s.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "HelloWorld" }}));
            StoredProcedure storedProcedure = client.CreateStoredProcedureQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.StoredProcedure"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for triggers under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{Trigger}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Trigger} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for triggers by id.
            <code language="c#">
            <![CDATA[
            Trigger trigger = client.CreateTriggerQuery(collectionLink).Where(t => t.Id == "validate").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for triggers under a collection in an Azure Cosmos DB service. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for triggers by id.
            <code language="c#">
            <![CDATA[
            Trigger trigger = client.CreateTriggerQuery(collectionLink, "SELECT * FROM triggers t WHERE t.id = 'validate'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Trigger"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateTriggerQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for triggers under a collection in the Azure Cosmos DB service using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{Trigger} that can evaluate the query with the provided SQL statement.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for udfs under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{UserDefinedFunction}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{UserDefinedFunction} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for user-defined functions by id.
            <code language="c#">
            <![CDATA[
            UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(collectionLink).Where(u => u.Id == "sqrt").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for udfs under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for user-defined functions by id.
            <code language="c#">
            <![CDATA[
            UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(collectionLink, "SELECT * FROM udfs u WHERE u.id = 'sqrt'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateUserDefinedFunctionQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for udfs under a collection in the Azure Cosmos DB service with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for user-defined functions by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM udfs u WHERE u.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "sqrt" }}));
            UserDefinedFunction udf = client.CreateUserDefinedFunctionQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateConflictQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for conflicts under a collection in an Azure Cosmos DB service. It returns An IOrderedQueryable{Conflict}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Conflict} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for conflicts by id.
            <code language="c#">
            <![CDATA[
            Conflict conflict = client.CreateConflictQuery(collectionLink).Where(c => c.Id == "summary").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateConflictQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for conflicts under a collection in an Azure Cosmos DB service. It returns an IQueryable{Conflict}.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the the provided SQL statement.</returns>
            <example>
            This example below queries for conflicts by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM conflicts c WHERE c.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "summary" }}));
            Conflict conflict = client.CreateConflictQuery(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Conflict"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateConflictQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for conflicts under a collection in an Azure Cosmos DB database with parameterized values. It returns an IQueryable{dynamic}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{dynamic} that can evaluate the query with the provided SQL statement.</returns>
            <example>
            This example below queries for conflicts by id.
            <code language="c#">
            <![CDATA[
            var query = new SqlQuerySpec("SELECT * FROM conflicts c WHERE c.id = @id", new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@id", Value = "summary" }}));
            dynamic conflict = client.CreateConflictQuery<dynamic>(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery``1(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent collection resource.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{T} that can evaluate the query.</returns>
            <example>
            This example below queries for some book documents.
            <code language="c#">
            <![CDATA[
            public class Book 
            {
                [JsonProperty("title")]
                public string Title {get; set;}
                
                public Author Author {get; set;}
                
                public int Price {get; set;}
            }
            
            public class Author
            {
                public string FirstName {get; set;}
                public string LastName {get; set;}
            }
             
            // Query by the Title property
            Book book = client.CreateDocumentQuery<Book>(collectionLink).Where(b => b.Title == "War and Peace").AsEnumerable().FirstOrDefault();
            
            // Query a nested property
            Book otherBook = client.CreateDocumentQuery<Book>(collectionLink).Where(b => b.Author.FirstName == "Leo").AsEnumerable().FirstOrDefault();
            
            // Perform a range query (needs an IndexType.Range on price or FeedOptions.EnableScansInQuery)
            foreach (Book matchingBook in client.CreateDocumentQuery<Book>(collectionLink).Where(b => b.Price > 100))
            {
                // Iterate through books
            }
            
            // Query asychronously. Optionally set FeedOptions.MaxItemCount to control page size
            using (var queryable = client.CreateDocumentQuery<Book>(
                collectionLink,
                new FeedOptions { MaxItemCount = 10 })
                .Where(b => b.Title == "War and Peace")
                .AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            The Azure Cosmos DB LINQ provider compiles LINQ to SQL statements. Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started#linq-to-documentdb-sql for the list of expressions supported by the Azure Cosmos DB LINQ provider. ToString() on the generated IQueryable returns the translated SQL statement. The Azure Cosmos DB provider translates JSON.NET and DataContract serialization attributes for members to their JSON property names.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery``1(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{T}.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent collection.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{T} that can evaluate the query.</returns>
            <example>
            This example below queries for some book documents.
            <code language="c#">
            <![CDATA[
            public class Book 
            {
                [JsonProperty("title")]
                public string Title {get; set;}
                
                public Author Author {get; set;}
                
                public int Price {get; set;}
            }
            
            public class Author
            {
                public string FirstName {get; set;}
                public string LastName {get; set;}
            }
            
            // Query by the Title property
            Book book = client.CreateDocumentQuery<Book>(collectionLink, 
                "SELECT * FROM books b WHERE b.title  = 'War and Peace'").AsEnumerable().FirstOrDefault();
            
            // Query a nested property
            Book otherBook = client.CreateDocumentQuery<Book>(collectionLink,
                "SELECT * FROM books b WHERE b.Author.FirstName = 'Leo'").AsEnumerable().FirstOrDefault();
            
            // Perform a range query (needs an IndexType.Range on price or FeedOptions.EnableScansInQuery)
            foreach (Book matchingBook in client.CreateDocumentQuery<Book>(
                collectionLink, "SELECT * FROM books b where b.Price > 1000"))
            {
                // Iterate through books
            }
            
            // Query asychronously. Optionally set FeedOptions.MaxItemCount to control page size
            using (var queryable = client.CreateDocumentQuery<Book>(collectionLink, 
                "SELECT * FROM books b WHERE b.title  = 'War and Peace'", 
                new FeedOptions { MaxItemCount = 10 }).AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery``1(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{T}.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <typeparam name="T">The type of object to query.</typeparam>
            <param name="collectionLink">The link to the parent document collection.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IQueryable{T} that can evaluate the query.</returns>
            <example>
            This example below queries for some book documents.
            <code language="c#">
            <![CDATA[
            public class Book 
            {
                [JsonProperty("title")]
                public string Title {get; set;}
                
                public Author Author {get; set;}
                
                public int Price {get; set;}
            }
            
            public class Author
            {
                public string FirstName {get; set;}
                public string LastName {get; set;}
            }
            
            // Query using Title
            Book book, otherBook;
            
            var query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.title = @title", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@title", Value = "War and Peace" }}));
            book = client.CreateDocumentQuery<Book>(collectionLink, query).AsEnumerable().FirstOrDefault();
            
            // Query a nested property
            query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.Author.FirstName = @firstName", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@firstName", Value = "Leo" }}));
            otherBook = client.CreateDocumentQuery<Book>(collectionLink, query).AsEnumerable().FirstOrDefault();
            
            // Perform a range query (needs an IndexType.Range on price or FeedOptions.EnableScansInQuery)
            query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.Price > @minPrice", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@minPrice", Value = 1000 }}));
            foreach (Book b in client.CreateDocumentQuery<Book>(
                collectionLink, query))
            {
                // Iterate through books
            }
            
            // Query asychronously. Optionally set FeedOptions.MaxItemCount to control page size
            query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.title = @title", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@title", Value = "War and Peace" }}));
                
            using (var queryable = client.CreateDocumentQuery<Book>(collectionLink, query, 
                new FeedOptions { MaxItemCount = 10 }).AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
             <summary>
             Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB service. It returns IOrderedQueryable{Document}.
             </summary>
             <param name="collectionLink">The link to the parent document collection.</param>
             <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
             <returns>An IOrderedQueryable{Document} that can evaluate the query.</returns>
             <example>
             This example below queries for documents by id.
             <code language="c#">
             <![CDATA[
             Document document = client.CreateDocumentQuery<Document>(collectionLink)
                 .Where(d => d.Id == "War and Peace").AsEnumerable().FirstOrDefault();
            
             ]]>
             </code>
             </example>
             <remarks>
             This overload should be used when the schema of the queried documents is unknown or when querying by ID and replacing/deleting documents.
             Since Document is a DynamicObject, it can be dynamically cast back to the original C# object.
             </remarks>
             <seealso cref="T:Microsoft.Azure.Documents.Document"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery(System.String,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement. It returns an IQueryable{dynamic}.
            </summary>
            <param name="collectionLink">The link to the parent document collection.</param>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic> that can evaluate the query.</returns>
            <example>
            This example below queries for book documents.
            <code language="c#">
            <![CDATA[
            // SQL querying allows dynamic property access
            dynamic document = client.CreateDocumentQuery<dynamic>(collectionLink,
                "SELECT * FROM books b WHERE b.title == 'War and Peace'").AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentQuery(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for documents under a collection in an Azure Cosmos DB database using a SQL statement with parameterized values. It returns an IQueryable{dynamic}.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="collectionLink">The link to the parent document collection.</param>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic> that can evaluate the query.</returns>
            <example>
            This example below queries for book documents.
            <code language="c#">
            <![CDATA[
            // SQL querying allows dynamic property access
            var query = new SqlQuerySpec(
                "SELECT * FROM books b WHERE b.title = @title", 
                new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@title", Value = "War and Peace" }}));
                
            dynamic document = client.CreateDocumentQuery<dynamic>(collectionLink, query).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Document"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateDocumentChangeFeedQuery(System.String,Microsoft.Azure.Cosmos.ChangeFeedOptions)">
            <summary>
            Overloaded. This method creates a change feed query for documents under a collection in an Azure Cosmos DB service.
            </summary>
            <param name="collectionLink">Specifies the collection to read documents from.</param>
            <param name="feedOptions">The options for processing the query results feed.</param>
            <returns>the query result set.</returns>
            <remarks>ChangeFeedOptions.PartitionKeyRangeId must be provided.</remarks>
            <example>
            <code language="c#">
            <![CDATA[
            string partitionKeyRangeId = "0";   // Use client.ReadPartitionKeyRangeFeedAsync() to obtain the ranges.
            string checkpointContinuation = null;
            ChangeFeedOptions options = new ChangeFeedOptions
            {
                PartitionKeyRangeId = partitionKeyRangeId,
                RequestContinuation = checkpointContinuation,
                StartFromBeginning = true,
            };
            using(var query = client.CreateDocumentChangeFeedQuery(collection.SelfLink, options))
            {
                while (true)
                {
                    do
                    {
                        var response = await query.ExecuteNextAsync<Document>();
                        if (response.Count > 0)
                        {
                            var docs = new List<Document>();
                            docs.AddRange(response);
                            // Process the documents.
                            // Checkpoint response.ResponseContinuation.
                        }
                    }
                    while (query.HasMoreResults);
                    Task.Delay(TimeSpan.FromMilliseconds(500)); // Or break here and use checkpointed continuation token later.
                }       
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.ChangeFeedOptions"/>
            <seealso cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateOfferQuery(Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for offers under an Azure Cosmos DB database account. It returns IOrderedQueryable{Offer}.
            </summary>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>An IOrderedQueryable{Offer} that can evaluate the query.</returns>
            <example>
            This example below queries for offers
            <code language="c#">
            <![CDATA[
            // Find the first collection with the S3 offer type
            Offer offer = client.CreateOfferQuery().Where(o => o.OfferType == "S3").AsEnumerable().FirstOrDefault();
            
            // Find the offer for the collection by SelfLink
            Offer offer = client.CreateOfferQuery().Where(o => o.Resource == collectionSelfLink).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateOfferQuery(System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for offers under an Azure Cosmos DB database account using a SQL statement. It returns IQueryable{dynamic}.
            </summary>
            <param name="sqlExpression">The SQL statement.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic} that can evaluate the query.</returns>
            <example>
            This example below queries for offers
            <code language="c#">
            <![CDATA[
            // Find the first collection with the S3 offer type
            Offer offer = client.CreateOfferQuery("SELECT * FROM offers o WHERE o.offerType = 'S3'").AsEnumerable().FirstOrDefault();
            
            // Find the offer for the collection by SelfLink
            Offer offer = client.CreateOfferQuery(
                string.Format("SELECT * FROM offers o WHERE o.resource = '{0}'", collectionSelfLink)).AsEnumerable().FirstOrDefault();
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClient.CreateOfferQuery(Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Overloaded. This method creates a query for offers under an Azure Cosmos DB database account using a SQL statement with parameterized values. It returns IQueryable{dynamic}.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/>.
            </summary>
            <param name="querySpec">The SqlQuerySpec instance containing the SQL expression.</param>
            <param name="feedOptions">The options for processing the query result feed. For details, see <see cref="T:Microsoft.Azure.Documents.Client.FeedOptions"/></param>
            <returns>an IQueryable{dynamic} that can evaluate the query.</returns>
            <example>
            This example below queries for offers
            <code language="c#">
            <![CDATA[
            // Find the first collection with the S3 offer type
            Offer offer = client.CreateOfferQuery("SELECT * FROM offers o WHERE o.offerType = @offerType",
            new SqlParameterCollection(new SqlParameter[] { new SqlParameter { Name = "@offerType", Value = "S3" }}))
            .AsEnumerable().FirstOrDefault();
            
            ]]>
            </code>
            </example>
            <remarks>Refer to https://msdn.microsoft.com/en-us/library/azure/dn782250.aspx and https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.</remarks>
            <seealso cref="T:Microsoft.Azure.Documents.Offer"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClientRetryPolicy.OnBeforeSendRequest(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Method that is called before a request is sent to allow the retry policy implementation
            to modify the state of the request.
            </summary>
            <param name="request">The request being sent to the service.</param>
            <remarks>
            Currently only read operations will invoke this method. There is no scenario for write
            operations to modify requests before retrying.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentClientRetryPolicy.ShouldRetryAsync(Microsoft.Azure.Cosmos.ResponseMessage,System.Threading.CancellationToken)">
            <summary>
            Method that is called to determine from the policy that needs to retry on the a particular status code
            </summary>
            <param name="cosmosResponseMessage"><see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> in return of the request</param>
            <param name="cancellationToken"></param>
            <returns>If the retry needs to be attempted or not</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IRetryPolicyFactory.GetRequestPolicy">
            <summary>
            Method that is called to get the retry policy for a non-query request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IMediaHandler.HeadMediaAsync(System.String,Microsoft.Azure.Documents.Collections.INameValueCollection)">
            <returns>
            ResponseHeaders,
            Media Attributes
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IMediaHandler.DownloadMediaAsync(System.String,Microsoft.Azure.Documents.Collections.INameValueCollection,System.TimeSpan)">
            <returns>
            Stream,
            ResponseHeaders,
            Media Attributes
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IMediaResponse">
            <summary>
            Captures the APIs for responses associated with media resource in the Azure Cosmos DB service.
            Interface exposed for mocking purposes.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.ActivityId">
            <summary> 
            Gets the Activity ID for the request associated with the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The Activity ID for the request.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.ContentLength">
            <summary>
            Gets the HTTP ContentLength header value for the response associated with the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The HTTP ContentLength header value.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.ContentType">
            <summary>
            Gets the HTTP ContentType header value for the response associated with the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The HTTP ContentType header value.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.CurrentMediaStorageUsageInMB">
            <summary>
            Gets the current attachment content (media) usage in megabytes for the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The current attachment content (media) usage in megabytes.</value>
            <remarks>This value is retrieved from the gateway. The value is returned from
            cached information updated periodically and is not guaranteed to be real time.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.MaxMediaStorageUsageInMB">
            <summary>
            Gets the attachment content (media) storage quota in megabytes for the media resource in the Azure Cosmos DB service. Retrieved from gateway.
            </summary>
            <value>The attachment content (media) storage quota in megabytes.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.Media">
            <summary>
            Gets the attachment content stream for the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The attachment content stream.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.ResponseHeaders">
            <summary>
            Gets the headers associated with the response associated with the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The headers associated with the response.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IMediaResponse.Slug">
            <summary>
            Gets the HTTP slug header value for the response associcated with the media resource in the Azure Cosmos DB service.
            </summary>
            <value>The HTTP slug header value.</value>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Common.AsyncCache`2">
            <summary>
            Cache which supports asynchronous value initialization.
            It ensures that for given key only single inintialization funtion is running at any point in time.
            </summary>
            <typeparam name="TKey">Type of keys.</typeparam>
            <typeparam name="TValue">Type of values.</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.AsyncCache`2.GetAsync(`0,`1,System.Func{System.Threading.Tasks.Task{`1}},System.Threading.CancellationToken,System.Boolean)">
            <summary>
            <para>
            Gets value corresponding to <paramref name="key"/>.
            </para>
            <para>
            If another initialization function is already running, new initialization function will not be started.
            The result will be result of currently running initialization function.
            </para>
            <para>
            If previous initialization function is successfully completed - value returned by it will be returned unless
            it is equal to <paramref name="obsoleteValue"/>, in which case new initialization function will be started.
            </para>
            <para>
            If previous initialization function failed - new one will be launched.
            </para>
            </summary>
            <param name="key">Key for which to get a value.</param>
            <param name="obsoleteValue">Value which is obsolete and needs to be refreshed.</param>
            <param name="singleValueInitFunc">Initialization function.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="forceRefresh">Skip cached value and generate new value.</param>
            <returns>Cached value or value returned by initialization function.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.AsyncCache`2.RemoveAsync(`0)">
            <summary>
            Remove value from cache and return it if present.
            </summary>
            <param name="key"></param>
            <returns>Value if present, default value if not present.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.AsyncCache`2.BackgroundRefreshNonBlocking(`0,System.Func{System.Threading.Tasks.Task{`1}})">
            <summary>
            Runs a background task that will started refreshing the cached value for a given key.
            This observes the same logic as GetAsync - a running value will still take precedence over a call to this.
            </summary>
            <param name="key">Key.</param>
            <param name="singleValueInitFunc">Generator function.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Common.CollectionCache">
            <summary>
            Cache to provide resource id lookup based on resource name
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Common.CollectionCache.InternalCache">
            <summary>
            Master Service returns collection definition based on API Version and may not be always same for all API Versions.
            Here the InternalCache stores collection information related to a particular API Version
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Common.CollectionCache.cacheByApiList">
            <summary>
            cacheByApiList caches the collection information by API Version. In general it is expected that only a single version is populated
            for a collection, but this handles the situation if customer is using multiple API versions from different applications
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.CollectionCache.ResolveCollectionAsync(Microsoft.Azure.Documents.DocumentServiceRequest,System.TimeSpan,System.Threading.CancellationToken,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Resolve the ContainerProperties object from the cache. If the collection was read before "refreshAfter" Timespan, force a cache refresh by reading from the backend.
            </summary>
            <param name="request">Request to resolve.</param>
            <param name="refreshAfter"> Time duration to refresh</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="trace">The trace.</param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.CollectionCache.ResolveCollectionAsync(Microsoft.Azure.Documents.DocumentServiceRequest,System.Threading.CancellationToken,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Resolves a request to a collection in a sticky manner.
            Unless request.ForceNameCacheRefresh is equal to true, it will return the same collection.
            </summary>
            <param name="request">Request to resolve.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="trace">The trace.</param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.CollectionCache.Refresh(System.String,System.String)">
            <summary>
            This method is only used in client SDK in retry policy as it doesn't have request handy.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.CollectionCache.GetCache(System.String)">
            <summary>
            The function selects the right cache based on apiVersion. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Common.IAddressCache.TryGetAddressesAsync(Microsoft.Azure.Documents.DocumentServiceRequest,Microsoft.Azure.Documents.PartitionKeyRangeIdentity,Microsoft.Azure.Documents.ServiceIdentity,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Resolves physical addresses by either PartitionKeyRangeIdentity or by ServiceIdentity.
            Client SDK would resolve by PartitionKeyRangeIdentity. Gateway would resolve by ServiceIdentity.
            </summary>
            <param name="request">
            Request is needed only by GatewayAddressCache in the only case when request is name based and user has name based auth token.
            Neither PartitionkeyRangeIdentity nor ServiceIdentity can be used to locate auth token in this case.
            </param>
            <param name="partitionKeyRangeIdentity">This parameter will be supplied in both client SDK and Gateway. In Gateway it will be absent only in case <see cref="P:Microsoft.Azure.Documents.DocumentServiceRequest.ServiceIdentity"/> is not <c>null</c>.</param>
            <param name="serviceIdentity">This parameter will be only supplied in Gateway. FabricAddressCache ignores <paramref name="partitionKeyRangeIdentity"/>.</param>
            <param name="forceRefreshPartitionAddresses">Whether addresses need to be refreshed as previously resolved addresses were determined to be outdated.</param>
            <param name="cancellationToken">Instance of <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>Physical addresses.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IResourceResponseBase">
            <summary>
            Represents the non-resource specific service response headers returned by any request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Interface exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.DatabaseQuota">
            <summary>
            Gets the maximum quota for database resources within the account. 
            </summary>
            <value>
            The maximum quota for the account.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.DatabaseUsage">
            <summary>
            The current number of database resources within the account.
            </summary>
            <value>
            The number of databases.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.CollectionQuota">
            <summary>
            Gets the maximum quota for collection resources within an account.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.CollectionUsage">
            <summary>
            The current number of collection resources within the account.
            </summary>
            <value>
            The number of collections.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.UserQuota">
            <summary>
            Gets the maximum quota for user resources within an account.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.UserUsage">
            <summary>
            The current number of user resources within the account.
            </summary>
            <value>
            The number of users.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.PermissionQuota">
            <summary>
            Gets the maximum quota for permission resources within an account.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.PermissionUsage">
            <summary>
            The current number of permission resources within the account. 
            </summary>
            <value>
            The number of permissions.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.CollectionSizeQuota">
            <summary>
            Maximum size of a collection in kilobytes.
            </summary>
            <value>
            Quota in kilobytes.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.CollectionSizeUsage">
            <summary>
            Current size of a collection in kilobytes. 
            </summary>
            <value>
            Current collection size in kilobytes.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.DocumentQuota">
            <summary>
            Maximum size of a documents within a collection in kilobytes.
            </summary>
            <value>
            Quota in kilobytes.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.DocumentUsage">
            <summary>
            Current size of documents within a collection in kilobytes. 
            </summary>
            <value>
            Current documents size in kilobytes.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.StoredProceduresQuota">
            <summary>
            Gets the maximum quota of stored procedures for a collection.
            </summary>
            <value>
            The maximum quota.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.StoredProceduresUsage">
            <summary>
            The current number of stored procedures for a collection.
            </summary>
            <value>
            Current number of stored procedures.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.TriggersQuota">
            <summary>
            Gets the maximum quota of triggers for a collection. 
            </summary>
            <value>
            The maximum quota.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.TriggersUsage">
            <summary>
            The current number of triggers for a collection.
            </summary>
            <value>
            Current number of triggers.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.UserDefinedFunctionsQuota">
            <summary>
            Gets the maximum quota of user defined functions for a collection. 
            </summary>
            <value>
            Maximum quota.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.UserDefinedFunctionsUsage">
            <summary>
            The current number of user defined functions for a collection.
            </summary>
            <value>
            Current number of user defined functions.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.ActivityId">
            <summary>
            Gets the activity ID for the request.
            </summary>
            <value>
            The activity ID for the request.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.SessionToken">
            <summary>
            Gets the session token for use in sesssion consistency reads.
            </summary>
            <value>
            The session token for use in session consistency.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.StatusCode">
            <summary>
            Gets the HTTP status code associated with the response.
            </summary>
            <value>
            The HTTP status code associated with the response.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.MaxResourceQuota">
            <summary>
            Gets the maximum size limit for this entity.
            </summary>
            <value>
            The maximum size limit for this entity. Measured in kilobytes for document resources 
            and in counts for other resources.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.CurrentResourceQuotaUsage">
            <summary>
            Gets the current size of this entity.
            </summary>
            <value>
            The current size for this entity. Measured in kilobytes for document resources 
            and in counts for other resources.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.ResponseStream">
            <summary>
            Gets the underlying stream of the response.
            </summary>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.RequestCharge">
            <summary>
            Gets the request charge for this request.
            </summary>
            <value>
            The request charge measured in reqest units.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.ResponseHeaders">
            <summary>
            Gets the response headers.
            </summary>
            <value>
            The response headers.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.ContentLocation">
            <summary>
            The content parent location, for example, dbs/foo/colls/bar
            </summary>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.IndexTransformationProgress">
            <summary>
            Gets the progress of an index transformation, if one is underway.
            </summary>
            <value>
            An integer from 0 to 100 representing percentage completion of the index transformation process.
            Returns -1 if the index transformation progress header could not be found.
            </value>
            <remarks>
            An index will be rebuilt when the IndexPolicy of a collection is updated.
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IResourceResponseBase.LazyIndexingProgress">
            <summary>
            Gets the progress of lazy indexing.
            </summary>
            <value>
            An integer from 0 to 100 representing percentage completion of the lazy indexing process.
            Returns -1 if the lazy indexing progress header could not be found.
            </value>
            <remarks>
            Lazy indexing progress only applies to the collection with indexing mode Lazy.
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1">
            <summary>
            Interface exposed for mocking purposes for the Azure Cosmos DB service.
            </summary>
            <typeparam name="TValue">The returned value type of the stored procedure.</typeparam>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.ActivityId">
            <summary>
            Gets the Activity ID of the request.
            </summary>
            <value>
            The Activity ID of the request.
            </value>
            <remarks>Every request is traced with a globally unique ID. 
            Include activity ID in tracing application failures and when contacting Azure Cosmos DB support.
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.CurrentResourceQuotaUsage">
            <summary>
            Gets the delimited string containing the usage of each resource type within the collection.
            </summary>
            <value>The delimited string containing the number of used units per resource type within the collection.</value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.MaxResourceQuota">
            <summary>
            Gets the delimited string containing the quota of each resource type within the collection.
            </summary>
            <value>The delimited string containing the number of used units per resource type within the collection.</value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.RequestCharge">
            <summary>
            Gets the number of normalized request units (RUs) charged.
            </summary>
            <value>
            The number of normalized request units (RUs) charged.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.Response">
            <summary>
            Gets the response of a stored procedure, serialized into the given type.
            </summary>
            <value>The response of a stored procedure, serialized into the given type.</value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.ResponseHeaders">
            <summary>
            Gets the headers associated with the response.
            </summary>
            <value>
            Headers associated with the response.
            </value>
            <remarks>
            Provides access to all HTTP response headers returned from the 
            Azure Cosmos DB API.
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.SessionToken">
            <summary>
            Gets the token for use with session consistency requests.
            </summary>
            <value>
            The token for use with session consistency requests.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.ScriptLog">
            <summary>
            Gets the output from stored procedure console.log() statements.
            </summary>
            <value>
            Output from console.log() statements in a stored procedure.
            </value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
            <seealso cref="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.EnableScriptLogging"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IStoredProcedureResponse`1.StatusCode">
            <summary>
            Gets the request completion status code.
            </summary>
            <value>The request completion status code</value>
            <remarks>
            This is exposed for mocking purposes for the Azure Cosmos DB service.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.ByteOrder">
            <summary>
            The ByteOrder class is capable of reversing the bytes of any primitive type.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Byte)">
            <summary>
            Reverses a single byte.
            </summary>
            <param name="value">The byte to reverse</param>
            <returns>The reversed byte.</returns>
            <remarks>Since a single byte has no byte order, so the value itself is returned so this is essentially a NO-OP.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Boolean)">
            <summary>
            Reverses a bool.
            </summary>
            <param name="value">The bool to reverse</param>
            <returns>The reversed bool.</returns>
            <remarks>Since a bool has no byte order, so the value itself is returned so this is essentially a NO-OP.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Char)">
            <summary>
            Reverses a char.
            </summary>
            <param name="value">The char to reverse.</param>
            <returns>The reversed char.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Int16)">
            <summary>
            Reverses a short.
            </summary>
            <param name="value">The short to reverse.</param>
            <returns>The reversed short.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.UInt16)">
            <summary>
            Reverses a ushort.
            </summary>
            <param name="value">The ushort to reverse.</param>
            <returns>The reversed ushort.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Int32)">
            <summary>
            Reverses a int.
            </summary>
            <param name="value">The int to reverse.</param>
            <returns>The reversed int.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.UInt32)">
            <summary>
            Reverses a uint.
            </summary>
            <param name="value">The uint to reverse.</param>
            <returns>The reversed uint.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Int64)">
            <summary>
            Reverses a long.
            </summary>
            <param name="value">The long to reverse.</param>
            <returns>The reversed long.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.UInt64)">
            <summary>
            Reverses a ulong.
            </summary>
            <param name="value">The ulong to reverse.</param>
            <returns>The reversed ulong.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Single)">
            <summary>
            Reverses a float.
            </summary>
            <param name="value">The float to reverse.</param>
            <returns>The reversed float.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ByteOrder.Reverse(System.Double)">
            <summary>
            Reverses a double.
            </summary>
            <param name="value">The double to reverse.</param>
            <returns>The reversed double.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.IJsonNavigator">
            <summary>
            JsonNavigator interface for classes that can navigate jsons.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.IJsonNavigator.SerializationFormat">
            <summary>
            Gets the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonSerializationFormat"/> for the IJsonNavigator.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetRootNode">
            <summary>
            Gets the root node.
            </summary>
            <returns>The root node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetNodeType(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonNodeType"/> type for a particular node
            </summary>
            <param name="node">The the node you want to know the type of</param>
            <returns><see cref="T:Microsoft.Azure.Cosmos.Json.JsonNodeType"/> for the node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetNumber64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>A double that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <summary>
            Tries to get the buffered string value from a node.
            </summary>
            <param name="stringNode">The node to get the buffered string from.</param>
            <param name="value">The buffered string value if possible</param>
            <returns><code>true</code> if the JsonNavigator successfully got the buffered string value; <code>false</code> if the JsonNavigator failed to get the buffered string value.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets a string value from a node.
            </summary>
            <param name="stringNode">The node to get the string value from.</param>
            <returns>The string value from the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetInt8Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as a signed byte.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>A sbyte value that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetInt16Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as a 16-bit signed integer.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>A short value that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as a 32-bit signed integer.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>An int value that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetInt64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as a 64-bit signed integer.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>A long value that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetFloat32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as a single precision number if the number is expressed as a floating point.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>A double that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetFloat64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as double precision number if the number is expressed as a floating point.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>A double that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetUInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the numeric value for a node as an unsigned 32 bit integer if the node is expressed as an uint32.
            </summary>
            <param name="numberNode">The node you want the number value from.</param>
            <returns>An unsigned integer that represents the number value in the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetGuidValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the Guid value for a node.
            </summary>
            <param name="guidNode">The node you want the guid value from.</param>
            <returns>A guid read from the node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets a binary value for a given node from the input.
            </summary>
            <param name="binaryNode">The node to get the binary value from.</param>
            <returns>The binary value from the node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.TryGetBufferedBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.ReadOnlyMemory{System.Byte}@)">
            <summary>
            Tries to get the buffered binary value from a node.
            </summary>
            <param name="binaryNode">The node to get the buffered binary from.</param>
            <param name="bufferedBinaryValue">The buffered binary value if possible</param>
            <returns><code>true</code> if the JsonNavigator successfully got the buffered binary value; <code>false</code> if the JsonNavigator failed to get the buffered binary value.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetArrayItemCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the number of elements in an array node.
            </summary>
            <param name="arrayNode">The (array) node to get the count of.</param>
            <returns>The number of elements in the array node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetArrayItemAt(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.Int32)">
            <summary>
            Gets the node at a particular index of an array node
            </summary>
            <param name="arrayNode">The (array) node to index from.</param>
            <param name="index">The offset into the array</param>
            <returns>The node at a particular index of an array node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetArrayItems(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the array item nodes of the array node.
            </summary>
            <param name="arrayNode">The array to get the items from.</param>
            <returns>The array item nodes of the array node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetObjectPropertyCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the number of properties in an object node.
            </summary>
            <param name="objectNode">The node to get the property count from.</param>
            <returns>The number of properties in an object node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.TryGetObjectProperty(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.String,Microsoft.Azure.Cosmos.Json.ObjectProperty@)">
            <summary>
            Tries to get a object property from an object with a particular property name.
            </summary>
            <param name="objectNode">The object node to get a property from.</param>
            <param name="propertyName">The name of the property to search for.</param>
            <param name="objectProperty">The <see cref="T:Microsoft.Azure.Cosmos.Json.ObjectProperty"/> with the specified property name if it exists.</param>
            <returns><code>true</code> if the JsonNavigator successfully found the <see cref="T:Microsoft.Azure.Cosmos.Json.ObjectProperty"/> with the specified property name; <code>false</code> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.GetObjectProperties(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Gets the <see cref="T:Microsoft.Azure.Cosmos.Json.ObjectProperty"/> properties from an object node.
            </summary>
            <param name="objectNode">The object node to get the properties from.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Json.ObjectProperty"/> properties from an object node.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.CreateReader(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Creates an <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonReader"/> that is able to read the supplied <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode"/>.
            </summary>
            <param name="jsonNavigatorNode">The node to create a reader from..</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonReader"/> that is able to read the supplied <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonNavigator.WriteNode(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.IJsonWriter)">
            <summary>
            Writes a <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode"/> to a <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonWriter"/>.
            </summary>
            <param name="jsonNavigatorNode">The <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode"/> to write.</param>
            <param name="jsonWriter">The <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonWriter"/> to write to.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode">
            <summary>
            Interface that describes a Node within a JSON document in a <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonNavigator"/>
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.IJsonReader">
            <summary>
            Interface for all JsonReaders that know how to read jsons.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.IJsonReader.SerializationFormat">
            <summary>
            Gets the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonSerializationFormat"/> for the JsonReader
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.IJsonReader.CurrentDepth">
            <summary>
            Gets the current level of nesting of the JSON that the JsonReader is reading.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.IJsonReader.CurrentTokenType">
            <summary>
            Gets the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonTokenType"/> of the current token that the JsonReader is about to read.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.Read">
            <summary>
            Advances the JsonReader by one token.
            </summary>
            <returns><code>true</code> if the JsonReader successfully advanced to the next token; <code>false</code> if the JsonReader has passed the end of the JSON.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetNumberValue">
            <summary>
            Gets the next JSON token from the JsonReader as a double.
            </summary>
            <returns>The next JSON token from the JsonReader as a double.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetStringValue">
            <summary>
            Gets the next JSON token from the JsonReader as a UTF-16 string.
            </summary>
            <returns>The next JSON token from the JsonReader as a string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <summary>
            Tries to get the buffered UTF-8 string value.
            </summary>
            <param name="value">The buffered UTF-8 string value if found.</param>
            <returns>true if the buffered UTF-8 string value was retrieved; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetInt8Value">
            <summary>
            Gets the next JSON token from the JsonReader as a 1 byte signed integer.
            </summary>
            <returns>The next JSON token from the JsonReader as a 1 byte signed integer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetInt16Value">
            <summary>
            Gets the next JSON token from the JsonReader as a 2 byte signed integer.
            </summary>
            <returns>The next JSON token from the JsonReader as a 2 byte signed integer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetInt32Value">
            <summary>
            Gets the next JSON token from the JsonReader as a 4 byte signed integer.
            </summary>
            <returns>The next JSON token from the JsonReader as a 4 byte signed integer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetInt64Value">
            <summary>
            Gets the next JSON token from the JsonReader as a 8 byte signed integer.
            </summary>
            <returns>The next JSON token from the JsonReader as a 8 byte signed integer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetUInt32Value">
            <summary>
            Gets the next JSON token from the JsonReader as a 4 byte unsigned integer.
            </summary>
            <returns>The next JSON token from the JsonReader as a 4 byte unsigned integer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetFloat32Value">
            <summary>
            Gets the next JSON token from the JsonReader as a single precision floating point.
            </summary>
            <returns>The next JSON token from the JsonReader as a single precision floating point.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetFloat64Value">
            <summary>
            Gets the next JSON token from the JsonReader as a double precision floating point.
            </summary>
            <returns>The next JSON token from the JsonReader as a double precision floating point.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetGuidValue">
            <summary>
            Gets the next JSON token from the JsonReader as a GUID.
            </summary>
            <returns>The next JSON token from the JsonReader as a GUID.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.GetBinaryValue">
            <summary>
            Gets the next JSON token from the JsonReader as a binary list.
            </summary>
            <returns>The next JSON token from the JsonReader as a binary list.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.WriteCurrentToken(Microsoft.Azure.Cosmos.Json.IJsonWriter)">
            <summary>
            Writes the current token on the reader to the writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonReader.WriteAll(Microsoft.Azure.Cosmos.Json.IJsonWriter)">
            <summary>
            Writes all the tokens in the reader to the writer.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation">
            <summary>
            This is meant more as a friends class. Do not use unless you have a strong reason to.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.IJsonWriter">
            <summary>
            Interface for all JsonWriters that know how to write jsons of a specific serialization format.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.IJsonWriter.SerializationFormat">
            <summary>
            Gets the SerializationFormat of the JsonWriter.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.IJsonWriter.CurrentLength">
            <summary>
            Gets the current length of the internal buffer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteObjectStart">
            <summary>
            Writes the object start symbol to internal buffer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteObjectEnd">
            <summary>
            Writes the object end symbol to the internal buffer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteArrayStart">
            <summary>
            Writes the array start symbol to the internal buffer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteArrayEnd">
            <summary>
            Writes the array end symbol to the internal buffer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteFieldName(System.String)">
            <summary>
            Writes a field name to the the internal buffer.
            </summary>
            <param name="fieldName">The name of the field to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteFieldName(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <summary>
            Writes a UTF-8 field name to the internal buffer.
            </summary>
            <param name="fieldName"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteStringValue(System.String)">
            <summary>
            Writes a string to the internal buffer.
            </summary>
            <param name="value">The value of the string to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteStringValue(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <summary>
            Writes a UTF-8 string value to the internal buffer.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteNumber64Value(Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Writes a number to the internal buffer.
            </summary>
            <param name="value">The value of the number to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteBoolValue(System.Boolean)">
            <summary>
            Writes a boolean to the internal buffer.
            </summary>
            <param name="value">The value of the boolean to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteNullValue">
            <summary>
            Writes a null to the internal buffer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteInt8Value(System.SByte)">
            <summary>
            Writes an single signed byte integer to the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteInt16Value(System.Int16)">
            <summary>
            Writes an signed 2-byte integer to the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteInt32Value(System.Int32)">
            <summary>
            Writes an signed 4-byte integer to the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteInt64Value(System.Int64)">
            <summary>
            Writes an signed 8-byte integer to the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteFloat32Value(System.Single)">
            <summary>
            Writes a single precision floating point number into the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteFloat64Value(System.Double)">
            <summary>
            Writes a double precision floating point number into the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteUInt32Value(System.UInt32)">
            <summary>
            Writes a 4 byte unsigned integer into the internal buffer.
            </summary>
            <param name="value">The value of the integer to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteGuidValue(System.Guid)">
            <summary>
            Writes a Guid value into the internal buffer.
            </summary>
            <param name="value">The value of the guid to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.WriteBinaryValue(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a Binary value into the internal buffer.
            </summary>
            <param name="value">The value of the bytes to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.IJsonWriter.GetResult">
            <summary>
            Gets the result of the JsonWriter.
            </summary>
            <returns>The result of the JsonWriter as an array of bytes.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader">
            <summary>
            Wrapper class that implements a Newtonsoft JsonReader,
            but forwards all the calls to a CosmosDB JSON reader.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.Null">
            <summary>
            Singleton boxed value for null.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.False">
            <summary>
            Singleton boxed value for false.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.True">
            <summary>
            Singleton boxed value for true.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.jsonReader">
            <summary>
            The CosmosDB JSON Reader that will be used for implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.#ctor(Microsoft.Azure.Cosmos.Json.IJsonReader)">
            <summary>
            Initializes a new instance of the NewtonsoftReader class.
            </summary>
            <param name="jsonReader">The reader to interop with.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.Read">
            <summary>
            Reads the next token from the reader.
            </summary>
            <returns>True if a token was read, else false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadAsBytes">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Byte"/>[].
            </summary>
            <returns>A <see cref="T:System.Byte"/>[] or <c>null</c> if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadAsDateTime">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1"/> of <see cref="T:System.DateTime"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/> of <see cref="T:System.DateTime"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadAsDateTimeOffset">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1"/> of <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/> of <see cref="T:System.DateTimeOffset"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadAsDecimal">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1"/> of <see cref="T:System.Decimal"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/> of <see cref="T:System.Decimal"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadAsInt32">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.Nullable`1"/> of <see cref="T:System.Int32"/>.
            </summary>
            <returns>A <see cref="T:System.Nullable`1"/> of <see cref="T:System.Int32"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadAsString">
            <summary>
            Reads the next JSON token from the source as a <see cref="T:System.String"/>.
            </summary>
            <returns>A <see cref="T:System.String"/>. This method will return <c>null</c> at the end of an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftReader.ReadNumberValue">
            <summary>
            Reads the next number token but returns null at the end of an array.
            </summary>
            <returns>The next number token but returns null at the end of an array.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter">
            <summary>
            Wrapper class that implements Newtonsoft's JsonWriter,
            but calls into a CosmosDB JsonWriter for the implementation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.jsonWriter">
            <summary>
            A CosmosDB JSON writer used for the actual implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.#ctor(Microsoft.Azure.Cosmos.Json.JsonSerializationFormat)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter"/> class.
            </summary>
            <param name="jsonSerializationFormat">The SerializationFormat to use.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.Flush">
            <summary>
            Flushes whatever is in the buffer to the underlying <see cref="T:System.IO.Stream"/> and also flushes the underlying stream.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteComment(System.String)">
            <summary>
            Writes a comment <c>/*...*/</c> containing the specified text.
            </summary>
            <param name="text">Text to place inside the comment.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteEndArray">
            <summary>
            Writes the end of an array.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteEndConstructor">
            <summary>
            Writes the end constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteEndObject">
            <summary>
            Writes the end of a JSON object.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WritePropertyName(System.String)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WritePropertyName(System.String,System.Boolean)">
            <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="escape">Whether or not to escape the name</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteStartConstructor(System.String)">
            <summary>
            Writes the start of a constructor with the given name.
            </summary>
            <param name="name">The name of the constructor.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteRaw(System.String)">
            <summary>
            Writes raw JSON.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteRawValue(System.String)">
            <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
            <param name="json">The raw JSON to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteStartArray">
            <summary>
            Writes the beginning of a JSON array.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteStartObject">
            <summary>
            Writes the beginning of a JSON object.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteUndefined">
            <summary>
            Writes an undefined value.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Object)">
            <summary>
            Writes a <see cref="T:System.Object"/> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
            <param name="value">The <see cref="T:System.Object"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.String)">
            <summary>
            Writes a <see cref="T:System.String"/> value.
            </summary>
            <param name="value">The <see cref="T:System.String"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Int32)">
            <summary>
            Writes a <see cref="T:System.Int32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.UInt32)">
            <summary>
            Writes a <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt32"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.UInt64)">
            <summary>
            Writes a <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Single)">
            <summary>
            Writes a <see cref="T:System.Single"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Double)">
            <summary>
            Writes a <see cref="T:System.Double"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Boolean"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Int16"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value.
            </summary>
            <param name="value">The <see cref="T:System.UInt16"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Char"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.SByte)">
            <summary>
            Writes a <see cref="T:System.SByte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.SByte"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Decimal)">
            <summary>
            Writes a <see cref="T:System.Decimal"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Decimal"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="value">The <see cref="T:System.DateTime"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte"/>[] value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/>[] value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Guid)">
            <summary>
            Writes a <see cref="T:System.Guid"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Guid"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.TimeSpan)">
            <summary>
            Writes a <see cref="T:System.TimeSpan"/> value.
            </summary>
            <param name="value">The <see cref="T:System.TimeSpan"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.WriteValue(System.Uri)">
            <summary>
            Writes a <see cref="T:System.Uri"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Uri"/> value to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.Interop.CosmosDBToNewtonsoftWriter.GetResult">
            <summary>
            Gets the result of all the tokens written so far.
            </summary>
            <returns>The result of all the tokens written so far.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.Interop.NewtonsoftToCosmosDBReader">
            <summary>
            IJsonReader adapter for a Newtonsoft reader meaning we get a newtonsoft reader for testing purposes.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.ITypedBinaryJsonWriter">
            <summary>
            Interface for all TypedBinaryJsonWriter that know how to write typed binary JSON.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ITypedBinaryJsonWriter.Write(Microsoft.Azure.Cosmos.Json.PreblittedBinaryJsonScope)">
            <summary>
            Writes a pre-blitted binary JSON scope.
            </summary>
            <param name="scope">Scope to write.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ITypedBinaryJsonWriter.WriteDollarTBsonTypeDollarV(System.Byte)">
            <summary>
            Writes a "{ $t: cosmosBsonType, $v: " snippet.
            </summary>
            <param name="cosmosBsonTypeByte">Cosmos BSON type.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ITypedBinaryJsonWriter.WriteDollarTBsonTypeDollarVNestedScope(System.Boolean,System.Byte)">
            <summary>
            Writes a "{ $t: cosmosBsonType, $v: {" snippet (or "{ $t: cosmosBsonType, $v: [" if array).
            </summary>
            <param name="isNestedArray">Indicates whether the nested scope should be an array.</param>
            <param name="cosmosBsonTypeByte">Cosmos BSON type.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.ITypedJsonReader">
            <summary>
            Interface for all TypedJsonReaders that know how to read typed json.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ITypedJsonReader.TryReadTypedJsonValueWrapper(System.Int32@)">
            <summary>
            Attempt to read a '$t': TYPECODE, '$v' in one call.
            If unsuccessful, the reader is left in its original state.
            Otherwise it is positioned at the value after the $v.
            </summary>
            <param name="typeCode">The type code read.</param>
            <returns>Success.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ITypedJsonReader.GetUtf8SpanValue">
            <summary>
            Gets the next JSON token from the JsonReader as a UTF-8 span.
            </summary>
            <returns>The next JSON token from the JsonReader as a span.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding">
            <summary>
            Static class with utility functions and constants for JSON binary encoding.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarkerLength">
            <summary>
            A type marker is a single byte.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.OneByteLength">
            <summary>
            Some type markers are followed by a single byte representing the length.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.OneByteCount">
            <summary>
            Some type markers are followed by 1 byte for the length and then optionally 1 byte for the count.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TwoByteLength">
            <summary>
            Some type markers are followed by 2 bytes representing the length as a ushort.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TwoByteCount">
            <summary>
            Some type markers are followed by 2 bytes for the length and then optionally 2 bytes for the count (both are ushorts).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.FourByteLength">
            <summary>
            Some type markers are followed by 4 bytes for representing the length as a uint32.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.FourByteCount">
            <summary>
            Some type markers are followed by 4 bytes for the length and then optionally 4 bytes for the count (both are uint32).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.OneByteBaseChar">
            <summary>
            For compressed strings we use a single byte base character.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.OneByteOffset">
            <summary>
            Reference strings are followed by an offset; this is for 1 byte offset reference strings.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TwoByteOffset">
            <summary>
            Reference strings are followed by an offset; this is for 2 byte offset reference strings.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.ThreeByteOffset">
            <summary>
            Reference strings are followed by an offset; this is for 2 byte offset reference strings.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.FourByteOffset">
            <summary>
            Reference strings are followed by an offset; this is for 4 byte offset reference strings.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.GetValueLength(System.ReadOnlySpan{System.Byte})">
            <summary>
            Gets the length of a particular value given it's typemarker
            </summary>
            <param name="buffer">The buffer to read from as input.</param>
            <returns>
            - Positive Value: The length of the value including its TypeMarker
            - Negative Value: The length is encoded as an integer of size equals to abs(value) following the TypeMarker byte
            - Zero Value: The length is unknown (for instance an unassigned type marker)
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.GetStringLengths(System.Byte)">
            <summary>
            Gets the length of a particular string given it's typemarker.
            </summary>
            <param name="typeMarker">The type marker as input</param>
            <returns>
            - Non-Negative Value: The TypeMarker encodes the string length
            - Negative Value: System or user dictionary encoded string, or encoded string length that follows the TypeMarker
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.GetFirstValueOffset(System.Byte)">
            <summary>
            Gets the offset of the first item in an array or object
            </summary>
            <param name="typeMarker">The typemarker as input.</param>
            <returns>The offset of the first item in an array or object</returns>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.FirstValueOffsets.Offsets">
            <summary>
            Defines the offset of the first item in an array or object
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.MultiByteTypeMarker">
            <summary>
            Struct to hold the a multibyte type marker.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.MultiByteTypeMarker.#ctor(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the MultiByteTypeMarker struct.
            </summary>
            <param name="length">The length of the typemarker.</param>
            <param name="one">The first byte.</param>
            <param name="two">The second byte.</param>
            <param name="three">The third byte.</param>
            <param name="four">The fourth byte.</param>
            <param name="five">The fifth byte.</param>
            <param name="six">The sixth byte.</param>
            <param name="seven">The seventh byte.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.GetNumberValue(System.ReadOnlySpan{System.Byte})">
            <summary>
            Gets the number value from the binary reader.
            </summary>
            <param name="numberToken">The buffer to read the number from.</param>
            <returns>The number value from the binary reader.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetNumberValue(System.ReadOnlySpan{System.Byte},Microsoft.Azure.Cosmos.Number64@,System.Int32@)">
            <summary>
            Try Get NumberValue
            </summary>
            <param name="numberToken">The buffer.</param>
            <param name="number64">The number.</param>
            <param name="bytesConsumed">The number of bytes consumed</param>
            <returns>Whether a number was parsed.</returns>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.StringLengths.Lengths">
            <summary>
            Lookup table for encoded string length for each TypeMarker value (0 to 255)
            The lengths are encoded as follows:
            - Non-Negative Value: The TypeMarker encodes the string length
            - Negative Value: System or user dictionary encoded string, or encoded string length that follows the TypeMarker
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.IsBufferedStringCandidate">
            <summary>
             Determines whether a type-marker is potentially for a buffered string value
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetEncodedStringValue(System.ReadOnlySpan{System.Byte},Microsoft.Azure.Cosmos.Json.UtfAllString@)">
            <summary>
            Try Get Encoded String Value
            </summary>
            <param name="stringToken">The string token to read from.</param>
            <param name="value">The encoded string if found.</param>
            <returns>Encoded String Value</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetEncodedSystemStringValue(System.ReadOnlySpan{System.Byte},Microsoft.Azure.Cosmos.Json.UtfAllString@)">
            <summary>
            Try Get Encoded System String Value
            </summary>
            <param name="stringToken">The buffer to read from..</param>
            <param name="value">The encoded system string.</param>
            <returns>Encoded System String Value</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetEncodedUserStringValue(System.ReadOnlySpan{System.Byte},Microsoft.Azure.Cosmos.Json.UtfAllString@)">
            <summary>
            Try Get Encoded User String Value
            </summary>
            <param name="stringToken">The string token to read from.</param>
            <param name="encodedUserStringValue">The encoded user string value if found.</param>
            <returns>Whether or not the Encoded User String Value was found</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetEncodedStringTypeMarker(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span,Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.MultiByteTypeMarker@)">
            <summary>
            Try Get Encoded String Type Marker
            </summary>
            <param name="utf8Span">the value</param>
            <param name="multiByteTypeMarker">The encoded string type marker if found.</param>
            <returns>Whether or not the type marker was found.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetEncodedSystemStringTypeMarker(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span,Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.MultiByteTypeMarker@)">
            <summary>
            Try Get Encoded System String Type Marker
            </summary>
            <param name="utf8Span">The value.</param>
            <param name="multiByteTypeMarker">The multi byte type marker if found.</param>
            <returns>Whether or not the Encoded System String Type Marker was found.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TryGetEncodedUserStringTypeMarker(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span,Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.MultiByteTypeMarker@)">
            <summary>
            Try Get Encoded User String Type Marker
            </summary>
            <param name="utf8Span">The value.</param>
            <param name="multiByteTypeMarker">The multi byte type marker if found.</param>
            <returns>Whether or not the Encoded User String Type Marker was found.</returns>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.SystemStrings.Strings">
            <summary>
            List of system strings
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.SystemStrings.TryGetSystemStringId(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span,System.Int32@)">
            <summary>
            Gets the SystemStringId for a particular system string.
            </summary>
            <param name="utf8Span">The system string to get the enum id for.</param>
            <param name="systemStringId">The id of the system string if found.</param>
            <returns>The SystemStringId for a particular system string.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker">
            <summary>
            Defines the set of type-marker values that are used to encode JSON value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.LiteralIntMin">
            <summary>
            The first integer what can be encoded in the type marker itself.
            </summary>
            <example>1 can be encoded as LiterIntMin + 1.</example>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.LiteralIntMax">
            <summary>
            The last integer what can be encoded in the type marker itself.
            </summary>
            <example>1 can be encoded as LiterIntMin + 1.</example>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.SystemString1ByteLengthMin">
            <summary>
            The first type marker for a system string whose value can be encoded in a 1 byte type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.SystemString1ByteLengthMax">
            <summary>
            The last type marker for a system string whose value can be encoded in a 1 byte type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.UserString1ByteLengthMin">
            <summary>
            The first type marker for a user string whose value can be encoded in a 1 byte type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.UserString1ByteLengthMax">
            <summary>
            The last type marker for a user string whose value can be encoded in a 1 byte type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.UserString2ByteLengthMin">
            <summary>
            The first type marker for a system string whose value can be encoded in a 2 byte type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.UserString2ByteLengthMax">
            <summary>
            The last type marker for a system string whose value can be encoded in a 2 byte type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.LowercaseGuidString">
            <summary>
            The type marker for a guid string with only lowercase characters.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.UppercaseGuidString">
            <summary>
            The type marker for a guid string with only uppercase characaters.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.DoubleQuotedLowercaseGuidString">
            <summary>
            The type marker for a guid string that is double quoted (ETAG).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.CompressedLowercaseHexString">
            <summary>
            String 1-byte length - Lowercase hexadecimal digits encoded as 4-bit characters
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.CompressedUppercaseHexString">
            <summary>
            String 1-byte length - Uppercase hexadecimal digits encoded as 4-bit characters
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.CompressedDateTimeString">
            <summary>
            String 1-byte length - Date-time character set encoded as 4-bit characters
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Packed4BitString">
            <summary>
            String 1-byte Length - 4-bit packed characters relative to a base value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Packed5BitString">
            <summary>
            String 1-byte Length - 5-bit packed characters relative to a base value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Packed6BitString">
            <summary>
            String 1-byte Length - 6-bit packed characters relative to a base value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Packed7BitStringLength1">
            <summary>
            String 1-byte Length - 7-bit packed characters
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Packed7BitStringLength2">
            <summary>
            String 2-byte Length - 7-bit packed characters
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.EncodedStringLengthMin">
            <summary>
            The first type marker for a string whose length is encoded.
            </summary>
            <example>EncodedStringLengthMin + 1 is a type marker for a string with length 1.</example>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.EncodedStringLengthMax">
            <summary>
            The last type marker for a string whose length is encoded.
            </summary>
            <example>EncodedStringLengthMin + 1 is a type marker for a string with length 1.</example>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.String1ByteLength">
            <summary>
            Type marker for a String of 1-byte length
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.String2ByteLength">
            <summary>
            Type marker for a String of 2-byte length
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.String4ByteLength">
            <summary>
            Type marker for a String of 4-byte length
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.ReferenceString1ByteOffset">
            <summary>
            Reference string of 1-byte offset
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.ReferenceString2ByteOffset">
            <summary>
            Reference string of 2-byte offset
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.ReferenceString3ByteOffset">
            <summary>
            Reference string of 3-byte offset
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.ReferenceString4ByteOffset">
            <summary>
            Reference string of 4-byte offset
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.NumberUInt8">
            <summary>
            Type marker for a 1-byte unsigned integer
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.NumberInt16">
            <summary>
            Type marker for a 2-byte singed integer
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.NumberInt32">
            <summary>
            Type marker for a 4-byte singed integer
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.NumberInt64">
            <summary>
            Type marker for a 8-byte singed integer
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.NumberDouble">
            <summary>
            Type marker for a Double-precession floating point number
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Float32">
            <summary>
            Type marker for a single precision floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Float64">
            <summary>
            Type marker for double precision floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Null">
            <summary>
            The type marker for a JSON null value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.False">
            <summary>
            The type marker for a JSON false value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.True">
            <summary>
            The type marker for a JSON true value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Guid">
            <summary>
            The type marker for a GUID
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Int8">
            <summary>
            The type marker for a 1-byte signed integer value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Int16">
            <summary>
            The type marker for a 2-byte signed integer value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Int32">
            <summary>
            The type marker for a 4-byte signed integer value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Int64">
            <summary>
            The type marker for a 8-byte signed integer value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.UInt32">
            <summary>
            The type marker for a 4-byte signed integer value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Binary1ByteLength">
            <summary>
            Type marker for binary payloads with 1 byte length.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Binary2ByteLength">
            <summary>
            Type marker for binary payloads with 2 byte length.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Binary4ByteLength">
            <summary>
            Type marker for binary payloads with 4 byte length.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.EmptyArray">
            <summary>
            Empty array type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.SingleItemArray">
            <summary>
            Single-item array type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Array1ByteLength">
            <summary>
            Array of 1-byte length type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Array2ByteLength">
            <summary>
            Array of 2-byte length type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Array4ByteLength">
            <summary>
            Array of 4-byte length type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Array1ByteLengthAndCount">
            <summary>
            Array of 1-byte length and item count type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Array2ByteLengthAndCount">
            <summary>
            Array of 2-byte length and item count type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Array4ByteLengthAndCount">
            <summary>
            Array of 4-byte length and item count type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.EmptyObject">
            <summary>
            Empty object type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.SinglePropertyObject">
            <summary>
            Single-property object type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Object1ByteLength">
            <summary>
            Object of 1-byte length type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Object2ByteLength">
            <summary>
            Object of 2-byte length type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Object4ByteLength">
            <summary>
            Object of 4-byte length type maker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Object1ByteLengthAndCount">
            <summary>
            Object of 1-byte length and property count type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Object2ByteLengthAndCount">
            <summary>
            Object of 2-byte length and property count type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Object4ByteLengthAndCount">
            <summary>
            Object of 4-byte length and property count type marker.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.Invalid">
            <summary>
            Type marker reserved to communicate an invalid type marker.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsEncodedNumberLiteral(System.Int64)">
            <summary>
            Gets whether an integer can be encoded as a literal.
            </summary>
            <param name="value">The input integer.</param>
            <returns>Whether an integer can be encoded as a literal.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsFixedLengthNumber(System.Int64)">
            <summary>
            Gets whether an integer is a fixed length integer.
            </summary>
            <param name="value">The input integer.</param>
            <returns>Whether an integer is a fixed length integer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsNumber(System.Int64)">
            <summary>
            Gets whether an integer is a number.
            </summary>
            <param name="value">The input integer.</param>
            <returns>Whether an integer is a number.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.EncodeIntegerLiteral(System.Int64)">
            <summary>
            Encodes an integer as a literal.
            </summary>
            <param name="value">The input integer.</param>
            <returns>The integer encoded as a literal if it can; else Invalid</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsSystemString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a system string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a system string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsOneByteEncodedUserString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a one byte encoded user string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a one byte encoded user string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsTwoByteEncodedUserString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a two byte encoded user string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a two byte encoded user string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsUserString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a user string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a user string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsOneByteEncodedString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a one byte encoded string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a one byte encoded string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsTwoByteEncodedString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a two byte encoded string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a two byte encoded string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsEncodedString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for an encoded string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for an encoded string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsEncodedLengthString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for an encoded length string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for an encoded string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsCompressedString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a compressed string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a compressed string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsVariableLengthString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a variable length string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a variable length string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsReferenceString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a reference string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a reference string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsGuidString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a GUID string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a GUID string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsHexadecimalString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a hexadecimal string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a hexadecimal string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsDateTimeString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a datetime string.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the typeMarker is for a datetime string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsString(System.Byte)">
            <summary>
            Gets whether a typeMarker is for a string.
            </summary>
            <param name="typeMarker">The type maker.</param>
            <returns>Whether the typeMarker is for a string.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.GetEncodedStringLength(System.Byte)">
            <summary>
            Gets the length of a encoded string type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>The length of the encoded string type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.TryGetEncodedStringLengthTypeMarker(System.Int64,System.Byte@)">
            <summary>
            Gets the type marker for an encoded string of a particular length.
            </summary>
            <param name="length">The length of the encoded string.</param>
            <param name="typeMarker">The type marker for the encoded string of particular length if valid.</param>
            <returns>Whether or not the there is a typemarker for the string of a particular length.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsNull(System.Byte)">
            <summary>
            Gets whether a type maker is the null type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type maker is the null type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsFalse(System.Byte)">
            <summary>
            Gets whether a type maker is the false type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type maker is the false type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsTrue(System.Byte)">
            <summary>
            Gets whether a type maker is the true type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type maker is the true type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsBoolean(System.Byte)">
            <summary>
            Gets whether a type maker is a boolean type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type maker is a boolean type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsEmptyArray(System.Byte)">
            <summary>
            Gets whether a type marker is the empty array type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type marker is the empty array type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsArray(System.Byte)">
            <summary>
            Gets whether a type marker is for an array.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type marker is for an array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsEmptyObject(System.Byte)">
            <summary>
            Gets whether a type marker is the empty object type marker.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type marker is the empty object type marker.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsObject(System.Byte)">
            <summary>
            Gets whether a type marker is for an object.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type marker is for an object.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.TypeMarker.IsValid(System.Byte)">
            <summary>
            Gets whether a type marker is valid.
            </summary>
            <param name="typeMarker">The input type marker.</param>
            <returns>Whether the type marker is valid.</returns>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding.ValueLengths.Lookup">
            <summary>
            Lookup table for encoded value length for each TypeMarker value (0 to 255)
            The lengths are encoded as follows:
            - Positive Value: The length of the value including its TypeMarker
            - Negative Value: The length is encoded as an integer of size equals to abs(value) following the TypeMarker byte
            - Zero Value: The length is unknown (for instance an unassigned type marker)
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNavigator">
            <summary>
            Base abstract class for JSON navigators.
            The navigator defines methods that allow random access to JSON document nodes.
            </summary>
            <summary>
            Partial class that wraps the private JsonTextNavigator
            </summary>
            <summary>
            Partial class that wraps the private JsonTextNavigator
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonNavigator"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonNavigator.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.Create(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Creates a JsonNavigator that can navigate a supplied buffer
            </summary>
            <param name="buffer">The buffer to navigate</param>
            <returns>A concrete JsonNavigator that can navigate the supplied buffer.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetRootNode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetNodeType(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetNumber64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetInt8Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetInt16Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetInt64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetFloat32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetFloat64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetUInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetGuidValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.TryGetBufferedBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.ReadOnlyMemory{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetArrayItemCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetArrayItemAt(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetArrayItems(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetObjectPropertyCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.TryGetObjectProperty(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.String,Microsoft.Azure.Cosmos.Json.ObjectProperty@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.GetObjectProperties(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.WriteNode(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.IJsonWriter)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.CreateReader(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator">
            <summary>
            JsonNavigator that know how to navigate JSONs in binary serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the JsonBinaryNavigator class
            </summary>
            <param name="buffer">The (UTF-8) buffer to navigate.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetRootNode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetNodeType(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetNumber64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetInt8Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetInt16Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetInt64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetFloat32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetFloat64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetUInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetGuidValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetArrayItemCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetArrayItemAt(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetArrayItems(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetObjectPropertyCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.TryGetObjectProperty(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.String,Microsoft.Azure.Cosmos.Json.ObjectProperty@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonBinaryNavigator.GetObjectProperties(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator">
            <summary>
            JsonNavigator that know how to navigate JSONs in text serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator"/> class.
            </summary>
            <param name="buffer">The (UTF-8) buffer to navigate.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetRootNode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetNodeType(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetNumber64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetStringValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetInt8Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetInt16Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetInt64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetFloat32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetFloat64Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetUInt32Value(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetGuidValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.TryGetBufferedBinaryValue(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.ReadOnlyMemory{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetArrayItemCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetArrayItemAt(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetArrayItems(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetObjectPropertyCount(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.TryGetObjectProperty(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,System.String,Microsoft.Azure.Cosmos.Json.ObjectProperty@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.GetObjectProperties(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser">
            <summary>
            The JsonTextParser class is used to get a JSON AST / DOM from plaintext using a JsonTextReader as a lexer / tokenizer.
            Internally the parser is implemented as an LL(1) parser, since JSON is unambiguous and we can just parse it using recursive decent.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.Parse(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Gets the root node of a JSON AST from a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>The root node of a JSON AST from a jsonTextReader.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseArrayNode(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Parses out a JSON array AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON array AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseObjectNode(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Parses out a JSON object AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON object AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseStringNode(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Parses out a JSON string AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON string AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseNumberNode(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Parses out a JSON number AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON number AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseTrueNode(Microsoft.Azure.Cosmos.Json.IJsonReader)">
            <summary>
            Parses out a JSON true AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON true AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseFalseNode(Microsoft.Azure.Cosmos.Json.IJsonReader)">
            <summary>
            Parses out a JSON false AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON true AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseNullNode(Microsoft.Azure.Cosmos.Json.IJsonReader)">
            <summary>
            Parses out a JSON null AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON null AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParsePropertyNode(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Parses out a JSON property AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON property AST node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNavigator.JsonTextNavigator.Parser.ParseNode(Microsoft.Azure.Cosmos.Json.IJsonTextReaderPrivateImplementation)">
            <summary>
            Parses out a JSON AST node with a jsonTextReader.
            </summary>
            <param name="jsonTextReader">The reader to use as a lexer / tokenizer</param>
            <returns>JSON AST node (type determined by the reader)</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNodeType">
            <summary>
            The enumeration of JSON node types
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Null">
            <summary>
            Corresponds to the 'null' value in JSON.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.False">
            <summary>
            Corresponds to the 'false' value in JSON.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.True">
            <summary>
            Corresponds to the 'true' value in JSON.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Number64">
            <summary>
            Corresponds to the number type in JSON (number = [ minus ] integer [ fraction ] [ exponent ])
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.String">
            <summary>
            Corresponds to the string type in JSON (string = quotation-mark *char quotation-mark)
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Array">
            <summary>
            Corresponds to the array type in JSON ( begin-array [ value *( value-separator value ) ] end-array)
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Object">
            <summary>
            Corresponds to the object type in JSON (begin-object [ member *( value-separator member ) ] end-object)
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.FieldName">
            <summary>
            Corresponds to the property name of a JSON object property (which is also a string).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Int8">
            <summary>
            Corresponds to the sbyte type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Int16">
            <summary>
            Corresponds to the short type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Int32">
            <summary>
            Corresponds to the int type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Int64">
            <summary>
            Corresponds to the long type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.UInt32">
            <summary>
            Corresponds to the uint type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Float32">
            <summary>
            Corresponds to the float type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Float64">
            <summary>
            Corresponds to the double type in C# for the extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Binary">
            <summary>
            Corresponds to an arbitrary sequence of bytes (equivalent to a byte[] in C#)
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Guid">
            <summary>
            Corresponds to a GUID type in C# for teh extended types.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonNodeType.Unknown">
            <summary>
            Unknown JsonNodeType.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonObjectState">
            <summary>
            This class maintains the current state of a JSON object/value while it is being read or written.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.JsonMaxNestingDepth">
            <summary>
            This constant defines the maximum nesting depth that the parser supports.
            The JSON spec states that this is an implementation dependent thing, so we're just picking a value for now.
            FWIW .Net chose 100
            Note: This value needs to be a multiple of 8 and must be less than 2^15 (see asserts in the constructor)
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.readMode">
            <summary>
            Flag for determining whether to throw exceptions that connote a context at the end or not started / complete.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.nestingStackBitmap">
            <summary>
            Stores a bitmap for whether we are in an array or object context at a particular level (0 => array, 1 => object).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.nestingStackIndex">
            <summary>
            The current nesting stack index.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.currentContext">
            <summary>
            The current JsonObjectContext.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the JsonObjectState class.
            </summary>
            <param name="readMode">Flag for determining whether to throw exceptions that correspond to a JsonReader or JsonWriter.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonObjectState.JsonObjectContext">
            <summary>
            JsonObjectContext enum
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.JsonObjectContext.None">
            <summary>
            Context at the start of the object state.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.JsonObjectContext.Array">
            <summary>
            Context when state is in an array.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonObjectState.JsonObjectContext.Object">
            <summary>
            Context when state is in an object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.CurrentDepth">
            <summary>
            Gets the current depth (level of nesting).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.CurrentTokenType">
            <summary>
            Gets the current JsonTokenType.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.IsPropertyExpected">
            <summary>
            Gets a value indicating whether a property is expected.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.InArrayContext">
            <summary>
            Gets a value indicating whether the current context is an array.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.InObjectContext">
            <summary>
            Gets a value indicating whether the current context in an object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.RetrieveCurrentContext">
            <summary>
            Gets the current JsonObjectContext
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonObjectState.Mask">
            <summary>
            Gets a mask to use to get the current context from the nesting stack
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterToken(Microsoft.Azure.Cosmos.Json.JsonTokenType)">
            <summary>
            Registers a JsonTokenType.
            </summary>
            <param name="jsonTokenType">The JsonTokenType to register.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.Push(System.Boolean)">
            <summary>
            Pushes a JsonObjectContext onto the nesting stack.
            </summary>
            <param name="isArray">Whether the JsonObjectContext is an array.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterValue(Microsoft.Azure.Cosmos.Json.JsonTokenType)">
            <summary>
            Registers any json token type.
            </summary>
            <param name="jsonTokenType">The jsonTokenType to register</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterBeginArray">
            <summary>
            Registers a beginning of a json array ('[')
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterEndArray">
            <summary>
            Registers the end of a json array (']')
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterBeginObject">
            <summary>
            Registers a beginning of a json object ('{')
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterEndObject">
            <summary>
            Registers a end of a json object ('}')
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectState.RegisterFieldName">
            <summary>
            Register a Json FieldName
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonParseException">
            <summary>
            Abstract class that all JsonParseExceptions will derive from.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonParseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonParseException"/> class.
            </summary>
            <param name="message">The exception message for the JsonParseException</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonMissingClosingQuoteException">
            <summary>
            JsonParseException for MissingClosingQuote 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonMissingClosingQuoteException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Json.JsonMissingClosingQuoteException"/> class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNotFieldnameTokenException">
            <summary>
            JsonParseException for NotFieldnameToken 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNotFieldnameTokenException.#ctor">
            <summary>
            Initializes a new instance of the JsonNotFieldnameTokenException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonInvalidParameterException">
            <summary>
            JsonParseException for InvalidParameter 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonInvalidParameterException.#ctor">
            <summary>
            Initializes a new instance of the JsonInvalidParameterException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNumberTooLongException">
            <summary>
            JsonParseException for NumberTooLong 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNumberTooLongException.#ctor">
            <summary>
            Initializes a new instance of the JsonNumberTooLongException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonMissingNameSeparatorException">
            <summary>
            JsonParseException for MissingNameSeparator 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonMissingNameSeparatorException.#ctor">
            <summary>
            Initializes a new instance of the JsonMissingNameSeparatorException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonUnexpectedTokenException">
            <summary>
            JsonParseException for UnexpectedToken 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonUnexpectedTokenException.#ctor">
            <summary>
            Initializes a new instance of the JsonUnexpectedTokenException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonUnexpectedEndArrayException">
            <summary>
            JsonParseException for UnexpectedEndArray 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonUnexpectedEndArrayException.#ctor">
            <summary>
            Initializes a new instance of the JsonUnexpectedEndArrayException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonUnexpectedEndObjectException">
            <summary>
            JsonParseException for UnexpectedEndObject 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonUnexpectedEndObjectException.#ctor">
            <summary>
            Initializes a new instance of the JsonUnexpectedEndObjectException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonInvalidTokenException">
            <summary>
            JsonParseException for InvalidToken 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonInvalidTokenException.#ctor">
            <summary>
            Initializes a new instance of the JsonInvalidTokenException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonUnexpectedNameSeparatorException">
            <summary>
            JsonParseException for UnexpectedNameSeparator 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonUnexpectedNameSeparatorException.#ctor">
            <summary>
            Initializes a new instance of the JsonUnexpectedNameSeparatorException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonUnexpectedValueSeparatorException">
            <summary>
            JsonParseException for UnexpectedValueSeparator 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonUnexpectedValueSeparatorException.#ctor">
            <summary>
            Initializes a new instance of the JsonUnexpectedValueSeparatorException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonMissingEndObjectException">
            <summary>
            JsonParseException for MissingEndObject 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonMissingEndObjectException.#ctor">
            <summary>
            Initializes a new instance of the JsonMissingEndObjectException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonMissingEndArrayException">
            <summary>
            JsonParseException for MissingEndArray 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonMissingEndArrayException.#ctor">
            <summary>
            Initializes a new instance of the JsonMissingEndArrayException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNotStringTokenException">
            <summary>
            JsonParseException for NotStringToken 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNotStringTokenException.#ctor">
            <summary>
            Initializes a new instance of the JsonNotStringTokenException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonMaxNestingExceededException">
            <summary>
            JsonParseException for MaxNestingExceeded 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonMaxNestingExceededException.#ctor">
            <summary>
            Initializes a new instance of the JsonMaxNestingExceededException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonInvalidEscapedCharacterException">
            <summary>
            JsonParseException for InvalidEscapedCharacter 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonInvalidEscapedCharacterException.#ctor">
            <summary>
            Initializes a new instance of the JsonInvalidEscapedCharacterException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonInvalidUnicodeEscapeException">
            <summary>
            JsonParseException for InvalidUnicodeEscape 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonInvalidUnicodeEscapeException.#ctor">
            <summary>
            Initializes a new instance of the JsonInvalidUnicodeEscapeException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonInvalidStringCharacterException">
            <summary>
            JsonParseException for InvalidStringCharacter 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonInvalidStringCharacterException.#ctor">
            <summary>
            Initializes a new instance of the JsonInvalidStringCharacterException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonInvalidNumberException">
            <summary>
            JsonParseException for InvalidNumber 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonInvalidNumberException.#ctor">
            <summary>
            Initializes a new instance of the JsonInvalidNumberException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNotNumberTokenException">
            <summary>
            JsonParseException for NotNumberToken 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNotNumberTokenException.#ctor">
            <summary>
            Initializes a new instance of the JsonNotNumberTokenException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNumberOutOfRangeException">
            <summary>
            JsonParseException for NumberOutOfRange 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNumberOutOfRangeException.#ctor">
            <summary>
            Initializes a new instance of the JsonNumberOutOfRangeException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonMissingPropertyException">
            <summary>
            JsonParseException for MissingProperty 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonMissingPropertyException.#ctor">
            <summary>
            Initializes a new instance of the JsonMissingPropertyException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonPropertyAlreadyAddedException">
            <summary>
            JsonParseException for PropertyAlreadyAdded 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonPropertyAlreadyAddedException.#ctor">
            <summary>
            Initializes a new instance of the JsonPropertyAlreadyAddedException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonObjectNotStartedException">
            <summary>
            JsonParseException for ObjectNotStarted 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonObjectNotStartedException.#ctor">
            <summary>
            Initializes a new instance of the JsonObjectNotStartedException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonArrayNotStartedException">
            <summary>
            JsonParseException for ArrayNotStarted 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonArrayNotStartedException.#ctor">
            <summary>
            Initializes a new instance of the JsonArrayNotStartedException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonPropertyArrayOrObjectNotStartedException">
            <summary>
            JsonParseException for PropertyArrayOrObjectNotStarted 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonPropertyArrayOrObjectNotStartedException.#ctor">
            <summary>
            Initializes a new instance of the JsonPropertyArrayOrObjectNotStartedException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonNotCompleteException">
            <summary>
            JsonParseException for NotComplete 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonNotCompleteException.#ctor">
            <summary>
            Initializes a new instance of the JsonNotCompleteException class.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonReader">
            <summary>
            Base abstract class for JSON readers.
            The reader defines methods that allow for reading a JSON encoded value as a stream of tokens.
            The tokens are traversed in the same order as they appear in the JSON document.
            </summary>
            <summary>
            Partial JsonReader with a private JsonBinaryReader implementation
            </summary>
            <summary>
            JsonReader partial.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonObjectState">
            <summary>
            The <see cref="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonObjectState"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.#ctor">
            <summary>
            Initializes a new instance of the JsonReader class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonReader.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonReader.CurrentDepth">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonReader.CurrentTokenType">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.Create(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Creates a JsonReader that can read from the supplied byte array (assumes utf-8 encoding) with format marker.
            </summary>
            <param name="buffer">The byte array (with format marker) to read from.</param>
            <returns>A concrete JsonReader that can read the supplied byte array.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.Create(Microsoft.Azure.Cosmos.Json.JsonSerializationFormat,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Creates a JsonReader with a given serialization format and byte array.
            </summary>
            <param name="jsonSerializationFormat">The serialization format of the payload.</param>
            <param name="buffer">The buffer to read from.</param>
            <returns>An <see cref="T:Microsoft.Azure.Cosmos.Json.IJsonReader"/> for the buffer, format, and dictionary.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.Read">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetNumberValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetStringValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetInt8Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetInt16Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetInt32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetInt64Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetUInt32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetFloat32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetFloat64Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetGuidValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.GetBinaryValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.WriteCurrentToken(Microsoft.Azure.Cosmos.Json.IJsonWriter)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.WriteAll(Microsoft.Azure.Cosmos.Json.IJsonWriter)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader">
            <summary>
            JsonReader that can read from a json serialized in binary <see cref="T:Microsoft.Azure.Cosmos.Json.JsonBinaryEncoding"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.jsonBinaryBuffer">
            <summary>
            Buffer to read from.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.arrayAndObjectEndStack">
            <summary>
            For binary there is no end of token marker in the actual binary, but the JsonReader interface still needs to surface ObjectEndToken and ArrayEndToken.
            To accommodate for this we have a progress stack to let us know how many bytes there are left to read for all levels of nesting. 
            With this information we know that we are at the end of a context and can now surface an end object / array token.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.Read">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetNumberValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetStringValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetInt8Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetInt16Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetInt32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetInt64Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetUInt32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetFloat32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetFloat64Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.TryReadTypedJsonValueWrapper(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetGuidValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetBinaryValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonBinaryReader.GetUtf8SpanValue">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader">
            <summary>
            JsonReader that knows how to read text
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.EscapeCharacters">
            <summary>
            Set of all escape characters in JSON.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the JsonTextReader class.
            </summary>
            <param name="buffer">The IJsonTextBuffer to read from.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType">
            <summary>
            Enum of JsonTextTokenType with extends the enum in JsonTokenType.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.EscapedFlag">
            <summary>
            Flag for escaped characters.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.FloatFlag">
            <summary>
            Flag for whether a number is a float
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.NotStarted">
            <summary>
            Reserved for no other value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.BeginArray">
            <summary>
            Corresponds to the beginning of a JSON array ('[')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.EndArray">
            <summary>
            Corresponds to the end of a JSON array (']')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.BeginObject">
            <summary>
            Corresponds to the beginning of a JSON object ('{')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.EndObject">
            <summary>
            Corresponds to the end of a JSON object ('}')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.UnescapedString">
            <summary>
            Corresponds to a JSON string.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.EscapedString">
            <summary>
            Corresponds to an escaped JSON string.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.Number">
            <summary>
            Corresponds to a JSON number.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.True">
            <summary>
            Corresponds to the JSON 'true' value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.False">
            <summary>
            Corresponds to the JSON 'false' value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.Null">
            <summary>
            Corresponds to the JSON 'null' value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.UnescapedFieldName">
            <summary>
            Corresponds to the JSON fieldname in a JSON object.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.JsonTextTokenType.EscapedFieldName">
            <summary>
            Corresponds to the an escaped JSON fieldname in a JSON object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.Read">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetNumberValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetStringValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.TryGetBufferedStringValue(Microsoft.Azure.Cosmos.Json.Utf8Memory@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetInt8Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetInt16Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetInt32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetInt64Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetUInt32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetFloat32Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetFloat64Value">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetGuidValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonReader.JsonTextReader.GetBinaryValue">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonSerializationFormat">
            <summary>
            Defines JSON different serialization Formats
            </summary>
            <remarks>
            Every enumeration type has an underlying type, which can be any integral type except char.
            The default underlying type of enumeration elements is integer.
            To declare an enum of another integral type, such as byte, use a colon after the identifier followed by the type, as shown in the following example.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonSerializationFormat.Text">
            <summary>
            Plain text
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonSerializationFormat.Binary">
            <summary>
            Binary Encoding
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonSerializationFormat.HybridRow">
            <summary>
            HybridRow Binary Encoding
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonTextParser">
            <summary>
            Common utility class for JsonTextReader and JsonTextNavigator.
            Please treat this class as private.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonTokenType">
            <summary>
            Enum of JsonTokenType
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.NotStarted">
            <summary>
            Reserved for no other value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.BeginArray">
            <summary>
            Corresponds to the beginning of a JSON array ('[')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.EndArray">
            <summary>
            Corresponds to the end of a JSON array (']')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.BeginObject">
            <summary>
            Corresponds to the beginning of a JSON object ('{')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.EndObject">
            <summary>
            Corresponds to the end of a JSON object ('}')
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.String">
            <summary>
            Corresponds to a JSON string.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Number">
            <summary>
            Corresponds to a JSON number.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.True">
            <summary>
            Corresponds to the JSON 'true' value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.False">
            <summary>
            Corresponds to the JSON 'false' value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Null">
            <summary>
            Corresponds to the JSON 'null' value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.FieldName">
            <summary>
            Corresponds to the JSON fieldname in a JSON object.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Int8">
            <summary>
            Corresponds to a signed 1 byte integer.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Int16">
            <summary>
            Corresponds to a signed 2 byte integer.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Int32">
            <summary>
            Corresponds to a signed 4 byte integer.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Int64">
            <summary>
            Corresponds to a signed 8 byte integer.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.UInt32">
            <summary>
            Corresponds to an unsigned 4 byte integer
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Float32">
            <summary>
            Corresponds to a single precision floating point.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Float64">
            <summary>
            Corresponds to a double precision floating point.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Guid">
            <summary>
            Corresponds to a GUID.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonTokenType.Binary">
            <summary>
            Corresponds to an arbitrary sequence of bytes in an object.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonWriter">
            <summary>
            Base abstract class for JSON writers.
            The writer defines methods that allow for writing a JSON encoded value to a buffer.
            </summary>
            <summary>
            Partial class for the JsonWriter that has a private JsonTextWriter below.
            </summary>
            <summary>
            Partial class for the JsonWriter that has a private JsonTextWriter below.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonObjectState">
            <summary>
            The <see cref="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonObjectState"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.#ctor">
            <summary>
            Initializes a new instance of the JsonWriter class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonWriter.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonWriter.CurrentLength">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.Create(Microsoft.Azure.Cosmos.Json.JsonSerializationFormat,System.Int32,System.Boolean)">
            <summary>
            Creates a JsonWriter that can write in a particular JsonSerializationFormat (utf8 if text)
            </summary>
            <param name="jsonSerializationFormat">The JsonSerializationFormat of the writer.</param>
            <param name="initalCapacity">Initial capacity to help avoid intermeidary allocations.</param>
            <param name="enableEncodedStrings">Only applicable to the binary writer</param>
            <returns>A JsonWriter that can write in a particular JsonSerializationFormat</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteObjectStart">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteObjectEnd">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteArrayStart">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteArrayEnd">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteFieldName(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteFieldName(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteStringValue(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteStringValue(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteNumber64Value(Microsoft.Azure.Cosmos.Number64)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteBoolValue(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteNullValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteInt8Value(System.SByte)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteInt16Value(System.Int16)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteInt32Value(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteInt64Value(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteFloat32Value(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteFloat64Value(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteUInt32Value(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteGuidValue(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.WriteBinaryValue(System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.GetResult">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.CapturePreblittedBinaryJsonScope(System.Action{Microsoft.Azure.Cosmos.Json.ITypedBinaryJsonWriter})">
            <summary>
            Executes the provided lambda and captures a copy of the written bytes for reuse.
            The lambda is executed at a field name, and should leave the reader in a state where
            it is valid to end the scope.
            </summary>
            <param name="scopeWriter">Writes the contents of the scope.</param>
            <returns>Blitted bytes.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter">
            <summary>
            Concrete implementation of <see cref="T:Microsoft.Azure.Cosmos.Json.JsonWriter"/> that knows how to serialize to binary encoding.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.DollarTSystemString">
            <summary>
            '$t' encoded string.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.DollarVSystemString">
            <summary>
            '$v' encoded string.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.binaryWriter">
            <summary>
            Writer used to write fully materialized context to the internal stream.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.bufferedContexts">
            <summary>
            With binary encoding all the json elements are length prefixed,
            unfortunately the caller of this class only provides what tokens to write.
            This means that whenever a user call WriteObject/ArrayStart we don't know the length of said object or array
            until WriteObject/ArrayEnd is invoked.
            To get around this we reserve some space for the length and write to it when the user supplies the end token.
            This stack remembers for each nesting level where it begins and how many items it has.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.serializeCount">
            <summary>
            With binary encoding json elements like arrays and object are prefixed with a length in bytes and optionally a count.
            This flag just determines whether you want to serialize the count, since it's optional and up to the user to make the
            tradeoff between O(1) .Count() operation as the cost of additional storage.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.reservationSize">
            <summary>
            When a user writes an open array or object we reserve this much space for the type marker + length + count
            And correct it later when they write a close array or object.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.stringReferenceOffsets">
            <summary>
            Offsets at which string references offsets are stored.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.#ctor(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the JsonBinaryWriter class.
            </summary>
            <param name="initialCapacity">The initial capacity to avoid intermediary allocations.</param>
            <param name="serializeCount">Whether to serialize the count for object and array typemarkers.</param>
            <param name="enableEncodedStrings">enable reference string encoding</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.CurrentLength">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteObjectStart">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteObjectEnd">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteArrayStart">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteArrayEnd">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteFieldName(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteStringValue(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteNumber64Value(Microsoft.Azure.Cosmos.Number64)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteBoolValue(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteNullValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteInt8Value(System.SByte)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteInt16Value(System.Int16)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteInt32Value(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteInt64Value(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteFloat32Value(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteFloat64Value(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteUInt32Value(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteGuidValue(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteBinaryValue(System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.GetResult">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteDollarTBsonTypeDollarV(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.WriteDollarTBsonTypeDollarVNestedScope(System.Boolean,System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.Write(Microsoft.Azure.Cosmos.Json.PreblittedBinaryJsonScope)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonBinaryWriter.CapturePreblittedBinaryJsonScope(System.Int32)">
            <summary>
            Captures a preblitted binary JSON scope.
            This method is for use by <see cref="M:Microsoft.Azure.Cosmos.Json.JsonWriter.CapturePreblittedBinaryJsonScope(System.Action{Microsoft.Azure.Cosmos.Json.ITypedBinaryJsonWriter})"/>.
            </summary>
            <param name="startPosition">Scope start position.</param>
            <returns>A preblitted binary JSON scope.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter">
            <summary>
            This class is used to build a JSON string.
            It supports our defined IJsonWriter interface.
            It keeps an stack to keep track of scope, and provides error checking using that.
            It has few other variables for error checking
            The user can also provide initial size to reserve string buffer, that will help reduce cost of reallocation.
            It provides error checking based on JSON grammar. It provides escaping for nine characters specified in JSON.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.firstValue">
            <summary>
            Whether we are writing the first value of an array or object
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the JsonTextWriter class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.SerializationFormat">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.CurrentLength">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteObjectStart">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteObjectEnd">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteArrayStart">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteArrayEnd">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteFieldName(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteStringValue(Microsoft.Azure.Cosmos.Core.Utf8.Utf8Span)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteNumber64Value(Microsoft.Azure.Cosmos.Number64)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteBoolValue(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteNullValue">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteInt8Value(System.SByte)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteInt16Value(System.Int16)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteInt32Value(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteInt64Value(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteFloat32Value(System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteFloat64Value(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteUInt32Value(System.UInt32)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteGuidValue(System.Guid)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.WriteBinaryValue(System.ReadOnlySpan{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.JsonWriter.JsonTextWriter.GetResult">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.ObjectProperty">
            <summary>
            Struct to hold the property name and property value for an object property.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.ObjectProperty.#ctor(Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode,Microsoft.Azure.Cosmos.Json.IJsonNavigatorNode)">
            <summary>
            Initializes a new instance of the ObjectProperty struct.
            </summary>
            <param name="nameNode">The IJsonNavigatorNode to the node that holds the object property name.</param>
            <param name="valueNode">The IJsonNavigatorNode to the node that holds the object property value.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.ObjectProperty.NameNode">
            <summary>
            The node that holds the object property name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Json.ObjectProperty.ValueNode">
            <summary>
            The node that holds the object property value.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Json.PreblittedBinaryJsonScope">
            <summary>
            Holds a blitted binary JSON blob.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Json.PreblittedBinaryJsonScope.Bytes">
            <summary>
            Blitted bytes.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Json.PreblittedBinaryJsonScope.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Json.PreblittedBinaryJsonScope"/> struct.
            </summary>
            <param name="bytes">Preblitted binary json bytes.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.ChangeFeedQuery`1">
            <summary>
            Provides interface for historical change feed.
            </summary>
            <typeparam name="TResource">Source Resource Type (e.g. Document)</typeparam>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.ChangeFeedQuery`1.HasMoreResults">
            <summary>
            Gets a value indicating whether there are potentially additional results that can be retrieved.
            </summary>
            <value>Boolean value representing if whether there are potentially additional results that can be retrieved.</value>
            <remarks>Initially returns true. This value is set based on whether the last execution returned a continuation token.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ChangeFeedQuery`1.ExecuteNextAsync``1(System.Threading.CancellationToken)">
            <summary>
            Read feed and retrieves the next page of results in the Azure Cosmos DB service.
            </summary>
            <typeparam name="TResult">The type of the object returned in the query result.</typeparam>
            <returns>The Task object for the asynchronous response from query execution.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ChangeFeedQuery`1.ExecuteNextAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the query and retrieves the next page of results as dynamic objects in the Azure Cosmos DB service.
            </summary>
            <param name="cancellationToken">(Optional) The <see cref="T:System.Threading.CancellationToken"/> allows for notification that operations should be cancelled.</param>
            <returns>The Task object for the asynchronous response from query execution.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ConstantEvaluator.PartialEval(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Boolean})">
            <summary> 
            Performs evaluation and replacement of independent sub-trees 
            </summary> 
            <param name="expression">The root of the expression tree.</param>
            <param name="fnCanBeEvaluated">A function that decides whether a given expression node can be part of the local function.</param>
            <returns>A new tree with sub-trees evaluated and replaced.</returns> 
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ConstantEvaluator.PartialEval(System.Linq.Expressions.Expression)">
            <summary> 
            Performs evaluation and replacement of independent sub-trees 
            </summary> 
            <param name="expression">The root of the expression tree.</param>
            <returns>A new tree with sub-trees evaluated and replaced.</returns> 
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.ConstantFolding">
            <summary>
            Simplifies an Expression tree evaluating everything that can be evaluated 
            at the current time.  Could be more efficient by evaluating a complete constant subtree at once.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.CosmosLinq">
            <summary>
            This class provides methods for cosmos LINQ code.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinq.InvokeUserDefinedFunction(System.String,System.Object[])">
             <summary>
             Helper method to invoke User Defined Functions via Linq queries in the Azure Cosmos DB service.
             </summary>
             <param name="udfName">The UserDefinedFunction name</param>
             <param name="arguments">The arguments of the UserDefinedFunction</param>
             <remarks>
             This is a stub helper method for use within LINQ expressions. Cannot be called directly. 
             Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-linq-to-sql for more details about the LINQ provider.
             Refer to https://docs.microsoft.com/azure/cosmos-db/stored-procedures-triggers-udfs for more details about user defined functions.
             </remarks>
             <example> 
             <code language="c#">
             <![CDATA[
             // Equivalent to SELECT * FROM books b WHERE udf.toLowerCase(b.title) = 'war and peace'" 
             IQueryable<Book> queryable = client
                 .GetContainer("database", "container")
                 .GetItemLinqQueryable<Book>()
                 .Where(b => CosmosLinq.InvokeUserDefinedFunction("toLowerCase", b.Title) == "war and peace");
            
             FeedIterator<Book> bookIterator = queryable.ToFeedIterator();
             while (feedIterator.HasMoreResults)
             {
                 FeedResponse<Book> responseMessage = await feedIterator.ReadNextAsync();
                 DoSomethingWithResponse(responseMessage);
             }
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/>
             <returns>Placeholder for the udf result.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions">
            <summary>
            This class provides extension methods for cosmos LINQ code.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.IsDefined(System.Object)">
            <summary>
            Determines if a certain property is defined or not.
            This method is to be used in LINQ expressions only and will be evaluated on server.
            There's no implementation provided in the client library.
            </summary>
            <param name="obj"></param>
            <returns>Returns true if this property is defined otherwise returns false.</returns>
            <example>
            <code>
            <![CDATA[
            var isDefinedQuery = documents.Where(document => document.Name.IsDefined());
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.IsNull(System.Object)">
            <summary>
            Determines if a certain property is null or not.
            This method is to be used in LINQ expressions only and will be evaluated on server.
            There's no implementation provided in the client library.
            </summary>
            <param name="obj"></param>
            <returns>Returns true if this property is null otherwise returns false.</returns>
            <example>
            <code>
            <![CDATA[
            var isNullQuery = documents.Where(document => document.Name.IsNull());
            ]]>
            </code>
            </example>s>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.IsPrimitive(System.Object)">
            <summary>
            Determines if a certain property is of primitive JSON type.
            This method is to be used in LINQ expressions only and will be evaluated on server.
            There's no implementation provided in the client library.
            </summary>
            <param name="obj"></param>
            <returns>Returns true if this property is null otherwise returns false.</returns>
            <remarks>
            Primitive JSON types (Double, String, Boolean and Null)
            </remarks>
            <example>
            <code>
            <![CDATA[
            var isPrimitiveQuery = documents.Where(document => document.Name.IsPrimitive());
            ]]>
            </code>
            </example>s>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.ToQueryDefinition``1(System.Linq.IQueryable{``0},System.Collections.Generic.IDictionary{System.Object,System.String})">
             <summary>
             This method generate query definition from LINQ query.
             </summary>
             <typeparam name="T">the type of object to query.</typeparam>
             <param name="query">the IQueryable{T} to be converted.</param>
             <param name="namedParameters">Dictionary containing parameter value and name for parameterized query</param>
             <returns>The queryDefinition which can be used in query execution.</returns>
             <example>
             This example shows how to generate query definition from LINQ.
            
             <code language="c#">
             <![CDATA[
             IQueryable<T> queryable = container.GetItemsQueryIterator<T>(allowSynchronousQueryExecution = true)
                                  .Where(t => b.id.contains("test"));
             QueryDefinition queryDefinition = queryable.ToQueryDefinition();
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.ToQueryDefinition``1(System.Linq.IQueryable{``0})">
             <summary>
             This method generate query definition from LINQ query.
             </summary>
             <typeparam name="T">the type of object to query.</typeparam>
             <param name="query">the IQueryable{T} to be converted.</param>
             <returns>The queryDefinition which can be used in query execution.</returns>
             <example>
             This example shows how to generate query definition from LINQ.
            
             <code language="c#">
             <![CDATA[
             IQueryable<T> queryable = container.GetItemsQueryIterator<T>(allowSynchronousQueryExecution = true)
                                  .Where(t => b.id.contains("test"));
             QueryDefinition queryDefinition = queryable.ToQueryDefinition();
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.ToFeedIterator``1(System.Linq.IQueryable{``0})">
             <summary>
             This extension method gets the FeedIterator from LINQ IQueryable to execute query asynchronously.
             This will create the fresh new FeedIterator when called.
             </summary>
             <typeparam name="T">the type of object to query.</typeparam>
             <param name="query">the IQueryable{T} to be converted.</param>
             <returns>An iterator to go through the items.</returns>
             <example>
             This example shows how to get FeedIterator from LINQ.
            
             <code language="c#">
             <![CDATA[
             IOrderedQueryable<ToDoActivity> linqQueryable = this.Container.GetItemLinqQueryable<ToDoActivity>();
             using (FeedIterator<ToDoActivity> setIterator = linqQueryable.Where(item => (item.taskNum < 100)).ToFeedIterator()
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.ToStreamIterator``1(System.Linq.IQueryable{``0})">
             <summary>
             This extension method gets the FeedIterator from LINQ IQueryable to execute query asynchronously.
             This will create the fresh new FeedIterator when called.
             </summary>
             <typeparam name="T">the type of object to query.</typeparam>
             <param name="query">the IQueryable{T} to be converted.</param>
             <returns>An iterator to go through the items.</returns>
             <example>
             This example shows how to get FeedIterator from LINQ.
            
             <code language="c#">
             <![CDATA[
             IOrderedQueryable<ToDoActivity> linqQueryable = this.Container.GetItemLinqQueryable<ToDoActivity>();
             using (FeedIterator setIterator = linqQueryable.Where(item => (item.taskNum < 100)).ToFeedIterator()
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.MaxAsync``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
            Returns the maximum value in a generic <see cref="T:System.Linq.IQueryable`1" />.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the maximum of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The maximum value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.MinAsync``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
            Returns the minimum value in a generic <see cref="T:System.Linq.IQueryable`1" />.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">A sequence of values to determine the minimum of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The minimum value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Decimal},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Decimal" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Nullable{System.Decimal}},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Double},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Double" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Nullable{System.Double}},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Single},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Single" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Nullable{System.Single}},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Int32" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Nullable{System.Int32}},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Int64},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Int64" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.AverageAsync(System.Linq.IQueryable{System.Nullable{System.Int64}},System.Threading.CancellationToken)">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Decimal},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Decimal" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Nullable{System.Decimal}},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Double},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Double" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Nullable{System.Double}},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Single},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Single" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Nullable{System.Single}},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Int32" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Nullable{System.Int32}},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Int64},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Int64" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.SumAsync(System.Linq.IQueryable{System.Nullable{System.Int64}},System.Threading.CancellationToken)">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Nullable`1" /> values.
            </summary>
            <param name="source">A sequence of values to calculate the average of.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The average value in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqExtensions.CountAsync``1(System.Linq.IQueryable{``0},System.Threading.CancellationToken)">
            <summary>
            Returns the number of elements in a sequence.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <param name="source">The sequence that contains the elements to be counted.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The number of elements in the input sequence.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.CosmosLinqQuery`1">
            <summary>
            This is the entry point for LINQ query creation/execution, it generate query provider, implements IOrderedQueryable.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Linq.CosmosLinqQueryProvider"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqQuery`1.GetEnumerator">
            <summary>
            Retrieves an object that can iterate through the individual results of the query.
            </summary>
            <remarks>
            This triggers a synchronous multi-page load.
            </remarks>
            <returns>IEnumerator</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.CosmosLinqQuery`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Synchronous Multi-Page load
            </summary>
            <returns>IEnumerator</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.CosmosLinqQueryProvider">
            <summary> 
            This class serve as LINQ query provider implementing IQueryProvider.
            </summary> 
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.DocumentQuery`1.HasMoreResults">
            <summary>
            Gets a value indicating whether there are additional results to retrieve. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.DocumentQuery`1.CorrelatedActivityId">
            <summary>
            Gets the unique ID for this instance of DocumentQuery used to correlate all activityIds generated when fetching from a partition collection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQuery`1.ExecuteNextAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the query to retrieve the next page of results.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQuery`1.ExecuteNextAsync``1(System.Threading.CancellationToken)">
            <summary>
            Executes the query to retrieve the next page of results.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQuery`1.GetEnumerator">
            <summary>
            Retrieves an object that can iterate through the individual results of the query.
            </summary>
            <remarks>
            This triggers a synchronous multi-page load.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQuery`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Synchronous Multi-Page load
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.DocumentQueryable">
            <summary>
            This class provides extension methods for converting a <see cref="T:System.Linq.IQueryable`1"/> object to a <see cref="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1"/> object.
            </summary>
            <remarks>
             The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class provides implementation of standard query methods for querying resources in Azure Cosmos DB. 
             These methods enable you to express traversal, filter, and projection operations over data persisted in the Azure Cosmos DB service.  They are defined as methods that 
             extend IQueryable, and do not perform any querying directly.  Instead, their functionality is to create queries 
             based the resource and query expression provided.  The actual query execution occurs when enumeration forces the expression tree associated with an IQueryable object to be executed.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.IDocumentClient"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentClient"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQueryable.AsDocumentQuery``1(System.Linq.IQueryable{``0})">
            <summary>
            Converts an IQueryable to IDocumentQuery which supports pagination and asynchronous execution in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">the type of object to query.</typeparam>
            <param name="query">the IQueryable{T} to be converted.</param>
            <returns>An IDocumentQuery{T} that can evaluate the query.</returns>
            <example>
            This example shows how to run a query asynchronously using the AsDocumentQuery() interface.
            
            <code language="c#">
            <![CDATA[
            using (var queryable = client.CreateDocumentQuery<Book>(
                collectionLink,
                new FeedOptions { MaxItemCount = 10 })
                .Where(b => b.Title == "War and Peace")
                .AsDocumentQuery())
            {
                while (queryable.HasMoreResults) 
                {
                    foreach(Book b in await queryable.ExecuteNextAsync<Book>())
                    {
                        // Iterate through books
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQueryEvaluator.HandleEmptyQuery(System.Linq.Expressions.ConstantExpression)">
            <summary>
            This is to handle the case, where user just executes code like this.
            foreach(Database db in client.CreateDatabaseQuery()) {}        
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQueryEvaluator.HandleAsSqlTransformExpression(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            foreach(string record in client.CreateDocumentQuery().Navigate("Raw JQuery"))
            </summary>
            <param name="expression"></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.DocumentQueryException">
            <summary> 
            Represents an exception from the Azure Cosmos DB service queries.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQueryException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.Linq.DocumentQueryException"/> class in the Azure Cosmos DB service.</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQueryException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.Linq.DocumentQueryException"/> class in the Azure Cosmos DB service.</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.DocumentQueryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.Linq.DocumentQueryException"/> class.
            </summary>
            <param name="info">The serialization info.</param>
            <param name="context">The streaming context.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.ExpressionToSql">
            <summary>
            Core Linq to DocDBSQL translator.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.TranslateQuery(System.Linq.Expressions.Expression,System.Collections.Generic.IDictionary{System.Object,System.String},Microsoft.Azure.Cosmos.CosmosLinqSerializerOptions)">
            <summary>
            Toplevel entry point.
            </summary>
            <param name="inputExpression">An Expression representing a Query on a IDocumentQuery object.</param>
            <param name="parameters">Optional dictionary for parameter name and value</param>
            <param name="linqSerializerOptions">Optional serializer options.</param>
            <returns>The corresponding SQL query.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.Translate(System.Linq.Expressions.Expression,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Translate an expression into a query.
            Query is constructed as a side-effect in context.currentQuery.
            </summary>
            <param name="inputExpression">Expression to translate.</param>
            <param name="context">Context for translation.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.GetBindingParameterName(Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Get a paramter name to be binded to the a collection from the next lambda.
            It's merely for readability purpose. If that is not possible, use a default 
            parameter name.
            </summary>
            <param name="context">The translation context</param>
            <returns>A parameter name</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitNonSubqueryScalarExpression(System.Linq.Expressions.Expression,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Visitor which produces a SqlScalarExpression.
            </summary>
            <param name="inputExpression">Expression to visit.</param>
            <param name="context">Context information.</param>
            <returns>The translation as a ScalarExpression.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.ConvertToScalarAnyCollection(Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Convert the context's current query to a scalar Any collection
            by wrapping it as following: SELECT VALUE COUNT(v0) > 0 FROM (current query) AS v0.
            This is used in cases where LINQ expression ends with Any() which is a boolean scalar.
            Normally Any would translate to SELECT VALUE EXISTS() subquery. However that wouldn't work
            for these cases because it would result in a boolean value for each row instead of 
            one single "aggregated" boolean value.
            </summary>
            <param name="context">The translation context</param>
            <returns>The scalar Any collection</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitCollectionLambda(System.Linq.Expressions.LambdaExpression,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Visit a lambda which is supposed to return a collection.
            </summary>
            <param name="lambdaExpression">LambdaExpression with a result which is a collection.</param>
            <param name="context">The translation context.</param>
            <returns>The collection computed by the lambda.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitMemberAccessCollectionExpression(System.Linq.Expressions.Expression,Microsoft.Azure.Cosmos.Linq.TranslationContext,System.String)">
            <summary>
            Visit an expression, usually a MemberAccess, then trigger parameter binding for that expression.
            </summary>
            <param name="inputExpression">The input expression</param>
            <param name="context">The current translation context</param>
            <param name="parameterName">Parameter name is merely for readability</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitMethodCall(System.Linq.Expressions.MethodCallExpression,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Visit a method call, construct the corresponding query in context.currentQuery.
            At ExpressionToSql point only LINQ method calls are allowed.
            These methods are static extension methods of IQueryable or IEnumerable.
            </summary>
            <param name="inputExpression">Method to translate.</param>
            <param name="context">Query translation context.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.IsSubqueryScalarExpression(System.Linq.Expressions.Expression,System.Nullable{Microsoft.Azure.Cosmos.Linq.ExpressionToSql.SubqueryKind}@,System.Boolean@)">
            <summary>
            Determine if an expression should be translated to a subquery.
            This only applies to expression that is inside a lamda.
            </summary>
            <param name="expression">The input expression</param>
            <param name="expressionObjKind">The expression object kind of the expression</param>
            <param name="isMinMaxAvgMethod">True if the method is either Min, Max, or Avg</param>
            <returns>True if subquery is needed, otherwise false</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitScalarExpression(System.Linq.Expressions.LambdaExpression,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Visit an lambda expression which is in side a lambda and translate it to a scalar expression or a subquery scalar expression.
            See the other overload of this method for more details.
            </summary>
            <param name="lambda">The input lambda expression</param>
            <param name="context">The translation context</param>
            <returns>A scalar expression representing the input expression</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitScalarExpression(System.Linq.Expressions.Expression,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Visit an lambda expression which is in side a lambda and translate it to a scalar expression or a collection scalar expression.
            If it is a collection scalar expression, e.g. should be translated to subquery such as SELECT VALUE ARRAY, SELECT VALUE EXISTS, 
            SELECT VALUE [aggregate], the subquery will be aliased to a new binding for the FROM clause. E.g. consider 
            Select(family => family.Children.Select(child => child.Grade)). Since the inner Select corresponds to a subquery, this method would 
            create a new binding of v0 to the subquery SELECT VALUE ARRAY(), and the inner expression will be just SELECT v0.
            </summary>
            <param name="expression">The input expression</param>
            <param name="context">The translation context</param>
            <returns>A scalar expression representing the input expression</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.VisitScalarExpression(System.Linq.Expressions.Expression,System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Visit an lambda expression which is in side a lambda and translate it to a scalar expression or a collection scalar expression.
            See the other overload of this method for more details.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.CreateSubquerySqlCollection(Microsoft.Azure.Cosmos.SqlObjects.SqlQuery,Microsoft.Azure.Cosmos.Linq.TranslationContext,Microsoft.Azure.Cosmos.Linq.ExpressionToSql.SubqueryKind)">
            <summary>
            Create a subquery SQL collection object for a SQL query
            </summary>
            <param name="query">The SQL query object</param>
            <param name="context">The translation context</param>
            <param name="subqueryType">The subquery type</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.CreateSubquery(System.Linq.Expressions.Expression,System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression},Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Create a subquery from a subquery scalar expression.
            By visiting the collection expression, this builds a new QueryUnderConstruction on top of the current one
            and then translate it to a SQL query while keeping the current QueryUnderConstruction in tact.
            </summary>
            <param name="expression">The subquery scalar expression</param>
            <param name="parameters">The list of parameters of the expression</param>
            <param name="context">The translation context</param>
            <returns>A query corresponding to the collection expression</returns>
            <remarks>The QueryUnderConstruction remains unchanged after this.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.ExpressionToSql.ConvertPropertyRefToPath(Microsoft.Azure.Cosmos.SqlObjects.SqlPropertyRefScalarExpression)">
            <summary>
            Property references that refer to array-valued properties are converted to collection references.
            </summary>
            <param name="propRef">Property reference object.</param>
            <returns>An inputPathCollection which contains the same property path as the propRef.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.GeometrySqlExpressionFactory">
            <summary>
            Constructs <see cref="T:Microsoft.Azure.Cosmos.SqlObjects.SqlScalarExpression"/> from a geometry <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.GeometrySqlExpressionFactory.Construct(System.Linq.Expressions.Expression)">
            <summary>
            Constructs <see cref="T:Microsoft.Azure.Cosmos.SqlObjects.SqlScalarExpression"/> from a geometry <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
            <param name="geometryExpression">
            Expression of type <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/>.
            </param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Cosmos.SqlObjects.SqlScalarExpression"/> representing geometry <paramref name="geometryExpression"/>.</returns>.
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.GeometrySqlExpressionFactory.FromJToken(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Constructs <see cref="T:Microsoft.Azure.Cosmos.SqlObjects.SqlScalarExpression"/> from a geometry <see cref="T:Newtonsoft.Json.Linq.JToken"/>.
            </summary>
            <param name="jToken">Json token.</param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Cosmos.SqlObjects.SqlScalarExpression"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.Nominator">
            <summary> 
            Performs bottom-up analysis to determine which nodes can possibly 
            be part of an evaluated sub-tree. 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction">
            <summary>
            Query that is being constructed.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.fromParameters">
            <summary>
            Binding for the FROM parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.Alias">
            <summary>
            The parameter expression to be used as this query's alias.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.inputQuery">
            <summary>
            Input subquery.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.CreateFrom(Microsoft.Azure.Cosmos.SqlObjects.SqlCollectionExpression)">
            <summary>
            Create a FROM clause from a set of FROM parameter bindings.
            </summary>
            <returns>The created FROM clause.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.GetSqlQuery">
            <summary>
            Convert the entire query to a SQL Query.
            </summary>
            <returns>The corresponding SQL Query.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.PackageQuery(System.Collections.Generic.HashSet{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Create a new QueryUnderConstruction node that take the current query as its input
            </summary>
            <param name="inScope">The current context's parameters scope</param>
            <returns>The new query node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.FlattenAsPossible">
            <summary>
            Find and flatten the prefix set of queries into a single query by substituting their expressions.
            </summary>
            <returns>The query that has been flatten</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.Flatten">
            <summary>
            Flatten subqueries into a single query by substituting their expressions in the current query.
            </summary>
            <returns>A flattened query.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.ShouldBeOnNewQuery(System.String,System.Int32)">
            <summary>
            Determine if the current method call should create a new QueryUnderConstruction node or not.
            </summary>
            <param name="methodName">The current method name</param>
            <param name="argumentCount">The method's parameter count</param>
            <returns>True if the current method should be in a new query node</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.AddSelectClause(Microsoft.Azure.Cosmos.SqlObjects.SqlSelectClause)">
            <summary>
            Add a Select clause to a query, without creating a new subquery
            </summary>
            <param name="select">The Select clause to add</param>
            <returns>A new query containing a select clause.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.AddSelectClause(Microsoft.Azure.Cosmos.SqlObjects.SqlSelectClause,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Add a Select clause to a query; may need to create a new subquery.
            </summary>
            <param name="select">Select clause to add.</param>
            <param name="context">The translation context.</param>
            <returns>A new query containing a select clause.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.AddWhereClause(Microsoft.Azure.Cosmos.SqlObjects.SqlWhereClause,Microsoft.Azure.Cosmos.Linq.TranslationContext)">
            <summary>
            Add a Where clause to a query; may need to create a new query.
            </summary>
            <param name="whereClause">Clause to add.</param>
            <param name="context">The translation context.</param>
            <returns>A new query containing the specified Where clause.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.GetSubquery(Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction)">
            <summary>
            Separate out the query branch, which makes up a subquery and is built on top of the parent query chain.
            E.g. Let the query chain at some point in time be q0 - q1 - q2. When a subquery is recognized, its expression is visited.
            Assume that adds 2 queries to the chain to q0 - q1 - q2 - q3 - q4. Invoking q4.GetSubquery(q2) would return q3 - q4
            after it's isolated from the rest of the chain.
            </summary>
            <param name="queryBeforeVisit">The last query in the chain before the collection expression is visited</param>
            <returns>The subquery that has been decoupled from the parent query chain</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.HasSelectAggregate">
            <summary>
            Check whether the current SELECT clause has an aggregate function
            </summary>
            <returns>true if the selectClause has an aggregate function call</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.QueryUnderConstruction.ToString">
            <summary>
            Debugging string.
            </summary>
            <returns>Query representation as a string (not legal SQL).</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.SqlTranslator">
            <summary>
            Wrapper class for translating LINQ to DocDB SQL.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.SqlTranslator.TranslateExpression(System.Linq.Expressions.Expression,Microsoft.Azure.Cosmos.CosmosLinqSerializerOptions)">
            <summary>
            This function exists for testing only.
            </summary>
            <param name="inputExpression">Expression to translate.</param>
            <param name="linqSerializerOptions">Optional serializer options.</param>
            <returns>A string describing the expression translation.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.SubtreeEvaluator">
            <summary> 
            Evaluates and replaces sub-trees when first candidate is reached (top-down) 
            </summary> 
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.TranslationContext">
            <summary>
            Used by the Expression tree visitor.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.memberNames">
            <summary>
            Member names for special mapping cases
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.InScope">
            <summary>
            Set of parameters in scope at any point; used to generate fresh parameter names if necessary.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.currentQuery">
            <summary>
            Query that is being assembled.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.parameters">
            <summary>
            Dictionary for parameter name and value
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.substitutions">
            <summary>
            If the FROM clause uses a parameter name, it will be substituted for the parameter used in 
            the lambda expressions for the WHERE and SELECT clauses.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.methodStack">
            <summary>
            We are currently visiting these methods.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.lambdaParametersStack">
            <summary>
            Stack of parameters from lambdas currently in scope.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.collectionStack">
            <summary>
            Stack of collection-valued inputs.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.TranslationContext.subqueryBindingStack">
            <summary>
            The stack of subquery binding information.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PushParameter(System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Called when visiting a lambda with one parameter.
            Binds this parameter with the last collection visited.
            </summary>
            <param name="parameter">New parameter.</param>
            <param name="shouldBeOnNewQuery">Indicate if the parameter should be in a new QueryUnderConstruction clause</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PopParameter">
            <summary>
            Remove a parameter from the stack.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PushMethod(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Called when visiting a new MethodCall.
            </summary>
            <param name="method">Method that is being visited.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PopMethod">
            <summary>
            Called when finished visiting a MethodCall.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PeekMethod">
            <summary>
            Return the top method in the method stack
            This is used only to determine the parameter name that the user provides in the lamda expression
            for readability purpose.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PushCollection(Microsoft.Azure.Cosmos.Linq.Collection)">
            <summary>
            Called when visiting a LINQ Method call with the input collection of the method.
            </summary>
            <param name="collection">Collection that is the input to a LINQ method.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.SetInputParameter(System.Type,System.String)">
            <summary>
            Sets the parameter used to scan the input.
            </summary>
            <param name="type">Type of the input parameter.</param>
            <param name="name">Suggested name for the input parameter.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.SetFromParameter(System.Linq.Expressions.ParameterExpression,Microsoft.Azure.Cosmos.SqlObjects.SqlCollection)">
            <summary>
            Sets the parameter used by the this.fromClause if it is not already set.
            </summary>
            <param name="parameter">Parameter to set for the FROM clause.</param>
            <param name="collection">Collection to bind parameter to.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.IsInMainBranchSelect">
            <summary>
            Gets whether the context is currently in a Select method at top level or not.
            Used to determine if a paramter should be an input parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.PackageCurrentQueryIfNeccessary">
            <summary>
            Create a new QueryUnderConstruction node if indicated as neccesary by the subquery binding 
            </summary>
            <returns>The current QueryUnderConstruction after the package query call if necessary</returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.TranslationContext.SubqueryBinding.ShouldBeOnNewQuery">
            <summary>
            Indicates if the current query should be on a new QueryUnderConstruction
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.TranslationContext.SubqueryBinding.NewBindings">
            <summary>
            Indicates the new bindings that are introduced when visiting the subquery
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TranslationContext.SubqueryBinding.TakeBindings">
            <summary>
            Consume all the bindings
            </summary>
            <returns>All the current bindings</returns>
            <remarks>The binding list is reset after this operation.</remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.ParameterSubstitution">
            <summary>
            Maintains a map from parameters to expressions.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.MemberNames">
            <summary>
            Special member names for mapping
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.MemberNames.Value">
            <summary>
            HasValue for mapping <see cref="P:System.Nullable`1.Value"/>
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.MemberNames.HasValue">
            <summary>
            HasValue for mapping <see cref="P:System.Nullable`1.HasValue"/>
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.FromParameterBindings">
            <summary>
            Bindings for a set of parameters used in a FROM expression.
            Each parameter is bound to a collection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.Binding">
            <summary>
            Binding for a single parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.Binding.Parameter">
            <summary>
            Parameter defined by FROM clause
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.Binding.ParameterDefinition">
            <summary>
            How parameter is defined (may be null).  
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.Binding.IsInCollection">
            <summary>
            If true this corresponds to the clause `Parameter IN ParameterDefinition'
            else this corresponds to the clause `ParameterDefinition Parameter'
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.Binding.IsInputParameter">
            <summary>
            True if a binding should be an input paramter for the next transformation. 
            E.g. in Select(f -> f.Children).Select(), if the lambda's translation is
            a subquery SELECT VALUE ARRAY() with alias v0 then v0 should be the input of the second Select.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.ParameterDefinitions">
            <summary>
            The list of parameter definitions.  This will generate a FROM clause of the shape:
            FROM ParameterDefinitions[0] JOIN ParameterDefinitions[1] ... ParameterDefinitions[n]
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.#ctor">
            <summary>
            Create empty parameter bindings.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.SetInputParameter(System.Type,System.String,System.Collections.Generic.HashSet{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Sets the parameter which iterates over the outer collection.
            </summary> 
            <param name="parameterType">Parameter type.</param>
            <param name="parameterName">Hint for name.</param>
            <param name="inScope">List of parameter names currently in scope.</param>
            <returns>The name of the parameter which iterates over the outer collection.  
            If the name is already set it will return the existing name.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.FromParameterBindings.GetInputParameter">
            <summary>
            Get the input parameter.
            </summary>
            <returns>The input parameter.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.Collection">
            <summary>
            There are two types of collections: outer and inner.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.Collection.#ctor(System.String)">
            <summary>
            Creates an outer collection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.TypeSystem.IsAnonymousType(System.Type)">
            <summary>
            True if type is anonymous.
            </summary>
            <param name="type">Type to check.</param>
            <returns>Trye if the type is anonymous.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.Utilities.SqlQuoteString(System.String)">
            <summary>
            Add quotation signs to a string.
            </summary>
            <param name="toQuote">String to quote.</param>
            <returns>A string properly quoted for embedding into SQL.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.Utilities.GetLambda(System.Linq.Expressions.Expression)">
            <summary>
            Get a lambda expression; may unpeel quotes.
            </summary> 
            <param name="expr">Expression to convert to a lambda.</param>
            <returns>The contained lambda expression, or an exception.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.Utilities.NewParameter(System.String,System.Type,System.Collections.Generic.HashSet{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Generate a new parameter and add it to the current scope.
            </summary>
            <param name="prefix">Prefix for the parameter name.</param>
            <param name="type">Parameter type.</param>
            <param name="inScope">Names to avoid.</param>
            <returns>The new parameter.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery">
            <summary>
            Provides methods to support query pagination and asynchronous execution in the Azure Cosmos DB service.
            </summary> 
            <remarks>
            Untyped interface with no methods.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1">
            <summary>
            Provides methods to support query pagination and asynchronous execution in the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">Source Query Type</typeparam>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1.HasMoreResults">
            <summary>
            Gets a value indicating whether there are potentially additional results that can be 
            returned from the query in the Azure Cosmos DB service.
            </summary>
            <value>Boolean value representing if there are potentially additional results that can be 
            returned from the query.</value>
            <remarks>Initially returns true. This value is set based on whether the last execution returned a continuation token.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1.ExecuteNextAsync``1(System.Threading.CancellationToken)">
            <summary>
            Executes the query and retrieves the next page of results in the Azure Cosmos DB service.
            </summary>
            <typeparam name="TResult">The type of the object returned in the query result.</typeparam>
            <param name="token">(Optional) The <see cref="T:System.Threading.CancellationToken"/> allows for notification that operations should be cancelled.</param>
            <returns>The Task object for the asynchronous response from query execution.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Linq.IDocumentQuery`1.ExecuteNextAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the query and retrieves the next page of results as dynamic objects in the Azure Cosmos DB service.
            </summary>
            <param name="token">(Optional) The <see cref="T:System.Threading.CancellationToken"/> allows for notification that operations should be cancelled.</param>
            <returns>The Task object for the asynchronous response from query execution.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.MediaOptions">
            <summary> 
            Options used with attachment content (aka media) creation in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaOptions.Slug">
            <summary>
            Gets or sets the Slug header in the Azure Cosmos DB service.
            </summary>
            <value>
            The slug header.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaOptions.ContentType">
            <summary>
            Gets or sets the ContentType header in the Azure Cosmos DB service.
            </summary>
            <value>
            The ContentType header
            </value>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.MediaReadMode">
            <summary> 
            Represents the mode for use with downloading attachment content (a.k.a. media) in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.MediaReadMode.Buffered">
            <summary>
            Content is buffered at the client and not directly streamed from the content store. Use Buffered to reduce the time taken to read and write media files.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.MediaReadMode.Streamed">
            <summary>
            Content is directly streamed from the content store without any buffering at the client. Use Streamed to reduce the client memory overhead of reading and writing media files.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.MediaResponse">
            <summary>
            Represents the response associated with retrieving attachment content from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MediaResponse.#ctor">
            <summary>
            Constructor exposed for mocking purposes for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.ActivityId">
            <summary> 
            Gets or sets the Activity ID for the request in the Azure Cosmos DB service.
            </summary>
            <value>The Activity ID for the request.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.Media">
            <summary>
            Gets or sets the attachment content stream in the Azure Cosmos DB service.
            </summary>
            <value>The attachment content stream.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.Slug">
            <summary>
            Gets or sets the HTTP slug header value in the Azure Cosmos DB service.
            </summary>
            <value>The HTTP slug header value.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.ContentType">
            <summary>
            Gets or sets the HTTP ContentType header value in the Azure Cosmos DB service.
            </summary>
            <value>The HTTP ContentType header value.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.ContentLength">
            <summary>
            Gets or sets the HTTP ContentLength header value in the Azure Cosmos DB service.
            </summary>
            <value>The HTTP ContentLength header value.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.MaxMediaStorageUsageInMB">
            <summary>
            Gets the attachment content (media) storage quota in megabytes from the Azure Cosmos DB service.
            Retrieved from gateway.
            </summary>
            <value>The attachment content (media) storage quota in megabytes.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.CurrentMediaStorageUsageInMB">
            <summary>
            Gets the current attachment content (media) usage in megabytes from the Azure Cosmos DB service.
            </summary>
            <value>The current attachment content (media) usage in megabytes.</value>
            <remarks>This value is retrieved from the gateway.
            The value is returned from
            cached information updated periodically and is not guaranteed to be real time.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.MediaResponse.ResponseHeaders">
            <summary>
            Gets the headers associated with the response from the Azure Cosmos DB service.
            </summary>
            <value>The headers associated with the response.</value>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.MurmurHash3">
            <summary>
            MurmurHash3 for x64 (Little Endian).
            <p>Reference: https://en.wikipedia.org/wiki/MurmurHash <br /></p>
            <p>
            This implementation provides span-based access for hashing content not available in a
            <see cref="T:byte[]" />
            </p>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash32(System.String,System.UInt32)">
            <summary>MurmurHash3 32-bit implementation for strings.</summary>
            <param name="value">The string to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 32-bit hash.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash32(System.Boolean,System.UInt32)">
            <summary>MurmurHash3 32-bit implementation for booleans.</summary>
            <param name="value">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 32-bit hash.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash32``1(``0,System.UInt32)">
            <summary>MurmurHash3 32-bit implementation.</summary>
            <param name="value">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 32-bit hash.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash32(System.ReadOnlySpan{System.Byte},System.UInt32)">
            <summary>MurmurHash3 32-bit implementation.</summary>
            <param name="span">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 32-bit hash.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash128(System.String,Microsoft.Azure.Cosmos.UInt128)">
            <summary>MurmurHash3 128-bit implementation.</summary>
            <param name="value">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 128-bit hash represented as two 64-bit words.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash128(System.Boolean,Microsoft.Azure.Cosmos.UInt128)">
            <summary>MurmurHash3 128-bit implementation.</summary>
            <param name="value">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 128-bit hash represented as two 64-bit words.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash128``1(``0,Microsoft.Azure.Cosmos.UInt128)">
            <summary>MurmurHash3 128-bit implementation.</summary>
            <param name="value">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 128-bit hash represented as two 64-bit words.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.MurmurHash3.Hash128(System.ReadOnlySpan{System.Byte},Microsoft.Azure.Cosmos.UInt128)">
            <summary>MurmurHash3 128-bit implementation.</summary>
            <param name="span">The data to hash.</param>
            <param name="seed">The seed to initialize with.</param>
            <returns>The 128-bit hash represented as two 64-bit words.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Number64">
            <summary>
            Struct that represents either a double or 64 bit int
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Number64.MaxValue">
            <summary>
            Maximum Number64.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Number64.MinValue">
            <summary>
            Maximum Number64.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Number64.doubleValue">
            <summary>
            The double if the value is a double.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Number64.longValue">
            <summary>
            The long if the value is a long.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_LessThan(Microsoft.Azure.Cosmos.Number64,Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns if one Number64 is less than another Number64.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is less than right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_GreaterThan(Microsoft.Azure.Cosmos.Number64,Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns if one Number64 is greater than another Number64.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is greater than right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_LessThanOrEqual(Microsoft.Azure.Cosmos.Number64,Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns if one Number64 is less than or equal to another Number64.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is less than or equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_GreaterThanOrEqual(Microsoft.Azure.Cosmos.Number64,Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns if one Number64 is greater than or equal to another Number64.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is greater than or equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_Equality(Microsoft.Azure.Cosmos.Number64,Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns if two Number64 are equal.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether the left is equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_Inequality(Microsoft.Azure.Cosmos.Number64,Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns if two Number64 are not equal.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether the left is not equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_Implicit(System.Int64)~Microsoft.Azure.Cosmos.Number64">
            <summary>
            Implicitly converts a long to Number64.
            </summary>
            <param name="value">The long to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.op_Implicit(System.Double)~Microsoft.Azure.Cosmos.Number64">
            <summary>
            Implicitly converts a double to Number64.
            </summary>
            <param name="value">The double to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.CompareTo(System.Object)">
            <summary>
            Compares this value to an object.
            </summary>
            <param name="value">The value to compare to.</param>
            <returns>The comparison.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.CompareTo(Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Compares this Number64 to another instance of the Number64 type.
            </summary>
            <param name="other">The other instance to compare to.</param>
            <returns>
            A negative number if this instance is less than the other instance.
            Zero if they are the same.
            A positive number if this instance is greater than the other instance.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.Equals(System.Object)">
            <summary>
            Returns whether this instance equals another object.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>Whether this instance equals another object.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.Equals(Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Returns whether this Number64 equals another Number64.
            </summary>
            <param name="other">The Number64 to compare to.</param>
            <returns>Whether this Number64 equals another Number64.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.GetHashCode">
            <summary>
            Gets a hash code for this instance.
            </summary>
            <returns>The hash code for this instance.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Number64.DoubleEx">
            <summary>
            Represents an extended double number with 62-bit mantissa which is capable of representing a 64-bit integer with no precision loss
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Number64.DoubleEx.DoubleValue">
            <summary>
            The double if the value is a double.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Number64.DoubleEx.ExtraBits">
            <summary>
            The long if the value is a long.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_Equality(Microsoft.Azure.Cosmos.Number64.DoubleEx,Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns if two DoubleEx are equal.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether the left is equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_Inequality(Microsoft.Azure.Cosmos.Number64.DoubleEx,Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns if two DoubleEx are not equal.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether the left is not equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_LessThan(Microsoft.Azure.Cosmos.Number64.DoubleEx,Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns if one DoubleEx is less than another DoubleEx.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is less than right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_GreaterThan(Microsoft.Azure.Cosmos.Number64.DoubleEx,Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns if one DoubleEx is greater than another DoubleEx.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is greater than right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_LessThanOrEqual(Microsoft.Azure.Cosmos.Number64.DoubleEx,Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns if one DoubleEx is less than or equal to another DoubleEx.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is less than or equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_GreaterThanOrEqual(Microsoft.Azure.Cosmos.Number64.DoubleEx,Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns if one Number64 is greater than or equal to another Number64.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is greater than or equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_Implicit(System.Int64)~Microsoft.Azure.Cosmos.Number64.DoubleEx">
            <summary>
            Implicitly converts a long to DoubleEx.
            </summary>
            <param name="value">The int to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_Implicit(Microsoft.Azure.Cosmos.Number64.DoubleEx)~System.Int64">
            <summary>
            Implicitly converts a DoubleEx to long.
            </summary>
            <param name="value">The int to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.op_Implicit(System.Double)~Microsoft.Azure.Cosmos.Number64.DoubleEx">
            <summary>
            Implicitly converts a double to DoubleEx.
            </summary>
            <param name="value">The int to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.Equals(System.Object)">
            <summary>
            Returns whether this instance equals another object.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>Whether this instance equals another object.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.Equals(Microsoft.Azure.Cosmos.Number64.DoubleEx)">
            <summary>
            Returns whether this DoubleEx equals another DoubleEx.
            </summary>
            <param name="other">The DoubleEx to compare to.</param>
            <returns>Whether this DoubleEx equals another DoubleEx.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Number64.DoubleEx.GetHashCode">
            <summary>
            Gets a hash code for this instance.
            </summary>
            <returns>The hash code for this instance.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Pagination.CrossPartitionRangePageAsyncEnumerator`2">
            <summary>
            Coordinates draining pages from multiple <see cref="T:Microsoft.Azure.Cosmos.Pagination.PartitionRangePageAsyncEnumerator`2"/>, while maintaining a global sort order and handling repartitioning (splits, merge).
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Pagination.DocumentContainer">
            <summary>
            Composes a <see cref="T:Microsoft.Azure.Cosmos.Pagination.IMonadicDocumentContainer"/> and creates an <see cref="T:Microsoft.Azure.Cosmos.Pagination.IDocumentContainer"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Pagination.PartitionRangePageAsyncEnumerator`2">
            <summary>
            Has the ability to page through a partition range.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PartitionKey">
            <summary>
            Represents a partition key value in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PartitionKey.None">
            <summary>
            The returned object represents a partition key value that allows creating and accessing items
            without a value for partition key.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PartitionKey.Null">
            <summary>
            The returned object represents a partition key value that allows creating and accessing items
            with a null value for the partition key.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PartitionKey.SystemKeyName">
            <summary>
            The tag name to use in the documents for specifying a partition key value
            when inserting such documents into a migrated collection
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PartitionKey.SystemKeyPath">
            <summary>
            The partition key path in the collection definition for migrated collections
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKey.InternalKey">
            <summary>
            Gets the value provided at initialization.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PartitionKey.IsNone">
            <summary>
            Gets the boolean to verify partitionKey is None.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.#ctor(System.String)">
            <summary>
            Creates a new partition key value.
            </summary>
            <param name="partitionKeyValue">The value to use as partition key.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.#ctor(System.Boolean)">
            <summary>
            Creates a new partition key value.
            </summary>
            <param name="partitionKeyValue">The value to use as partition key.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.#ctor(System.Double)">
            <summary>
            Creates a new partition key value.
            </summary>
            <param name="partitionKeyValue">The value to use as partition key.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.#ctor(System.Object)">
            <summary>
            Creates a new partition key value.
            </summary>
            <param name="value">The value to use as partition key.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.#ctor(Microsoft.Azure.Documents.Routing.PartitionKeyInternal)">
            <summary>
            Creates a new partition key value.
            </summary>
            <param name="partitionKeyInternal">The value to use as partition key.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.#ctor(Microsoft.Azure.Documents.Routing.PartitionKeyInternal,System.Boolean)">
            <summary>
            Creates a new partition key value.
            </summary>
            <param name="partitionKeyInternal">The value to use as partition key.</param>
            <param name="isNone">The value to decide partitionKey is None.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="obj">An object to compare.</param>
            <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.GetHashCode">
            <summary>
            Returns the hash code for this partition key.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.Equals(Microsoft.Azure.Cosmos.PartitionKey)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified partition key.
            </summary>
            <param name="other">A partition key value to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.ToString">
            <summary>
            Gets the string representation of the partition key value.
            </summary>
            <returns>The string representation of the partition key value</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.op_Equality(Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.PartitionKey)">
            <summary>
            Determines whether two specified instances of the PartitionKey are equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if <paramref name="left"/> and <paramref name="right"/> represent the same partition key; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKey.op_Inequality(Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.PartitionKey)">
            <summary>
            Determines whether two specified instances of the PartitionKey are not equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>true if <paramref name="left"/> and <paramref name="right"/> do not represent the same partition key; otherwise, false.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PartitionKeyBuilder">
            <summary>
            Represents a partition key value list in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.#ctor">
            <summary>
            Creates a new partition key value list object.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.Add(System.String)">
            <summary>
            Adds a partition key value of type string to the list.
            </summary>
            <param name="val">The value of type string to be used as partition key.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyBuilder"/> to use. </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.Add(System.Double)">
            <summary>
            Adds a partition key value of type double to the list.
            </summary>
            <param name="val">The value of type double to be used as partition key.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyBuilder"/> to use. </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.Add(System.Boolean)">
            <summary>
            Adds a partition key value of type bool to the list.
            </summary>
            <param name="val">The value of type bool to be used as partition key.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyBuilder"/> to use. </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.AddNullValue">
            <summary>
            Adds a partition key value which is null
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyBuilder"/> to use. </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.AddNoneType">
            <summary>
            Adds a None partition key value.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyBuilder"/> to use. </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyBuilder.Build">
            <summary>
            Builds a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> with the specified Partition Key values.
            </summary>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyMismatchRetryPolicy.ShouldRetryAsync(System.Exception,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="exception">Exception that occured when the operation was tried</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyMismatchRetryPolicy.ShouldRetryAsync(Microsoft.Azure.Cosmos.ResponseMessage,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="cosmosResponseMessage"><see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> in return of the request</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyMismatchRetryPolicy.OnBeforeSendRequest(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Method that is called before a request is sent to allow the retry policy implementation
            to modify the state of the request.
            </summary>
            <param name="request">The request being sent to the service.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PatchOperation">
            <summary>
            Details of Patch operation that is to be applied to the referred Cosmos item.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PatchOperation.OperationType">
            <summary>
            Patch operation type.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PatchOperation.Path">
            <summary>
            Target location reference. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.TrySerializeValueParameter(Microsoft.Azure.Cosmos.CosmosSerializer,System.IO.Stream@)">
            <summary>
            Serializes the value parameter, if specified for the PatchOperation.
            </summary>
            <param name="cosmosSerializer">Serializer to be used.</param>
            <param name="valueParam">Outputs the serialized stream if value parameter is specified, null otherwise.</param>
            <returns>True if value is serialized, false otherwise.</returns>
            <remarks>Output stream should be disposed after use.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.Add``1(System.String,``0)">
            <summary>
            Create <see cref="T:Microsoft.Azure.Cosmos.PatchOperation`1"/> to add a value.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="path">Target location reference.</param>
            <param name="value">The value to be added.</param>
            <returns>PatchOperation instance for specified input.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.Remove(System.String)">
            <summary>
            Create <see cref="T:Microsoft.Azure.Cosmos.PatchOperation"/> to remove a value.
            </summary>
            <param name="path">Target location reference.</param>
            <returns>PatchOperation instance for specified input.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.Replace``1(System.String,``0)">
            <summary>
            Create <see cref="T:Microsoft.Azure.Cosmos.PatchOperation`1"/> to replace a value.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="path">Target location reference.</param>
            <param name="value">The new value.</param>
            <returns>PatchOperation instance for specified input.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.Set``1(System.String,``0)">
            <summary>
            Create <see cref="T:Microsoft.Azure.Cosmos.PatchOperation`1"/> to set a value.
            </summary>
            <typeparam name="T">Type of <paramref name="value"/></typeparam>
            <param name="path">Target location reference.</param>
            <param name="value">The value to be set at the specified path.</param>
            <returns>PatchOperation instance for specified input.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.Increment(System.String,System.Int64)">
            <summary>
            Create <see cref="T:Microsoft.Azure.Cosmos.PatchOperation"/> to Increment a value.
            </summary>
            <param name="path">Target location reference.</param>
            <param name="value">The value to be Incremented by at the specified path.</param>
            <returns>PatchOperation instance for specified input.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperation.Increment(System.String,System.Double)">
            <summary>
            Create <see cref="T:Microsoft.Azure.Cosmos.PatchOperation"/> to Increment a value.
            </summary>
            <param name="path">Target location reference.</param>
            <param name="value">The value to be Incremented by at the specified path.</param>
            <returns>PatchOperation instance for specified input.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperationCore.#ctor(Microsoft.Azure.Cosmos.PatchOperationType,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PatchOperationCore"/> class.
            </summary>
            <param name="operationType">Specifies the type of Patch operation.</param>
            <param name="path">Specifies the path to target location.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperationCore`1.#ctor(Microsoft.Azure.Cosmos.PatchOperationType,System.String,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PatchOperationCore`1"/> class.
            </summary>
            <param name="operationType">Specifies the type of Patch operation.</param>
            <param name="path">Specifies the path to target location.</param>
            <param name="value">Specifies the value to be used.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PatchOperationsJsonConverter">
            <summary>
            A custom serializer converter for list of Patch operations.>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchOperationsJsonConverter.CreatePatchOperationsSerializer(Microsoft.Azure.Cosmos.CosmosSerializer,Microsoft.Azure.Cosmos.CosmosSerializer)">
            <summary>
            Only create a custom PatchOperations serializer if there is a customer serializer else
            use the default properties serializer
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PatchOperationType">
            <summary>
            Type of Patch operation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PatchOperationType.Add">
            <summary>
            Operation to add a value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PatchOperationType.Remove">
            <summary>
            Operation to remove a value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PatchOperationType.Replace">
            <summary>
            Operation to replace a value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PatchOperationType.Set">
            <summary>
            Operation to set a value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PatchOperationType.Increment">
            <summary>
            Operation to increment a value.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PatchOperation`1">
            <summary>
            Defines PatchOperation with a value parameter.
            </summary>
            <typeparam name="T">Data type of value provided for PatchOperation.</typeparam>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PatchOperation`1.Value">
            <summary>
            Value parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PatchSpec">
            <summary>
            Details of Patch operation that is to be applied to the referred Cosmos item.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PatchSpec.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.PatchOperation},Microsoft.Azure.Cosmos.Query.Core.Monads.Either{Microsoft.Azure.Cosmos.PatchItemRequestOptions,Microsoft.Azure.Cosmos.TransactionalBatchPatchItemRequestOptions})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PatchSpec"/> struct.
            </summary>
            <param name="patchOperations"></param>
            <param name="requestOptions"></param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PatchSpec.PatchOperations">
            <summary>
            Details of Patch operation that is to be applied to the referred Cosmos item.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PatchSpec.RequestOptions">
            <summary>
            Cosmos item request options specific to patch.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PortReuseMode">
            <summary>
            Port reuse policy options used by the transport stack
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PortReuseMode.ReuseUnicastPort">
            <summary>
            Windows Server 2016 and newer: Uses the SO_REUSE_UNICASTPORT option if the operating system has automatic client port reuse enabled.
            Older versions of Windows, Linux, other: Uses default socket options.
            </summary>
            <remarks>
            see also
            https://docs.microsoft.com/en-us/windows/win32/winsock/sol-socket-socket-options
            https://docs.microsoft.com/en-us/powershell/module/nettcpip/set-nettcpsetting?view=win10-ps
            https://support.microsoft.com/en-us/help/3149157/reliability-and-scalability-improvements-in-tcp-ip-for-windows-8-1-and
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PortReuseMode.PrivatePortPool">
            <summary>
            Windows: Tracks client ports used by the Cosmos DB client and reuses them. Ports are reused at DocumentClient scope.
            Linux: Uses default socket options.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Collections.PriorityQueue`1">
            <summary> 
            An implementation of <a href="https://en.wikipedia.org/wiki/Binary_heap">Binary Heap</a>
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics">
            <summary>
            Metrics received for queries from the backend.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.Empty">
            <summary>
            QueryMetrics that with all members having default (but not null) members.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.TotalTime">
            <summary>
            Gets the total query time in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.RetrievedDocumentCount">
            <summary>
            Gets the number of documents retrieved during query in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.RetrievedDocumentSize">
            <summary>
            Gets the size of documents retrieved in bytes during query in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.OutputDocumentCount">
            <summary>
            Gets the number of documents returned by query in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.OutputDocumentSize">
            <summary>
            Gets the size of documents outputted in bytes during query in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.QueryPreparationTimes">
            <summary>
            Gets the query QueryPreparationTimes in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.IndexLookupTime">
            <summary>
            Gets the query index lookup time in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.DocumentLoadTime">
            <summary>
            Gets the document loading time during query in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.RuntimeExecutionTimes">
            <summary>
            Gets the query runtime execution times during query in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.DocumentWriteTime">
            <summary>
            Gets the output writing/serializing time during query in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.IndexHitRatio">
            <summary>
            Gets the index hit ratio by query in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics.VMExecutionTime">
            <summary>
            Gets the VMExecution Time.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetricsParser">
            <summary>
            Parser for <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetricsTokenizer">
            <summary>
            Tokenizer for <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.BackendMetrics"/>
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.ClientSideMetrics">
            <summary>
            Stores client side QueryMetrics.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.ClientSideMetrics.#ctor(System.Int64,System.Double,System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange})">
            <summary>
            Initializes a new instance of the ClientSideMetrics class.
            </summary>
            <param name="retries">The number of retries required to execute the query.</param>
            <param name="requestCharge">The request charge incurred from executing the query.</param>
            <param name="fetchExecutionRanges">The fetch execution ranges from executing the query.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.ClientSideMetrics.Retries">
            <summary>
            Gets number of retries in the Azure DocumentDB database service (see IRetryPolicy.cs).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.ClientSideMetrics.RequestCharge">
            <summary>
            Gets the request charge for this continuation of the query.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.ClientSideMetrics.FetchExecutionRanges">
            <summary>
            Gets the Fetch Execution Ranges for this continuation of the query.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.CompositeIndexUtilizationEntity">
            <summary>
            Query index utilization data for composite indexes (sub-structure of the Index Utilization metrics) in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.CompositeIndexUtilizationEntity.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Boolean,System.String)">
            <summary>
            Initialized a new instance of the Composite Index Utilization Entity class.
            </summary>
            <param name="indexDocumentExpressions">The index representation of the filter expression.</param>
            <param name="indexPlanFullFidelity">The index plan full fidelity.</param>
            <param name="indexImpactScore">The index impact score.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange">
            <summary>
            Stores information about fetch execution (for cross partition queries).
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.#ctor(System.String,System.String,System.DateTime,System.DateTime,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange"/> class.
            </summary>
            <param name="activityId">The activityId of the fetch</param>
            <param name="startTime">The start time of the fetch.</param>
            <param name="endTime">The end time of the fetch.</param>
            <param name="partitionKeyRangeId">The partitionkeyrangeid from which you are fetching for.</param>
            <param name="numberOfDocuments">The number of documents that were fetched in the particular execution range.</param>
            <param name="retryCount">The number of times we retried for this fetch execution range.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.PartitionId">
            <summary>
            Gets the partition id that was fetched from.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.ActivityId">
            <summary>
            Gets the activityId of the fetch.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.StartTime">
            <summary>
            Gets the start time of the fetch.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.EndTime">
            <summary>
            Gets the end time of the fetch.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.NumberOfDocuments">
            <summary>
            Gets the number of documents that where fetched in the particular execution range.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRange.RetryCount">
            <summary>
            Gets the number of times we retried for this fetch execution range.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRangeAccumulator">
            <summary>
            Accumulator that acts as a builder of FetchExecutionRanges
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRangeAccumulator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRangeAccumulator"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRangeAccumulator.GetExecutionRanges">
            <summary>
            Gets the FetchExecutionRanges and resets the accumulator.
            </summary>
            <returns>the SchedulingMetricsResult.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRangeAccumulator.BeginFetchRange">
            <summary>
            Updates the most recent start time internally.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.FetchExecutionRangeAccumulator.EndFetchRange(System.String,System.String,System.Int64,System.Int64)">
            <summary>
            Updates the most recent end time internally and constructs a new FetchExecutionRange
            </summary>
            <param name="partitionIdentifier">The identifier for the partition.</param>
            <param name="activityId">The activity of the fetch.</param>
            <param name="numberOfDocuments">The number of documents that were fetched for this range.</param>
            <param name="retryCount">The number of times we retried for this fetch execution range.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.IndexMetricWriter">
            <summary>
            Base class for visiting and serializing a <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.IndexUtilizationInfo">
            <summary>
            Query index utilization metrics in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.IndexUtilizationInfo.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Metrics.SingleIndexUtilizationEntity},System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Metrics.SingleIndexUtilizationEntity},System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Metrics.CompositeIndexUtilizationEntity},System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Metrics.CompositeIndexUtilizationEntity})">
            <summary>
            Initializes a new instance of the Index Utilization class.
            </summary>
            <param name="utilizedSingleIndexes">The utilized single indexes list</param>
            <param name="potentialSingleIndexes">The potential single indexes list</param>
            <param name="utilizedCompositeIndexes">The potential composite indexes list</param>
            <param name="potentialCompositeIndexes">The utilized composite indexes list</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.IndexUtilizationInfo.TryCreateFromDelimitedString(System.String,Microsoft.Azure.Cosmos.Query.Core.Metrics.IndexUtilizationInfo@)">
            <summary>
            Creates a new IndexUtilizationInfo from the backend delimited string.
            </summary>
            <param name="delimitedString">The backend delimited string to deserialize from.</param>
            <param name="result">The parsed index utilization info</param>
            <returns>A new IndexUtilizationInfo from the backend delimited string.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics">
            <summary>
            Class for composing multiple query metrics in a dictionary interface.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.partitionedQueryMetrics">
            <summary>
            The backing store.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.#ctor(System.Collections.Generic.IReadOnlyDictionary{System.String,Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics})">
            <summary>
            Initializes a new instance of the PartitionedQueryMetrics class.
            </summary>
            <param name="other">The other dictionary of query metrics to create from.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.#ctor">
            <summary>
            Initializes a new instance of the PartitionedQueryMetrics class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.Count">
            <summary>
            Gets the count.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.Keys">
            <summary>
            Gets the keys.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.Values">
            <summary>
            Gets the values.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.Item(System.String)">
            <summary>
            Gets the QueryMetrics corresponding to the key.
            </summary>
            <param name="key">The partition id.</param>
            <returns>The QueryMetrics corresponding to the key.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.CreateFromIEnumerable(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics})">
            <summary>
            Aggregates an IEnumerable of partitioned query metrics together.
            </summary>
            <param name="partitionedQueryMetricsList">The partitioned query metrics to add together.</param>
            <returns>The summed up partitioned query metrics.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.op_Addition(Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics,Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics)">
            <summary>
            Overloaded for adding two partitioned query metrics together.
            </summary>
            <param name="partitionedQueryMetrics1">The first partitioned query metrics.</param>
            <param name="partitionedQueryMetrics2">The second partitioned query metrics.</param>
            <returns>
            Sums up two partitioned query metrics taking the union of the keys.
            If there is an intersection then the intersection is summed up as defined by QueryMetrics.
            The union minus the intersection is left as is.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.Add(Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics[])">
            <summary>
            Adds partitioned query metrics together.
            </summary>
            <param name="partitionedQueryMetricsList">The partitioned query metrics to add.</param>
            <returns>The summed up partitioned query metrics.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.ToString">
            <summary>
            Gets the string version.
            </summary>
            <returns>The string version.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.ContainsKey(System.String)">
            <summary>
            Checks to see if this contains a key.
            </summary>
            <param name="key">The key.</param>
            <returns>Whether or not this partitioned query metrics contains a key.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.GetEnumerator">
            <summary>
            Gets an enumerator.
            </summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.TryGetValue(System.String,Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics@)">
            <summary>
            Tries to get a value corresponding to a key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>true if the key was found, else false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.PartitionedQueryMetrics.ToTextString">
            <summary>
            Gets the text string of this object.
            </summary>
            <returns>The text string of this object.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics">
            <summary>
            Query metrics in the Azure Cosmos database service.
            This metric represents a moving average for a set of queries whose metrics have been aggregated together.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics.Empty">
            <summary>
            QueryMetrics that with all members having default (but not null) members.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics.op_Addition(Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics,Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics)">
            <summary>
            Add two specified <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instances
            </summary>
            <param name="queryMetrics1">The first <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instance</param>
            <param name="queryMetrics2">The second <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instance</param>
            <returns>A new <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instance that is the sum of two <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instances</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics.ToString">
            <summary>
            Gets the stringified <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instance in the Azure Cosmos database service.
            </summary>
            <returns>The stringified <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/> instance in the Azure Cosmos database service.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetricsTextWriter">
            <summary>
            Fancy <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetricsWriter"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetricsWriter">
            <summary>
            Base class for visiting and serializing a <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryMetrics"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryPreparationTimes">
            <summary>
            Query preparation metrics in the Azure DocumentDB database service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryPreparationTimes.#ctor(System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the QueryPreparationTimes class.
            </summary>
            <param name="queryCompilationTime">Query compile and optimization time</param>
            <param name="logicalPlanBuildTime">Query logical plan build time</param>
            <param name="physicalPlanBuildTime">Query physical plan build time</param>
            <param name="queryOptimizationTime">Query optimization time</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryPreparationTimes.QueryCompilationTime">
            <summary>
            Gets the query compile time in the Azure DocumentDB database service. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryPreparationTimes.LogicalPlanBuildTime">
            <summary>
            Gets the query logical plan build time in the Azure DocumentDB database service. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryPreparationTimes.PhysicalPlanBuildTime">
            <summary>
            Gets the query physical plan build time in the Azure DocumentDB database service. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.QueryPreparationTimes.QueryOptimizationTime">
            <summary>
            Gets the query optimization time in the Azure DocumentDB database service. 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.RuntimeExecutionTimes">
            <summary>
            Query runtime execution times in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.RuntimeExecutionTimes.#ctor(System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the RuntimeExecutionTimes class.
            </summary>
            <param name="queryEngineExecutionTime">Query end - to - end execution time</param>
            <param name="systemFunctionExecutionTime">Total time spent executing system functions</param>
            <param name="userDefinedFunctionExecutionTime">Total time spent executing user - defined functions</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.RuntimeExecutionTimes.QueryEngineExecutionTime">
            <summary>
            Gets the total query runtime execution time in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.RuntimeExecutionTimes.SystemFunctionExecutionTime">
            <summary>
            Gets the query system function execution time in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.RuntimeExecutionTimes.UserDefinedFunctionExecutionTime">
            <summary>
            Gets the query user defined function execution time in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch">
            <summary>
            This class keeps track of scheduling metrics for a single process using a stopwatch interface.
            Internally this class is composed of Stopwatches keeping track of scheduling metrics.
            The main metrics are turnaround, response, run, and wait time.
            However this class only handles behavior; if you want the data / results, then you will have to call on the 
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.turnaroundTimeStopwatch">
            <summary>
            Stopwatch used to measure turnaround time.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.responseTimeStopwatch">
            <summary>
            Stopwatch used to measure response time.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.runTimeStopwatch">
            <summary>
            Stopwatch used to measure runtime.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.numPreemptions">
            <summary>
            Number of times the process was preempted.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.responded">
            <summary>
            Whether or not the process got a response yet.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.#ctor">
            <summary>
            Initializes a new instance of the SchedulingStopwatch class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.Elapsed">
            <summary>
            Gets the SchedulingMetricsTimeSpan, which is a readonly snapshot of the SchedulingMetrics.
            </summary>
            <returns>the SchedulingMetricsResult.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.Ready">
            <summary>
            Tells the SchedulingStopwatch know that the process is in a state where it is ready to be worked on,
            which in turn starts the stopwatch for for response time and turnaround time.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.Start">
            <summary>
            Starts or resumes the stopwatch for runtime meaning that the process in the run state for the first time
            or was preempted and now back in the run state.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.Terminate">
            <summary>
            Stops all the internal stopwatches.
            This is mainly useful for marking the end of a process to get an accurate turnaround time.
            It is undefined behavior to start a stopwatch that has been terminated.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingStopwatch.ToString">
            <summary>
            Returns a string version of this SchedulingStopwatch
            </summary>
            <returns>String version of the SchedulingStopwatch.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan">
            <summary>
            This struct is the TimeSpan equivalent to Stopwatch for SchedulingStopwatch.cs.
            That is to say that SchedulingStopwatch is behavior like a stopwatch (you can start and stop the stopwatch).
            SchedulingTimeSpan is a non mutable snapshot of SchedulingMetrics 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.#ctor(System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.Int64)">
            <summary>
            Initializes a new instance of the SchedulingTimeSpan struct.
            </summary>
            <param name="turnaroundTime">The total time taken from when the process arrives to when it ended.</param>
            <param name="responseTime">The total latency (time) taken from when the process arrived to when the CPU actually started working on it.</param>
            <param name="runTime">The total time the process spent in the running state.</param>
            <param name="waitTime">The total time the process spent in the waiting state.</param>
            <param name="numPreemptions">Number of times the process was preempted.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.NumPreemptions">
            <summary>
            Gets the number of preemptions (the number of times the process was moved from the running state to the ready state).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.TurnaroundTime">
            <summary>
            Gets the total time from when the process arrived to when it ended.
            turnaround_time = end_time - arrival_time
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.ResponseTime">
            <summary>
            Gets the total latency (time) from when the process arrived to when the CPU actually started working on it.
            response_time = start_time - arrival_time
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.RunTime">
            <summary>
            Gets the total time the process spent in the running state.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.WaitTime">
            <summary>
            Gets the total time that a process was is in the ready or waiting state.
            wait_time = (end_time - arrival_time) - run_time = turnaround_time - run_time
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.GetAverageTurnaroundTime(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan})">
            <summary>
            Gets the average turnaround time for a list of SchedulingMetrics.
            </summary>
            <param name="schedulingTimeSpans">Metrics to get average turnaround times from.</param>
            <returns>The average turnaround time for a list of SchedulingMetrics.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.GetAverageResponseTime(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan})">
            <summary>
            Gets the average response time for a list of SchedulingMetrics.
            </summary>
            <param name="schedulingTimeSpans">Metrics to get average response times from.</param>
            <returns>The average response time for a list of SchedulingMetrics.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.GetAverageRunTime(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan})">
            <summary>
            Gets the average run time for a list of SchedulingMetrics.
            </summary>
            <param name="schedulingTimeSpans">Metrics to get average run times from.</param>
            <returns>The average run time for a list of SchedulingMetrics.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.GetThroughput(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan})">
            <summary>
            Get the throughput which is the number of completed processes per time unit (second).
            </summary>
            <param name="schedulingTimeSpans">The scheduling metrics you wish to use.</param>
            <returns>The throughput for a list of scheduling Metrics</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.GetCpuUtilization(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan})">
            <summary>
            Gets the CPU utilization (percent of time CPU is being used) for a list of SchedulingMetrics.
            </summary>
            <param name="schedulingTimeSpans">List of SchedulingMetrics to calculate the utilization from.</param>
            <returns>The CPU utilization for a list of SchedulingMetrics.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.WriteJsonObject(Newtonsoft.Json.JsonWriter)">
            <summary>
            Appends a JSON version of this SchedulingMetricsResult
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.ToString">
            <summary>
            Returns a string version of this SchedulingMetricsResult
            </summary>
            <returns>String version of the SchedulingMetricsResult.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan.GetAverageTime(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan},System.Func{Microsoft.Azure.Cosmos.Query.Core.Metrics.SchedulingTimeSpan,System.Int64})">
            <summary>
            Gets the average time for a list of scheduling metrics based on the property you wish to average over.
            </summary>
            <param name="schedulingTimeSpans">Metrics to get average times from.</param>
            <param name="propertySelectorCallback">Callback to use to select the desired property.</param>
            <returns>The average time for a list of scheduling metrics based on the property you wish to average over.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.SingleIndexUtilizationEntity">
            <summary>
            Query index utilization data for single index (sub-structure of the Index Utilization metrics) in the Azure Cosmos database service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.SingleIndexUtilizationEntity.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.String)">
            <summary>
            Initialized a new instance of the Single Index Utilization Entity class.
            </summary>
            <param name="filterExpression">The filter expression.</param>
            <param name="indexDocumentExpression">The index representation of the filter expression.</param>
            <param name="filterExpressionPrecision">The precision flag of the filter expression.</param>
            <param name="indexPlanFullFidelity">The index plan full fidelity.</param>
            <param name="indexImpactScore">The index impact score.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Metrics.TextTable">
            <summary>
            Query runtime execution times in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Metrics.TextTable.#ctor(Microsoft.Azure.Cosmos.Query.Core.Metrics.TextTable.Column[])">
            <summary>
            Initializes a new instance of the TextTable class.
            </summary>
            <param name="columns">The columns of the table.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Monads.TryCatch.Void">
            <summary>
            Represents a void return type.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Parser.CstToAstVisitor">
            <summary>
            Converts from ANTLR's CST to a CosmosDB SQL AST.
            The main difference is that a CST Context will contain every token like array start and delimiters, which is too verbose for most usecases.
            The children of a CST are also untyped (generic IParseTree), which doesn't give the contraints we need.
            In general the ANTLR parser could in theory generate an incorrect CST if the grammar file has a mistake,
            while and AST is strongly typed and any AST is a valid grammar (as long as the AST is defined correctly).
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.AggregateQueryPipelineStage">
            <summary>
            Stage that is able to aggregate local aggregates from multiple continuations and partitions.
            At a high level aggregates queries only return a "partial" aggregate.
            "partial" means that the result is only valid for that one continuation (and one partition).
            For example suppose you have the query "SELECT COUNT(1) FROM c" and you have a single partition collection, 
            then you will get one count for each continuation of the query.
            If you wanted the true result for this query, then you will have to take the sum of all continuations.
            The reason why we have multiple continuations is because for a long running query we have to break up the results into multiple continuations.
            Fortunately all the aggregates can be aggregated across continuations and partitions.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.AggregateQueryPipelineStage.singleGroupAggregator">
            <summary>
            This class does most of the work, since a query like:
            
            SELECT VALUE AVG(c.age)
            FROM c
            
            is really just an aggregation on a single grouping (the whole collection).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.AggregateQueryPipelineStage.isValueQuery">
            <summary>
            We need to keep track of whether the projection has the 'VALUE' keyword.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.AggregateQueryPipelineStage.#ctor(Microsoft.Azure.Cosmos.Query.Core.Pipeline.IQueryPipelineStage,Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the AggregateDocumentQueryExecutionComponent class.
            </summary>
            <param name="source">The source component that will supply the local aggregates from multiple continuations and partitions.</param>
            <param name="singleGroupAggregator">The single group aggregator that we will feed results into.</param>
            <param name="isValueQuery">Whether or not the query has the 'VALUE' keyword.</param>
            <param name="cancellationToken">The cancellation token for cooperative yeilding.</param>
            <remarks>This constructor is private since there is some async initialization that needs to happen in CreateAsync().</remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.AggregateQueryPipelineStage.RewrittenAggregateProjections">
            <summary>
            Struct for getting the payload out of the rewritten projection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator">
            <summary>
            Concrete implementation of IAggregator that can take the global weighted average from the local weighted average of multiple partitions and continuations.
            The way this works is that for each continuation in each partition we decompose the average into a sum and count.
            Let us denote the sum and count for the ith continuation in the jth partition as (sum_i,j, count_i,j),
            then the true average for the whole query is SUM(sum_i,j for all i and all j) / SUM(count_i,j for all i and all j),
            this way the average is weighted across continuation and partitions that have more or less documents contributing to their average.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.globalAverage">
            <summary>
            The running weighted average for this aggregator.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.Aggregate(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Averages the supplied item with the previously supplied items.
            </summary>
            <param name="localAverage">The local average to add to the global average.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.GetResult">
            <summary>
            Returns the current running average or undefined if any of the intermediate averages resulted in an undefined value.
            </summary>
            <returns>The current running average or undefined if any of the intermediate averages resulted in an undefined value.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo">
            <summary>
            Struct that stores a weighted average as a sum and count so they that average across different partitions with different numbers of documents can be taken.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo.#ctor(System.Nullable{System.Double},System.Int64)">
            <summary>
            Initializes a new instance of the AverageInfo class.
            </summary>
            <param name="sum">The sum (if defined).</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo.TryCreateFromCosmosElement(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Initializes a new instance of the AverageInfo class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo.Sum">
            <summary>
            Gets the some component of the weighted average (or null of the result is undefined).
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo.Count">
            <summary>
            Gets the count component of the weighted average.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo.op_Addition(Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo,Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo)">
            <summary>
            Takes the sum of two AverageInfo structs
            </summary>
            <param name="info1">The first AverageInfo.</param>
            <param name="info2">The second AverageInfo.</param>
            <returns>The sum of two AverageInfo structs</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.AverageAggregator.AverageInfo.GetAverage">
            <summary>
            Returns the average or undefined if any of the intermediate averages resulted in an undefined value.
            </summary>
            <returns>The average or undefined if any of the intermediate averages resulted in an undefined value.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.CountAggregator">
            <summary>
            Concrete implementation of IAggregator that can take the global count from the local counts from multiple partitions and continuations.
            Let count_i,j be the count from the ith continuation in the jth partition, 
            then the count for the entire query is SUM(count_i,j for all i and j)
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.CountAggregator.globalCount">
            <summary>
            The global count.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.CountAggregator.Aggregate(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Adds a count to the running count.
            </summary>
            <param name="localCount">The count to add.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.CountAggregator.GetResult">
            <summary>
            Gets the global count.
            </summary>
            <returns>The global count.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.IAggregator">
            <summary>
            Interface for all aggregators that are used to aggregate across continuation and partition boundaries.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.IAggregator.Aggregate(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Adds an item to the aggregation.
            </summary>
            <param name="item">The item to add to the aggregation.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.IAggregator.GetResult">
            <summary>
            Gets the result of the aggregation.
            </summary>
            <returns>The result of the aggregation.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.MinMaxAggregator">
            <summary>
            Concrete implementation of IAggregator that can take the global min/max from the local min/max of multiple partitions and continuations.
            Let min/max_i,j be the min/max from the ith continuation in the jth partition, 
            then the min/max for the entire query is MIN/MAX(min/max_i,j for all i and j).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.MinMaxAggregator.isMinAggregation">
            <summary>
            Whether or not the aggregation is a min or a max.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.MinMaxAggregator.globalMinMax">
            <summary>
            The global max of all items seen.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator">
            <summary>
            Aggregates all the projections for a single grouping.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator.AddValues(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Adds the payload for group by values 
            </summary>
            <param name="values"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator.GetResult">
            <summary>
            Forms the final result of the grouping.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator.SelectValueAggregateValues">
            <summary>
            For SELECT VALUE queries there is only one value for each grouping.
            This class just helps maintain that and captures the first value across all continuations.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator.SelectListAggregateValues">
            <summary>
            For select list queries we need to create a dictionary of alias to group by value.
            For each grouping drained from the backend we merge it with the results here.
            At the end this class will form a JSON object with the correct aliases and grouping result.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SingleGroupAggregator.AggregateValue">
            <summary>
            With a group by value we need to encapsulate the fact that we have:
            1) aggregate group by values
            2) scalar group by values.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SumAggregator">
            <summary>
            Concrete implementation of IAggregator that can take the global sum from the local sum of multiple partitions and continuations.
            Let sum_i,j be the sum from the ith continuation in the jth partition, 
            then the sum for the entire query is SUM(sum_i,j for all i and j).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SumAggregator.globalSum">
            <summary>
            The global sum.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SumAggregator.Aggregate(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Adds a local sum to the global sum.
            </summary>
            <param name="localSum">The local sum.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Aggregate.Aggregators.SumAggregator.GetResult">
            <summary>
            Gets the current sum.
            </summary>
            <returns>The current sum.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer">
            <summary>
            Utility class used to compare all items that we get back from a query.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.Instance">
            <summary>
            Singleton item comparer.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.MinValue">
            <summary>
            The minimum value out of all possible items.
            </summary>
            <remarks>Note that this isn't a real item.</remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.MaxValue">
            <summary>
            The maximum value out of all possible items.
            </summary>
            <remarks>Note that this isn't a real item.</remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.Undefined">
            <summary>
            Undefined is represented by null in the CosmosElement library.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.Compare(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement,Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Compares to objects and returns their partial sort relationship.
            </summary>
            <param name="element1">The first element to compare.</param>
            <param name="element2">The second element to compare.</param>
            <returns>
            Less than zero if obj1 comes before obj2 in the sort order.
            Zero if obj1 and obj2 are interchangeable in the sort order.
            Greater than zero if obj2 comes before obj1 in the sort order.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.MinValueItem">
            <summary>
            Represents the minimum value item.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.ItemComparer.MaxValueItem">
            <summary>
            Represent the maximum value item.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken">
            <summary>
            <para>
            Executing an OrderBy query for a partitioned collection, say, "select * from root order by root.key ASC", 
            boils down to solving a version of k-way merge sort, where, each of the k partitions produces a sorted stream of values.
            </para>
            <para>
            Now if a query requires multiple ExecuteNextAsync, we return a serialized version of OrderByContinuationToken, to the users
            so that they can resume the query from where they left off at a later point in time. Below we describe the components of
            OrderByContinuation in detail. 
            </para> 
            A key notion of a OrderByContinuation is that of the "Target Partition", which is effectively 
            the partition from whose stream the last value was consumed during the execution of the query. 
            We construct our continuation token composing the information of the target partition and 
            the metadata related to the last value seen from the target partition.  
            <para>
            One key difference in our version of the k-way merge sort from the classical version of the k-way merge sort is that, in
            our case there is a partial order on the 2-tuple consisting of {partition, value seen from that partition}. 
            For example, (P1, 2) less than (P2, 2) if P1 is less than P2 (i.e., P1.MinRange is less than P2.MinRange). This difference allowed 
            us to shorten the continuation token (i.e., we only need to know the state of the target range), 
            but at the cost of performance penalties in pathological cases (e.g., Partition 0 is heavily throttled 
            but still serving value "2", while partition 1 has a large number of "2"s which can't be served
            to the user).
            </para>
            <para>
            Considering the above fact, three important points to note here are:
                1. If the latest value seen at the target partition is X, then we have exhausted all value less than X (for ASC order),
                all partitions that have smaller Range.Min than that of the target partition. 
                2. All partitions, that have greater Range.Min than that of the target partition, have exhausted all values less than or equal to X 
            </para>    
            <para>
            Given this background, below is an example of order by continuation token. The class members below explains the different 
            component/states of the continuation token.
            </para> 
            </summary>
            <example>
            Order by continuation token example.
            <![CDATA[
             {"compositeToken":{"token":"+RID:OpY0AN-mFAACAAAAAAAABA==#RT:1#TRC:1#RTD:qdTAEA==","range":{"min":"05C1D9CD673398","max":"05C1E399CD6732"}},"orderByItems"[{"item":2}],"rid":"OpY0AN-mFAACAAAAAAAABA==","skipCount":0,"filter":"r.key > 1"}
            ]]>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken.#ctor(Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.Parallel.ParallelContinuationToken,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByItem},System.String,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the OrderByContinuationToken struct.
            </summary>
            <param name="compositeContinuationToken">The composite continuation token (refer to property documentation).</param>
            <param name="orderByItems">The order by items (refer to property documentation).</param>
            <param name="rid">The rid (refer to property documentation).</param>
            <param name="skipCount">The skip count (refer to property documentation).</param>
            <param name="filter">The filter (refer to property documentation).</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken.ParallelContinuationToken">
            <summary>
            Gets: Target partition states, including backend continuation and partition key range information. 
            </summary>
            <example>
            <![CDATA[
             {"compositeToken":{"token":"+RID:OpY0AN-mFAACAAAAAAAABA==#RT:1#TRC:1#RTD:qdTAEA==","range":{"min":"05C1D9CD673398","max":"05C1E399CD6732"}}
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken.OrderByItems">
            <summary>
            Gets: Values in the top most OrderByQueryResult from the target partition.
            orderByItems is used for filtering after we resume.
            </summary>
            <example>
            Here, the item 2 means that, it was an orderBy by integer field, and when the query paused,
            the latest value seen from the corresponding partition was 2. 
            <![CDATA[
             "orderByItems"[{"item":2}]
            ]]>
            </example>
            <remarks>
            Right now, we don't support orderBy by multiple fields, so orderByItems is an array of one element. 
            </remarks>>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken.Rid">
            <summary>
            Gets: Rid in the top most OrderByQueryResult from the target partition.
            Rid is used for filtering after we resume, when orderByItems have the same value.
            </summary>
            <remarks>
            Note that, Rid is just a marker from the backend point of view, and the
            document with the Rid might not exist upon resuming a query (due to deletion or
            other reasons). The backend will just return the next available result logically 
            succeeding the marker. 
            </remarks>
            <example>
            <![CDATA[
             "rid":"OpY0AN-mFAACAAAAAAAABA=="
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken.SkipCount">
            <summary>
            <para>
            Gets: Skip count is necessary for JOIN queries to resume. Azure Cosmos DB's joins are much different from standard 
            SQL joins. While standard SQL joins happen across two tables, Azure Cosmos DB joins happens over a single collection 
            (think single table with each row having dynamic number of columns). While executing a join query, 
            each Azure Cosmos DB document (i.e, each row), though, can generate multiple result items. You can look up the documentation 
            online to understand this better. 
            </para>
            <para>
            This behavior has implications on how pagination work for CosmosDB queries, especially for order by queries across
            multiple partition. 
            </para>
            <para>
            To understand complexity, let's take an example. Let's say that there is only 1 partition in a collection, and the collection
            has 2 documents. And each document generate 6 results on a hypothetical join query. Now, if someone issues the query with a page size
            of 10, while fetching the second page of the query (as it has already exhausted the results produced by the join on the first document) 
            needs to resume from the second document and skip the first 6 - ((2 * 6) - 10) = 4 results. 
            </para>
            The skip count keeps track of that information. 
            </summary> 
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByContinuationToken.Filter">
            <summary>
            Gets: We use the filter to rewrite the OrderBy query when resuming from a continuation token. 
            </summary>
            <example>
            <para>
            In this example snippet below the filter string indicates that the query was an OrderBy query 
            and when the query was paused it had already output all the values value greater than 1. 
            And when the query resumes it only needs to fetch value greater than 1. 
            </para>
            <para>
            Note that, if any value less than 1 that was inserted after the query started won't be delivered as a 
            part of the result. 
            <![CDATA[
             "filter":"r.key > 1"
            ]]>
            </para>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByCrossPartitionQueryPipelineStage">
            <summary>
            CosmosOrderByItemQueryExecutionContext is a concrete implementation for CrossPartitionQueryExecutionContext.
            This class is responsible for draining cross partition queries that have order by conditions.
            The way order by queries work is that they are doing a k-way merge of sorted lists from each partition with an added condition.
            The added condition is that if 2 or more top documents from different partitions are equivalent then we drain from the left most partition first.
            This way we can generate a single continuation token for all n partitions.
            This class is able to stop and resume execution by generating continuation tokens and reconstructing an execution context from said token.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByCrossPartitionQueryPipelineStage.FormatPlaceHolder">
            <summary>
            Order by queries are rewritten to allow us to inject a filter.
            This placeholder is so that we can just string replace it with the filter we want without having to understand the structure of the query.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByCrossPartitionQueryPipelineStage.TrueFilter">
            <summary>
            If query does not need a filter then we replace the FormatPlaceHolder with "true", since
            "SELECT * FROM c WHERE blah and true" is the same as "SELECT * FROM c where blah"
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByEnumeratorComparer">
            <summary>
            For cross partition order by queries we serve documents from the partition
            that has the next document in the sort order of the query.
            If there is a tie, then we break the tie by picking the leftmost partition.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByEnumeratorComparer.sortOrders">
            <summary>
            The sort orders for the query (1 for each order by in the query).
            Until composite indexing is released this will just be an array of length 1.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByEnumeratorComparer.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.SortOrder})">
            <summary>
            Initializes a new instance of the OrderByConsumeComparer class.
            </summary>
            <param name="sortOrders">The sort orders for the query.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByEnumeratorComparer.Compare(Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByQueryPartitionRangePageAsyncEnumerator,Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByQueryPartitionRangePageAsyncEnumerator)">
            <summary>
            Compares two document producer trees and returns an integer with the relation of which has the document that comes first in the sort order.
            </summary>
            <param name="enumerator1">The first document producer tree.</param>
            <param name="enumerator2">The second document producer tree.</param>
            <returns>
            Less than zero if the document in the first document producer comes first.
            Zero if the documents are equivalent.
            Greater than zero if the document in the second document producer comes first.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByEnumeratorComparer.CompareOrderByItems(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByItem},System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByItem})">
            <summary>
            Takes the items relevant to the sort and return an integer defining the relationship.
            </summary>
            <param name="items1">The items relevant to the sort from the first partition.</param>
            <param name="items2">The items relevant to the sort from the second partition.</param>
            <returns>The sort relationship.</returns>
            <example>
            Suppose the query was "SELECT * FROM c ORDER BY c.name asc, c.age desc",
            then items1 could be ["Brandon", 22] and items2 could be ["Felix", 28]
            Then we would first compare "Brandon" to "Felix" and say that "Brandon" comes first in an ascending lex order (we don't even have to look at age).
            If items1 was ["Brandon", 22] and items2 was ["Brandon", 23] then we would say have to look at the age to break the tie and in this case 23 comes first in a descending order.
            Some examples of composite order by: http://www.dofactory.com/sql/order-by
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByItem">
            <summary>
            Used to represent an order by item for a cross partition ORDER BY query.
            </summary>
            <example>{"item": 5}</example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByQueryResult">
            <summary>
            <para>
            For cross partition order by queries a query like "SELECT c.id, c.field_0 ORDER BY r.field_7 gets rewritten as:
            SELECT r._rid, [{"item": r.field_7}] AS orderByItems, {"id": r.id, "field_0": r.field_0} AS payload
            FROM r
            WHERE({ document db - formattable order by query - filter})
            ORDER BY r.field_7
            </para>
            <para>
            This is so that the client can parse out the _rid, orderByItems from the actual data / payload,
            without scanning the entire document.
            </para>
            <para>
            This struct is used to strongly bind the results of that rewritten query.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByQueryResult.Rid">
            <summary>
            Gets the rid of the document.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByQueryResult.OrderByItems">
            <summary>
            Gets the order by items from the document.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.OrderBy.OrderByQueryResult.Payload">
            <summary>
            Gets the actual document.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.Parallel.ParallelContinuationToken">
            <summary>
            A composite continuation token that has both backend continuation token and partition range information. 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.Parallel.ParallelCrossPartitionQueryPipelineStage">
            <summary>
            <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.Parallel.ParallelCrossPartitionQueryPipelineStage"/> is an implementation of <see cref="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.IQueryPipelineStage"/> that drain results from multiple remote nodes.
            This class is responsible for draining cross partition queries that do not have order by conditions.
            The way parallel queries work is that it drains from the left most partition first.
            This class handles draining in the correct order and can also stop and resume the query 
            by generating a continuation token and resuming from said continuation token.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.PartitionMapper.MergeRangesWherePossible(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.FeedRangeEpk})">
            <summary>
            Merges all the feed ranges as much as possible.
            </summary>
            <param name="feedRanges">The ranges to merge.</param>
            <returns>The merged ranges</returns>
            <example>
            [(A, B), (B, C), (E, F), (H, I), (I, J)] 
                => [(A, C), (E, F), (H, J)]
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.PartitionMapper.SplitRangesBasedOffContinuationToken``1(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.FeedRangeEpk},System.Collections.Generic.IReadOnlyList{``0})">
            <summary>
            Splits the ranges into the ranges from the continuation token.
            </summary>
            <typeparam name="PartitionedToken">The partitioned token type.</typeparam>
            <param name="feedRanges">The ranges to split.</param>
            <param name="tokens">The tokens to split with.</param>
            <returns>A list of Range and corresponding token tuple.</returns>
            <example>
            ranges: [(A, E), (H, K)], 
            tokens: [(A, C):5, (I, J): 6] 
                => [(A,C): 5, (C, E): null, (H, I): null, (I, J): 6, (J, K): null]
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.CrossPartition.PartitionMapper.MonadicConstructPartitionMapping``1(System.Collections.Generic.IReadOnlyList{System.ValueTuple{Microsoft.Azure.Cosmos.FeedRangeEpk,``0}},System.Collections.Generic.IReadOnlyList{``0},Microsoft.Azure.Cosmos.FeedRangeEpk)">
            <summary>
            Segments the ranges and their tokens into a partition mapping.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.DCount.DCountQueryPipelineStage">
            <summary>
            Stage that is able to aggregate COUNT(DISTINCT) from multiple continuations and partitions.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.DCount.DCountQueryPipelineStage.info">
            <summary>
            We need to keep track of whether the projection has the 'VALUE' keyword or an alias.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.DCount.DCountQueryPipelineStage.count">
            <summary>
            This job of this class is to just keep a count.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.DCount.DCountQueryPipelineStage.#ctor(Microsoft.Azure.Cosmos.Query.Core.Pipeline.IQueryPipelineStage,System.Int64,Microsoft.Azure.Cosmos.Query.Core.QueryPlan.DCountInfo,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the DCountQueryPipelineStage class.
            </summary>
            <param name="source">The source component that will supply the local aggregates from multiple continuations and partitions.</param>
            <param name="count">The actual dcount that will be reported.</param>
            <param name="info">Metadata about the original dcount query that is elided in the rewritten query</param>
            <param name="cancellationToken">The cancellation token for cooperative yeilding.</param>
            <remarks>This constructor is private since there is some async initialization that needs to happen in CreateAsync().</remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap">
            <summary>
            Base class for all types of DistinctMaps.
            An IDistinctMap is able to efficiently store a hash set of json values.
            This is done by taking the json value and storing a GUID like hash of that value in a hashset.
            By storing the hash we avoid storing the entire object in main memory.
            Only downside is that there is a possibility of a hash collision.
            However we store the hash as 192 bits, so the possibility of a collision is pretty low.
            You can run the birthday paradox math to figure out how low: https://en.wikipedia.org/wiki/Birthday_problem
            </summary>
            <summary>
            Partial wrapper
            </summary>
            <summary>
            Partial wrapper
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.TryCreate(Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryType,Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Creates an IDistinctMap based on the type.
            </summary>
            <param name="distinctQueryType">The type of distinct query.</param>
            <param name="distinctMapContinuationToken">The continuation token to resume from.</param>
            <returns>The appropriate IDistinctMap.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.Add(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement,Microsoft.Azure.Cosmos.UInt128@)">
            <summary>
            Adds a JToken to this DistinctMap.
            </summary>
            <param name="cosmosElement">The element to add.</param>
            <param name="hash">The hash of the cosmos element</param>
            <returns>Whether or not the token was successfully added.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.OrderedDistinctMap">
            <summary>
            For distinct queries of the form:
            SELECT DISTINCT VALUE c.(blah) from c order by c.(blah)
            We can make an optimization, since the problem boils down to
            "How can you find all the distinct items in a sorted stream"
            Ex. "1, 1, 2, 2, 2, 3, 4, 4" -> "1, 2, 3, 4"
            The solution is that you only need to remember the previous item of the stream:
            foreach item in stream:
                if item != previous item:
                    yield item
            This class accomplishes that by storing the previous hash and assuming the items come in sorted order.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.OrderedDistinctMap.lastHash">
            <summary>
            The hash of the last item that was added to this distinct map.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.OrderedDistinctMap.#ctor(Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Initializes a new instance of the OrderedDistinctMap class.
            </summary>
            <param name="lastHash">The previous hash from the previous continuation.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.OrderedDistinctMap.Add(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement,Microsoft.Azure.Cosmos.UInt128@)">
            <summary>
            Adds a JToken to this map if it hasn't already been added.
            </summary>
            <param name="cosmosElement">The element to add.</param>
            <param name="hash">The hash of the token.</param>
            <returns>Whether or not the item was added to this Distinct Map.</returns>
            <remarks>This function assumes data is added in sorted order.</remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues">
            <summary>
            Flags for all the simple json values, so that we don't need a separate hash for them.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.None">
            <summary>
            None JSON Value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.Undefined">
            <summary>
            Undefined JSON Value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.Null">
            <summary>
            Null JSON Value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.False">
            <summary>
            False JSON Value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.True">
            <summary>
            True JSON Value.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.EmptyString">
            <summary>
            Empty String.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.EmptyArray">
            <summary>
            Empty Array.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues.EmptyObject">
            <summary>
            Empty Object.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap">
            <summary>
            For distinct queries we need to keep a running hash set of all the documents seen.
            You can read more about this in DistinctDocumentQueryExecutionComponent.cs.
            This class does that with the additional optimization that it doesn't store the whole JSON.
            Instead this class takes a GUID like hash and store that instead.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.UInt128Length">
            <summary>
            Length of UInt128 (in bytes).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.ULongLength">
            <summary>
            Length of ulong (in bytes).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.UIntLength">
            <summary>
            Length of uint (in bytes).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.numbers">
            <summary>
            HashSet for all numbers seen.
            This takes less space than a 24 byte hash and has full fidelity.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.stringsLength4">
            <summary>
            HashSet for all strings seen of length less than or equal to 4 stored as a uint.
            This takes less space than a 24 byte hash and has full fidelity.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.stringsLength8">
            <summary>
            HashSet for all strings seen of length less than or equal to 8 stored as a ulong.
            This takes less space than a 24 byte hash and has full fidelity.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.stringsLength16">
            <summary>
            HashSet for all strings of length less than or equal to 16 stored as a UInt128.
            This takes less space than a 24 byte hash and has full fidelity.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.stringsLength16Plus">
            <summary>
            HashSet for all strings seen of length greater than 24 stored as a UInt192.
            This set only stores the hash, since we don't want to spend the space for storing large strings.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.arrays">
            <summary>
            HashSet for all arrays seen.
            This set only stores the hash, since we don't want to spend the space for storing large arrays.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.objects">
            <summary>
            HashSet for all object seen.
            This set only stores the hash, since we don't want to spend the space for storing large objects.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.simpleValues">
            <summary>
            Stores all the simple values that we don't want to dedicate a hash set for.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.Add(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement,Microsoft.Azure.Cosmos.UInt128@)">
            <summary>
            Adds a JToken to this map if it hasn't already been added.
            </summary>
            <param name="cosmosElement">The element to add.</param>
            <param name="hash">The hash of the token.</param>
            <returns>Whether or not the item was added to this Distinct Map.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.AddNumberValue(Microsoft.Azure.Cosmos.Number64)">
            <summary>
            Adds a number value to the map.
            </summary>
            <param name="value">The value to add.</param>
            <returns>Whether or not the value was successfully added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.AddSimpleValue(Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.SimpleValues)">
            <summary>
            Adds a simple value to the map.
            </summary>
            <param name="value">The simple value.</param>
            <returns>Whether or not the value was successfully added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.AddStringValue(System.String)">
            <summary>
            Adds a string to the distinct map.
            </summary>
            <param name="value">The string to add.</param>
            <returns>Whether or not the value was successfully added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.AddArrayValue(Microsoft.Azure.Cosmos.CosmosElements.CosmosArray)">
            <summary>
            Adds an array value to the distinct map.
            </summary>
            <param name="array">The array to add.</param>
            <returns>Whether or not the value was successfully added.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctMap.UnorderdDistinctMap.AddObjectValue(Microsoft.Azure.Cosmos.CosmosElements.CosmosObject)">
            <summary>
            Adds an object value to the distinct map.
            </summary>
            <param name="cosmosObject">The object to add.</param>
            <returns>Whether or not the value was successfully added.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage">
            <summary>
            Distinct queries return documents that are distinct with a page.
            This means that documents are not guaranteed to be distinct across continuations and partitions.
            The reasoning for this is because the backend treats each continuation of a query as a separate request
            and partitions are not aware of each other.
            The solution is that the client keeps a running hash set of all the documents it has already seen,
            so that when it encounters a duplicate document from another continuation it will not be emitted to the user.
            The only problem is that if the user chooses to go through the continuation token API for DocumentQuery instead
            of while(HasMoreResults) ExecuteNextAsync, then will see duplicates across continuations.
            There is no workaround for that use case, since the continuation token will have to include all the documents seen.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.ClientDistinctQueryPipelineStage">
            <summary>
            Client implementaiton of Distinct. Here we only serialize the continuation token if there is a matching DISTINCT.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.ClientDistinctQueryPipelineStage.DistinctContinuationToken">
            <summary>
            Continuation token for distinct queries.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.ClientDistinctQueryPipelineStage.DistinctContinuationToken.TryParse(Microsoft.Azure.Cosmos.CosmosElements.CosmosElement,Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.ClientDistinctQueryPipelineStage.DistinctContinuationToken@)">
            <summary>
            Tries to parse a DistinctContinuationToken from a string.
            </summary>
            <param name="cosmosElement">The value to parse.</param>
            <param name="distinctContinuationToken">The output DistinctContinuationToken.</param>
            <returns>True if we successfully parsed the DistinctContinuationToken, else false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.ClientDistinctQueryPipelineStage.DistinctContinuationToken.ToString">
            <summary>
            Gets the serialized form of DistinctContinuationToken
            </summary>
            <returns>The serialized form of DistinctContinuationToken</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.ComputeDistinctQueryPipelineStage">
            <summary>
            Compute implementation of DISTINCT.
            Here we never serialize the continuation token, but you can always retrieve it on demand with TryGetContinuationToken.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryPipelineStage.distinctMap">
            <summary>
            An DistinctMap that efficiently stores the documents that we have already seen.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryType">
            <summary>
            Enum of the type of distinct queries.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryType.None">
            <summary>
            This means that the query does not have DISTINCT.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryType.Unordered">
            <summary>
            This means that the query has DISTINCT, but it's not ordered perfectly.
            </summary>
            <example>SELECT DISTINCT VALUE c.name FROM c</example>
            <example>SELECT DISTINCT VALUE c.name FROM c ORDER BY c.age</example>
            <example>SELECT DISTINCT c.name FROM c ORDER BY c.name</example>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Distinct.DistinctQueryType.Ordered">
            <summary>
            This means that the query has DISTINCT, and it is ordered perfectly.
            </summary>
            <example>SELECT DISTINCT VALUE c.name FROM c ORDER BY c.name</example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.ExecutionEnvironment">
            <summary>
            Environment the query is going to be executed on.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.ExecutionEnvironment.Client">
            <summary>
            Query is being executed on a 3rd party client.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.Core.Pipeline.ExecutionEnvironment.Compute">
            <summary>
            Query is being executed on the compute gateway.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.GroupBy.GroupByQueryPipelineStage">
            <summary>
            Query execution component that groups groupings across continuations and pages.
            The general idea is a query gets rewritten from this:
            
            SELECT c.team, c.name, COUNT(1) AS count
            FROM c
            GROUP BY c.team, c.name
            
            To this:
            
            SELECT 
                [{"item": c.team}, {"item": c.name}] AS groupByItems, 
                {"team": c.team, "name": c.name, "count": {"item": COUNT(1)}} AS payload
            FROM c
            GROUP BY c.team, c.name
            
            With the following dictionary:
            
            {
                "team": null,
                "name": null,
                "count" COUNT
            }
            
            So we know how to aggregate each column. 
            At the end the columns are stitched together to make the grouped document.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.GroupBy.GroupByQueryPipelineStage.RewrittenGroupByProjection">
            <summary>
            When a group by query gets rewritten the projection looks like:
            
            SELECT 
                [{"item": c.age}, {"item": c.name}] AS groupByItems, 
                {"age": c.age, "name": c.name} AS payload
            
            This struct just lets us easily access the "groupByItems" and "payload" property.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken">
            <summary>
            A OffsetContinuationToken is a composition of a source continuation token and how many items to skip from that source.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the OffsetContinuationToken struct.
            </summary>
            <param name="offset">The number of items to skip in the query.</param>
            <param name="sourceToken">The continuation token for the source component of the query.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken.Offset">
            <summary>
            The number of items to skip in the query.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken.SourceToken">
            <summary>
            Gets the continuation token for the source component of the query.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken.TryParse(System.String,Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken@)">
            <summary>
            Tries to parse out the OffsetContinuationToken.
            </summary>
            <param name="value">The value to parse from.</param>
            <param name="offsetContinuationToken">The result of parsing out the token.</param>
            <returns>Whether or not the LimitContinuationToken was successfully parsed out.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ClientSkipQueryPipelineStage.OffsetContinuationToken.ToString">
            <summary>
            Gets the string version of the continuation token that can be passed in a response header.
            </summary>
            <returns>The string version of the continuation token that can be passed in a response header.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ComputeSkipQueryPipelineStage.OffsetContinuationToken">
            <summary>
            A OffsetContinuationToken is a composition of a source continuation token and how many items to skip from that source.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ComputeSkipQueryPipelineStage.OffsetContinuationToken.#ctor(System.Int64,Microsoft.Azure.Cosmos.CosmosElements.CosmosElement)">
            <summary>
            Initializes a new instance of the OffsetContinuationToken struct.
            </summary>
            <param name="offset">The number of items to skip in the query.</param>
            <param name="sourceToken">The continuation token for the source component of the query.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ComputeSkipQueryPipelineStage.OffsetContinuationToken.Offset">
            <summary>
            The number of items to skip in the query.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Skip.SkipQueryPipelineStage.ComputeSkipQueryPipelineStage.OffsetContinuationToken.SourceToken">
            <summary>
            Gets the continuation token for the source component of the query.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken">
            <summary>
            A LimitContinuationToken is a composition of a source continuation token and how many items we have left to drain from that source.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the LimitContinuationToken struct.
            </summary>
            <param name="limit">The limit to the number of document drained for the remainder of the query.</param>
            <param name="sourceToken">The continuation token for the source component of the query.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken.Limit">
            <summary>
            Gets the limit to the number of document drained for the remainder of the query.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken.SourceToken">
            <summary>
            Gets the continuation token for the source component of the query.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken.TryParse(System.String,Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken@)">
            <summary>
            Tries to parse out the LimitContinuationToken.
            </summary>
            <param name="value">The value to parse from.</param>
            <param name="limitContinuationToken">The result of parsing out the token.</param>
            <returns>Whether or not the LimitContinuationToken was successfully parsed out.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.LimitContinuationToken.ToString">
            <summary>
            Gets the string version of the continuation token that can be passed in a response header.
            </summary>
            <returns>The string version of the continuation token that can be passed in a response header.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken">
            <summary>
            A TopContinuationToken is a composition of a source continuation token and how many items we have left to drain from that source.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the TopContinuationToken struct.
            </summary>
            <param name="top">The limit to the number of document drained for the remainder of the query.</param>
            <param name="sourceToken">The continuation token for the source component of the query.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken.Top">
            <summary>
            Gets the limit to the number of document drained for the remainder of the query.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken.SourceToken">
            <summary>
            Gets the continuation token for the source component of the query.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken.TryParse(System.String,Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken@)">
            <summary>
            Tries to parse out the TopContinuationToken.
            </summary>
            <param name="value">The value to parse from.</param>
            <param name="topContinuationToken">The result of parsing out the token.</param>
            <returns>Whether or not the TopContinuationToken was successfully parsed out.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Take.TakeQueryPipelineStage.ClientTakeQueryPipelineStage.TopContinuationToken.ToString">
            <summary>
            Gets the string version of the continuation token that can be passed in a response header.
            </summary>
            <returns>The string version of the continuation token that can be passed in a response header.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Tokens.PipelineContinuationTokenV0">
            <summary>
            Pipelined continuation token before we started versioning continuation tokens.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Tokens.PipelineContinuationTokenV1">
            <summary>
            Pipelined continuation where we start versioning.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.Pipeline.Tokens.PipelineContinuationTokenV1_1">
            <summary>
            Pipelined continuation where we start versioning.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.ExecutionContext.CosmosQueryExecutionContextFactory.GetTargetPartitionKeyRangesAsync(Microsoft.Azure.Cosmos.Query.Core.QueryClient.CosmosQueryClient,System.String,Microsoft.Azure.Cosmos.Query.Core.QueryPlan.PartitionedQueryExecutionInfo,Microsoft.Azure.Cosmos.Query.Core.QueryClient.ContainerQueryProperties,System.Collections.Generic.IReadOnlyDictionary{System.String,System.Object},Microsoft.Azure.Cosmos.FeedRangeInternal,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Gets the list of partition key ranges. 
            1. Check partition key range id
            2. Check Partition key
            3. Check the effective partition key
            4. Get the range from the FeedToken
            5. Get the range from the PartitionedQueryExecutionInfo
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.ExecutionContext.CosmosQueryExecutionContextFactory.AggregateProjectionDetector.HasAggregate(Microsoft.Azure.Cosmos.SqlObjects.SqlSelectSpec)">
            <summary>
            Determines whether or not the SqlSelectSpec has an aggregate in the outer most query.
            </summary>
            <param name="selectSpec">The select spec to traverse.</param>
            <returns>Whether or not the SqlSelectSpec has an aggregate in the outer most query.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.ExecutionContext.CosmosQueryExecutionContextFactory.AggregateProjectionDetector.AggregateProjectionDectorVisitor.AggregateScalarExpressionDetector">
            <summary>
            Determines if there is an aggregate in a scalar expression.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.QueryClient.CosmosQueryClient.TryGetOverlappingRangesAsync(System.String,Microsoft.Azure.Documents.Routing.Range{System.String},System.Boolean)">
            <summary>
            Returns list of effective partition key ranges for a collection.
            </summary>
            <param name="collectionResourceId">Collection for which to retrieve routing map.</param>
            <param name="range">This method will return all ranges which overlap this range.</param>
            <param name="forceRefresh">Whether forcefully refreshing the routing map is necessary</param>
            <returns>List of effective partition key ranges for a collection or null if collection doesn't exist.</returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.QueryClient.CosmosQueryExecutionInfo.ReverseRidEnabled">
            <summary>
            Whether or not the backend has the reverseRid feature enabled.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.QueryClient.CosmosQueryExecutionInfo.ReverseIndexScan">
            <summary>
            Indicates the direction of the index scan.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.QueryPlan.QueryPlanHandler.TryGetQueryInfoAndIfSupportedAsync(Microsoft.Azure.Cosmos.Query.Core.QueryPlan.QueryFeatures,Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,Microsoft.Azure.Documents.PartitionKeyDefinition,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Used in the compute gateway to support legacy gateways query execution pattern.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.SqlParameter">
            <summary>
            Represents a parameter associated with <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec"/> in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Azure Cosmos DB SQL parameters are name-value pairs referenced in parameterized queries.
            Unlike in relation SQL databases, they don't have types associated with them.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlParameter"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlParameter"/> class with the name of the parameter for the Azure Cosmos DB service.
            </summary>
            <param name="name">The name of the parameter.</param>
            <remarks>Names of parameters must begin with '@' and be a valid SQL identifier.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Query.Core.SqlParameter"/> class with the name and value of the parameter for the Azure Cosmos DB service.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="value">The value of the parameter.</param>
            <remarks>Names of parameters must begin with '@' and be a valid SQL identifier. The value gets serialized and passed in as JSON to the document query.</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.Name">
            <summary>
            Gets or sets the name of the parameter for the Azure Cosmos DB service.
            </summary>
            <value>The name of the parameter.</value>
            <remarks>Names of parameters must begin with '@' and be a valid SQL identifier.</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.Value">
            <summary>
            Gets or sets the value of the parameter for the Azure Cosmos DB service.
            </summary>
            <value>The value of the parameter.</value>
            <remarks>The value gets serialized and passed in as JSON to the document query.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.Equals(Microsoft.Azure.Cosmos.Query.Core.SqlParameter)">
            <summary>
            Checking for equality between two Sql parameter objects.
            </summary>
            <param name="other"></param>
            <returns>True if objects are equal, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameter.GetHashCode">
            <summary>
            Simple implementation of hash code for SqlParameter class.
            </summary>
            <returns>Integer representing the hash code.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection">
            <summary>
            Represents a collection of parameters associated with <see cref="T:Microsoft.Azure.Documents.SqlQuerySpec"/> for use in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.#ctor">
            <summary>
            Initialize a new instance of the SqlParameterCollection class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.Query.Core.SqlParameter})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.SqlParameterCollection"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="parameters">The collection of parameters.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.IndexOf(Microsoft.Azure.Cosmos.Query.Core.SqlParameter)">
            <summary>
            Determines the index of a specific item in the Azure Cosmos DB collection.
            </summary> 
            <param name="item">The item to find.</param>
            <returns>The index value for the item.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Insert(System.Int32,Microsoft.Azure.Cosmos.Query.Core.SqlParameter)">
            <summary>
            Inserts an item at the specified index in the Azure Cosmos DB collection.
            </summary>
            <param name="index">The location in the index array in which to start inserting elements.</param>
            <param name="item">The item to copy into the index.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified index from the Azure Cosmos DB collection.
            </summary>
            <param name="index">The location in the index where the item will be removed from.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index in the Azure Cosmos DB collection.
            </summary>
            <param name="index">The location in the index.</param>
            <value>The element at the specified index.</value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Add(Microsoft.Azure.Cosmos.Query.Core.SqlParameter)">
            <summary>
            Adds an item to the Azure Cosmos DB collection.
            </summary>
            <param name="item">The item to add to the collection.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Clear">
            <summary>
            Removes all items from the Azure Cosmos DB collection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Contains(Microsoft.Azure.Cosmos.Query.Core.SqlParameter)">
            <summary>
            Determines whether the Azure Cosmos DB collection contains a specific value.
            </summary>
            <param name="item">The value to search for.</param>
            <returns>true if the collection contains a specific value; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.CopyTo(Microsoft.Azure.Cosmos.Query.Core.SqlParameter[],System.Int32)">
            <summary>
            Copies the elements of the Azure Cosmos DB collection to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.</summary>
            <param name="array">The array to copy into.</param>
            <param name="arrayIndex">The location in the index array in which to start adding elements.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Count">
            <summary>
            Gets the number of elements contained in the Azure Cosmos DB collection.
            </summary>
            <value>The number of elements contained in the collection.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.IsReadOnly">
            <summary>
            Gets a value indicating whether the Azure Cosmos DB collection is read-only.
            </summary>
            <value>true if the collection is read-only; otherwise, false.</value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.Remove(Microsoft.Azure.Cosmos.Query.Core.SqlParameter)">
            <summary>
            /// Removes the first occurrence of a specific object from the Azure Cosmos DB collection.
            </summary>
            <param name="item">
            The item to remove from the collection.
            </param>
            <returns>true if the first item was removed; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the Azure Cosmos DB collection.
            </summary>
            <returns>An enumerator for the collection.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the Azure Cosmos DB collection.
            </summary>
            <returns>An enumerator to iterate through the collection. </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec">
            <summary>
            Represents a SQL query in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.SqlQuerySpec"/> class for the Azure Cosmos DB service.</summary>
            <remarks> 
            The default constructor initializes any fields to their default values.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.SqlQuerySpec"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="queryText">The text of the query.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.#ctor(System.String,Microsoft.Azure.Cosmos.Query.Core.SqlParameterCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Documents.SqlQuerySpec"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="queryText">The text of the database query.</param>
            <param name="parameters">The <see cref="T:Microsoft.Azure.Documents.SqlParameterCollection"/> instance, which represents the collection of query parameters.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.QueryText">
            <summary>
            Gets or sets the text of the Azure Cosmos DB database query.
            </summary>
            <value>The text of the database query.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.Parameters">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Azure.Documents.SqlParameterCollection"/> instance, which represents the collection of Azure Cosmos DB query parameters.
            </summary>
            <value>The <see cref="T:Microsoft.Azure.Documents.SqlParameterCollection"/> instance.</value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.ShouldSerializeParameters">
            <summary>
            Returns a value that indicates whether the Azure Cosmos DB database <see cref="P:Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec.Parameters"/> property should be serialized.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.DefaultDocumentQueryExecutionContext">
            <summary>
            Default document query execution context for single partition queries or for split proofing general requests.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.DefaultDocumentQueryExecutionContext.isContinuationExpected">
            <summary>
            Whether or not a continuation is expected.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.DocumentQueryExecutionContextFactory">
            <summary>
            Factory class for creating the appropriate DocumentQueryExecutionContext for the provided type of query.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.DocumentQueryExecutionContextFactory.GetTargetPartitionKeyRangesAsync(Microsoft.Azure.Cosmos.Query.DefaultDocumentQueryExecutionContext,Microsoft.Azure.Cosmos.Query.Core.QueryPlan.PartitionedQueryExecutionInfo,Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Gets the list of partition key ranges. 
            1. Check partition key range id
            2. Check Partition key
            3. Check the effective partition key
            4. Get the range from the PartitionedQueryExecutionInfo
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.QueryCompatibilityMode">
            <summary>
            A client query compatibility mode when making query request.
            Can be used to force a specific query request format.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.QueryCompatibilityMode.Default">
            <summary>
            Default (latest) query format.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.QueryCompatibilityMode.Query">
            <summary>
            Query (application/query+json).
            Default.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Query.QueryCompatibilityMode.SqlQuery">
            <summary>
            SqlQuery (application/sql).
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.IDocumentQueryExecutionContext">
            <summary>
            Interface for all document query execution contexts
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Query.IDocumentQueryExecutionContext.IsDone">
            <summary>
            Gets a value indicating whether or not the context is done serving documents.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Query.IDocumentQueryExecutionContext.ExecuteNextFeedResponseAsync(System.Threading.CancellationToken)">
            <summary>
            Executes the context to feed the next page of results.
            </summary>
            <param name="token">The cancellation token.</param>
            <returns>A task to await on, which in return provides a DoucmentFeedResponse of documents.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Query.ProxyDocumentQueryExecutionContext">
            <summary>
            This class is used as a proxy to wrap the DefaultDocumentQueryExecutionContext which is needed 
            for sending the query to Gateway first and then uses PipelinedDocumentQueryExecutionContext after
            it gets the necessary info. This has been added since we
            haven't produced Linux/Mac version of the ServiceInterop native binary which holds the logic for
            parsing the query without having this extra hop to Gateway
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DocumentFeedResponse`1">
            <summary>
            Represents the template class used by feed methods (enumeration operations) for the Azure Cosmos DB service.
            </summary>
            <typeparam name="T">The feed type.</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.#ctor">
            <summary>
            Constructor exposed for mocking purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructor exposed for mocking purposes.
            </summary>
            <param name="result"></param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.RequestStatistics">
            <summary>
            Get the client side request statistics for the current request.
            </summary>
            <remarks>
            This value is currently used for tracking replica Uris.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.ResponseLengthBytes">
            <summary>
            Gets the response length in bytes
            </summary>
            <remarks>
            This value is only set for Direct mode.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.DatabaseQuota">
            <summary>
            Gets the maximum quota for database resources within the account from the Azure Cosmos DB service. 
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.DatabaseUsage">
            <summary>
            Gets the current number of database resources within the account from the Azure Cosmos DB service.
            </summary>
            <value>
            The number of databases.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.CollectionQuota">
            <summary>
            Gets the maximum quota for collection resources within an account from the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.CollectionUsage">
            <summary>
            Gets the current number of collection resources within the account from the Azure Cosmos DB service.
            </summary>
            <value>
            The number of collections.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.UserQuota">
            <summary>
            Gets the maximum quota for user resources within an account from the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.UserUsage">
            <summary>
            Gets the current number of user resources within the account from the Azure Cosmos DB service.
            </summary>
            <value>
            The number of users.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.PermissionQuota">
            <summary>
            Gets the maximum quota for permission resources within an account from the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.PermissionUsage">
            <summary>
            Gets the current number of permission resources within the account from the Azure Cosmos DB service. 
            </summary>
            <value>
            The number of permissions.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.CollectionSizeQuota">
            <summary>
            Gets the maximum size of a collection in kilobytes from the Azure Cosmos DB service.
            </summary>
            <value>
            Quota in kilobytes.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.CollectionSizeUsage">
            <summary>
            Gets the current size of a collection in kilobytes from the Azure Cosmos DB service. 
            </summary>
            <vallue>
            Current collection size in kilobytes.
            </vallue>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.StoredProceduresQuota">
            <summary>
            Gets the maximum quota of stored procedures for a collection from the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum quota.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.StoredProceduresUsage">
            <summary>
            Gets the current number of stored procedures for a collection from the Azure Cosmos DB service.
            </summary>
            <value>
            Current number of stored procedures.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.TriggersQuota">
            <summary>
            Gets the maximum quota of triggers for a collection from the Azure Cosmos DB service. 
            </summary>
            <value>
            The maximum quota.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.TriggersUsage">
            <summary>
            Get the current number of triggers for a collection from the Azure Cosmos DB service.
            </summary>
            <value>
            Current number of triggers.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.UserDefinedFunctionsQuota">
            <summary>
            Gets the maximum quota of user defined functions for a collection from the Azure Cosmos DB service. 
            </summary>
            <value>
            Maximum quota.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.UserDefinedFunctionsUsage">
            <summary>
            Gets the current number of user defined functions for a collection from the Azure Cosmos DB service.
            </summary>
            <value>
            Current number of user defined functions.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.Count">
            <summary>
            Gets the number of items returned in the response from the Azure Cosmos DB service.
            </summary>
            <value>
            Count of items in the response.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.MaxResourceQuota">
            <summary>
            Gets the maximum size limit for this entity from the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum size limit for this entity. Measured in kilobytes for document resources 
            and in counts for other resources.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.CurrentResourceQuotaUsage">
            <summary>
            Gets the current size of this entity from the Azure Cosmos DB service.
            </summary>
            <value>
            The current size for this entity. Measured in kilobytes for document resources 
            and in counts for other resources.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.RequestCharge">
            <summary>
            Gets the request charge for this request from the Azure Cosmos DB service.
            </summary>
            <value>
            The request charge measured in reqest units.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.ActivityId">
            <summary>
            Gets the activity ID for the request from the Azure Cosmos DB service.
            </summary>
            <value>
            The activity ID for the request.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.ResponseContinuation">
            <summary>
            Gets the continuation token to be used for continuing enumeration of the Azure Cosmos DB service.
            </summary>
            <value>
            The continuation token to be used for continuing enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.SessionToken">
            <summary>
            Gets the session token for use in sesssion consistency reads from the Azure Cosmos DB service.
            </summary>
            <value>
            The session token for use in session consistency.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.ContentLocation">
            <summary>
            Gets the content parent location, for example, dbs/foo/colls/bar, from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.ETag">
            <summary>
            Gets the entity tag associated with last transaction in the Azure Cosmos DB service,
            which can be used as If-Non-Match Access condition for ReadFeed REST request or 
            ContinuationToken property of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedOptions"/> parameter for
            <see cref="M:Microsoft.Azure.Cosmos.DocumentClient.CreateDocumentChangeFeedQuery(System.String,Microsoft.Azure.Cosmos.ChangeFeedOptions)"/> 
            to get feed changes since the transaction specified by this entity tag.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.ResponseHeaders">
            <summary>
            Gets the response headers from the Azure Cosmos DB service.
            </summary>
            <value>
            The response headers.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.QueryMetrics">
            <summary>
            Get QueryMetrics for each individual partition in the Azure Cosmos DB service
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.InternalResponseContinuation">
            <summary>
            Gets the continuation token to be used for continuing enumeration of the Azure Cosmos DB service.
            </summary>
            <value>
            The continuation token to be used for continuing enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.RequestDiagnosticsString">
            <summary>
            Gets a dump for troubleshooting the request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DocumentFeedResponse`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection from the Azure Cosmos DB service.
            </summary>
            <returns>An IEnumerator object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1">
            <summary>
            Captures APIs for responses associated with feed methods (enumeration operations) in the Azure Cosmos DB service.
            Interface exposed for mocking purposes.
            </summary>
            <typeparam name="T">The feed type.</typeparam>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.DatabaseQuota">
            <summary>
            Gets the maximum quota for database resources within the Azure Cosmos DB database account. 
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.DatabaseUsage">
            <summary>
            The current number of database resources within the Azure Cosmos DB database account.
            </summary>
            <value>
            The number of databases.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.CollectionQuota">
            <summary>
            Gets the maximum quota for collection resources within the Azure Cosmos DB database account.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.CollectionUsage">
            <summary>
            The current number of collection resources within the Azure Cosmos DB database account.
            </summary>
            <value>
            The number of collections.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.UserQuota">
            <summary>
            Gets the maximum quota for user resources within the Azure Cosmos DB database account.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.UserUsage">
            <summary>
            The current number of user resources within the Azure Cosmos DB database account.
            </summary>
            <value>
            The number of users.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.PermissionQuota">
            <summary>
            Gets the maximum quota for permission resources within the Azure Cosmos DB database account.
            </summary>
            <value>
            The maximum quota for the account.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.PermissionUsage">
            <summary>
            The current number of permission resources within the Azure Cosmos DB database account. 
            </summary>
            <value>
            The number of permissions.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.CollectionSizeQuota">
            <summary>
            Maximum size of a collection in the Azure Cosmos DB database in kilobytes.
            </summary>
            <value>
            Quota in kilobytes.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.CollectionSizeUsage">
            <summary>
            Current size of a collection in the Azure Cosmos DB database in kilobytes. 
            </summary>
            <vallue>
            Current collection size in kilobytes.
            </vallue>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.StoredProceduresQuota">
            <summary>
            Gets the maximum quota of stored procedures for a collection in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum quota.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.StoredProceduresUsage">
            <summary>
            The current number of stored procedures for a collection in the Azure Cosmos DB service.
            </summary>
            <value>
            Current number of stored procedures.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.TriggersQuota">
            <summary>
            Gets the maximum quota of triggers for a collection in the Azure Cosmos DB service. 
            </summary>
            <value>
            The maximum quota.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.TriggersUsage">
            <summary>
            The current number of triggers for a collection in the Azure Cosmos DB service.
            </summary>
            <value>
            Current number of triggers.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.UserDefinedFunctionsQuota">
            <summary>
            Gets the maximum quota of user defined functions for a collection in the Azure Cosmos DB service. 
            </summary>
            <value>
            Maximum quota.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.UserDefinedFunctionsUsage">
            <summary>
            The current number of user defined functions for a collection in the Azure Cosmos DB service.
            </summary>
            <value>
            Current number of user defined functions.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.Count">
            <summary>
            Gets the number of items returned in the response associated with the feed operations for the Azure Cosmos DB service.
            </summary>
            <value>
            Count of items in the response.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.MaxResourceQuota">
            <summary>
            Gets the maximum size limit for this entity in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum size limit for this entity. Measured in kilobytes for document resources 
            and in counts for other resources.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.CurrentResourceQuotaUsage">
            <summary>
            Gets the current size of this entity in the Azure Cosmos DB service.
            </summary>
            <value>
            The current size for this entity. Measured in kilobytes for document resources 
            and in counts for other resources.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.RequestCharge">
            <summary>
            Gets the request charge for the Azure Cosmos DB database account for this request
            </summary>
            <value>
            The request charge measured in reqest units.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.ActivityId">
            <summary>
            Gets the activity ID for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The activity ID for the request.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.ResponseContinuation">
            <summary>
            Gets the continuation token to be used for continuing enumeration in the Azure Cosmos DB service.
            </summary>
            <value>
            The continuation token to be used for continuing enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.SessionToken">
            <summary>
            Gets the session token for use in sesssion consistency reads in the Azure Cosmos DB service.
            </summary>
            <value>
            The session token for use in session consistency.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.ContentLocation">
            <summary>
            The content parent location in the Azure Cosmos DB database, for example, dbs/foo/colls/bar
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.ResponseHeaders">
            <summary>
            Gets the response headers.
            </summary>
            <value>
            The response headers.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IDocumentFeedResponse`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection in the Azure Cosmos DB service.
            </summary>
            <returns>An IEnumerator object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeGoneRetryPolicy.ShouldRetryAsync(System.Exception,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="exception">Exception that occured when the operation was tried</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PartitionKeyRangeGoneRetryPolicy.ShouldRetryAsync(Microsoft.Azure.Cosmos.ResponseMessage,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="cosmosResponseMessage"><see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> in return of the request</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosQueryClientCore.ParseElementsFromRestStream(System.IO.Stream,Microsoft.Azure.Documents.ResourceType,Microsoft.Azure.Cosmos.CosmosSerializationFormatOptions)">
            <summary>
            Converts a list of CosmosElements into a memory stream.
            </summary>
            <param name="stream">The memory stream response for the query REST response Azure Cosmos</param>
            <param name="resourceType">The resource type</param>
            <param name="cosmosSerializationOptions">The custom serialization options. This allows custom serialization types like BSON, JSON, or other formats</param>
            <returns>An array of CosmosElements parsed from the response body.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedResponse`1">
            <summary>
            The user contract for the various feed responses that serialized the responses to a type.
            To follow the .NET standard for typed responses any exceptions should be thrown to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedResponse`1.#ctor">
            <summary>
            Create an empty cosmos feed response for mock testing
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedResponse`1.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedResponse`1.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedResponse`1.ETag">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedResponse`1.ContinuationToken">
            <summary>
            Gets the continuation token to be used for continuing enumeration of the Azure Cosmos DB service.
            </summary>
            <value>
            The continuation token to be used for continuing enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedResponse`1.Count">
            <summary>
            The number of items in the stream.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedResponse`1.IndexMetrics">
            <summary>
            Gets the index utilization metrics to be used for debugging purposes. 
            It's applicable to query response only. Other feed response will return null for this field.
            This result is only available if QueryRequestOptions.PopulateIndexMetrics is set to true.
            </summary>
            <value>
            The index utilization metrics.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedResponse`1.GetEnumerator">
            <summary>
            Get an enumerator of the object.
            </summary>
            <returns>An instance of an Enumerator</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedResponse`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator of the object.
            </summary>
            <returns>An instance of an Enumerator</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.QueryDefinition">
            <summary>
            Defines a Cosmos SQL query
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinition.#ctor(System.String)">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>
            </summary>
            <param name="query">A valid Cosmos SQL query "Select * from test t"</param>
            <example>
            <code language="c#">
            <![CDATA[
            QueryDefinition query = new QueryDefinition(
                "select * from t where t.Account = @account")
                .WithParameter("@account", "12345");
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryDefinition.QueryText">
            <summary>
            Gets the text of the Azure Cosmos DB SQL query.
            </summary>
            <value>The text of the SQL query.</value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinition.WithParameter(System.String,System.Object)">
            <summary>
            Add parameters to the SQL query
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="value">The value for the parameter.</param>
            <remarks>
            If the same name is added again it will replace the original value
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            QueryDefinition query = new QueryDefinition(
                "select * from t where t.Account = @account")
                .WithParameter("@account", "12345");
            ]]>
            </code>
            </example>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinition.WithParameterStream(System.String,System.IO.Stream)">
            <summary>
            Add parameters with Stream Value to the SQL query.       
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="valueStream">The stream value for the parameter.</param>
            <remarks>
            UseCase : This is useful in cases like running a Query on Encrypted Values, where the value is generated post serialization and then encrypted 
            and we don't want to change the cipher value due to a call to serializer again.
            If the same name is added again it will replace the original value.
            </remarks>        
            <example>
            <code language="c#">
            <![CDATA[
            QueryDefinition query = new QueryDefinition(
                "select * from t where t.Account = @account")
                .WithParameterStream("@account", streamValue);
            ]]>
            </code>
            </example>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinition.GetQueryParameters">
            <summary>
            Returns the names and values of parameters in this <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
            </summary>
            <returns>
            A list of name/value tuples representing the parameters of this <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
            </returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryDefinition.Parameters">
            <summary>
            Gets the sql parameters for the class
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.QueryDefinitionEqualityComparer">
            <summary>
            Custom comparer class to check equality for query definition. This class does not check for
            logical equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinitionEqualityComparer.Equals(Microsoft.Azure.Cosmos.QueryDefinition,Microsoft.Azure.Cosmos.QueryDefinition)">
            <summary>
            Checks for equality of two QueryDefinitions. Two queries are considered equal if
            1. They are the same object in memory
            2. Their query text is exactly the same AND they provide the same parameter values.
            Following are NOT Equal: (SELECT * FROM c WHERE c.A= @param1 AND c.B=@param2 , param1=val1, param2=val2), (SELECT * FROM c WHERE c.B= @param2 AND c.A=@param1 , param1=val1, param2=val2)
            Following are Equal: (SELECT * FROM c WHERE c.A= @param1 AND c.B=@param2 , param1=val1, param2=val2), (SELECT * FROM c WHERE c.A= @param1 AND c.B=@param2 , param2=val2, param1=val1)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>Boolean representing the equality</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinitionEqualityComparer.GetHashCode(Microsoft.Azure.Cosmos.QueryDefinition)">
            <summary>
            Caculates a hashcode of QueryDefinition, ignoring order of sqlParameters.
            </summary>
            <returns>Hash code of the object.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryDefinitionEqualityComparer.ParameterEquals(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.SqlParameter},System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.Query.Core.SqlParameter})">
            <summary>
            Checks if two sets of parameters have the same values.
            </summary>
            <param name="parameters"></param>
            <param name="otherParameters"></param>
            <returns>True if parameters have the same values.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.QueryResponse">
            <summary>
            Represents the template class used by feed methods (enumeration operations) for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryResponse.#ctor">
            <summary>
            Used for unit testing only
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryResponse.ResponseLengthBytes">
            <summary>
            Gets the response length in bytes
            </summary>
            <remarks>
            This value is only set for Direct mode.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.QueryResponse`1">
            <summary>
            The cosmos query response
            </summary>
            <typeparam name="T">The type for the query response.</typeparam>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Reactive.EmptyAsyncEnumerator`1">
            <summary>
            Emits no items but terminates normally.
            </summary>
            <typeparam name="T">The type of the items.</typeparam>
            <seealso href="http://reactivex.io/documentation/operators/empty-never-throw.html"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Reactive.JustAsyncEnumerator`1">
            <summary>
            Emits a particular item (or series of items).
            </summary>
            <typeparam name="T">The type of the item(s)</typeparam>
            <seealso href="http://reactivex.io/documentation/operators/just.html"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ReadFeedKeyType">
            <summary>
            Type of Start and End key for ReadFeedKey
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ReadFeedKeyType.ResourceId">
            <summary>
             Use ResourceName
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ReadFeedKeyType.EffectivePartitionKey">
            <summary>
            Use EffectivePartitionKey
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ReadFeed.ReadFeedIteratorCore">
            <summary>
            Cosmos feed stream iterator. This is used to get the query responses with a Stream content
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ReadFeed.ReadFeedIteratorCore.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A query response from cosmos service</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ReadManyRequestOptions">
            <summary>
            The Cosmos query request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ReadManyRequestOptions.ConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            Azure Cosmos DB offers 5 different consistency levels. Strong, Bounded Staleness, Session, Consistent Prefix and Eventual - in order of strongest to weakest consistency. <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
            <para>
            While this is set at a database account level, Azure Cosmos DB allows a developer to override the default consistency level
            for each individual request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ReadManyRequestOptions.SessionToken">
             <summary>
             Gets or sets the token for use with session consistency in the Azure Cosmos DB service.
             </summary>
             <value>
             The token for use with session consistency.
             </value>
            
             <remarks>
             One of the <see cref="P:Microsoft.Azure.Cosmos.ReadManyRequestOptions.ConsistencyLevel"/> for Azure Cosmos DB is Session. In fact, this is the default level applied to accounts.
             <para>
             When working with Session consistency, each new write request to Azure Cosmos DB is assigned a new SessionToken.
             The CosmosClient will use this token internally with each read/query request to ensure that the set consistency level is maintained.
            
             <para>
             In some scenarios you need to manage this Session yourself;
             Consider a web application with multiple nodes, each node will have its own instance of <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>
             If you wanted these nodes to participate in the same session (to be able read your own writes consistently across web tiers)
             you would have to send the SessionToken from <see cref="T:Microsoft.Azure.Cosmos.FeedResponse`1"/> of the write action on one node
             to the client tier, using a cookie or some other mechanism, and have that token flow back to the web tier for subsequent reads.
             If you are using a round-robin load balancer which does not maintain session affinity between requests, such as the Azure Load Balancer,
             the read could potentially land on a different node to the write request, where the session was created.
             </para>
            
             <para>
             If you do not flow the Azure Cosmos DB SessionToken across as described above you could end up with inconsistent read results for a period of time.
             </para>
            
             </para>
             </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Regions">
            <summary>
            The LocationNames class contains the names of Azure regions that
            are currently supported by the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.WestUS">
            <summary>
            Name of the Azure West US region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.WestUS2">
            <summary>
            Name of the Azure West US 2 region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.WestCentralUS">
            <summary>
            Name of the Azure West Central US region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.EastUS">
            <summary>
            Name of the Azure East US region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.EastUS2">
            <summary>
            Name of the Azure East US 2 region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.CentralUS">
            <summary>
            Name of the Azure Central US region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SouthCentralUS">
            <summary>
            Name of the Azure Sourth Central US region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.NorthCentralUS">
            <summary>
            Name of the Azure North Central US region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.WestEurope">
            <summary>
            Name of the Azure West Europe region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.NorthEurope">
            <summary>
            Name of the Azure North Europe region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.EastAsia">
            <summary>
            Name of the Azure East Asia region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SoutheastAsia">
            <summary>
            Name of the Azure Southeast Asia region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.JapanEast">
            <summary>
            Name of the Azure Japan East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.JapanWest">
            <summary>
            Name of the Azure Japan West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.AustraliaEast">
            <summary>
            Name of the Azure Australia East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.AustraliaSoutheast">
            <summary>
            Name of the Azure Australia Southeast region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.CentralIndia">
            <summary>
            Name of the Azure Central India region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SouthIndia">
            <summary>
            Name of the Azure South India region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.WestIndia">
            <summary>
            Name of the Azure West India region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.CanadaEast">
            <summary>
            Name of the Azure Canada East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.CanadaCentral">
            <summary>
            Name of the Azure Canada Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.GermanyCentral">
            <summary>
            Name of the Azure Germany Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.GermanyNortheast">
            <summary>
            Name of the Azure Germany Northeast region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.ChinaNorth">
            <summary>
            Name of the Azure China North region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.ChinaEast">
            <summary>
            Name of the Azure China East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.ChinaNorth2">
            <summary>
            Name of the Azure China North 2 region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.ChinaEast2">
            <summary>
            Name of the Azure China East 2 region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.KoreaSouth">
            <summary>
            Name of the Azure Korea South region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.KoreaCentral">
            <summary>
            Name of the Azure Korea Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.UKWest">
            <summary>
            Name of the Azure UK West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.UKSouth">
            <summary>
            Name of the Azure UK South region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.BrazilSouth">
            <summary>
            Name of the Azure Brazil South region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USGovArizona">
            <summary>
            Name of the Azure USGov Arizona region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USGovTexas">
            <summary>
            Name of the Azure USGov Texas region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USGovVirginia">
            <summary>
            Name of the Azure USGov Virginia region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.EastUS2EUAP">
            <summary>
            Name of the Azure East US 2 EUAP region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.CentralUSEUAP">
            <summary>
            Name of the Azure Central US EUAP region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.FranceCentral">
            <summary>
            Name of the Azure France Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.FranceSouth">
            <summary>
            Name of the Azure France South region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USDoDCentral">
            <summary>
            Name of the Azure DoD Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USDoDEast">
            <summary>
            Name of the Azure DoD East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.AustraliaCentral">
            <summary>
            Name of the Azure Australia Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.AustraliaCentral2">
            <summary>
            Name of the Azure Australia Central 2 region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SouthAfricaNorth">
            <summary>
            Name of the Azure South Africa North region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SouthAfricaWest">
            <summary>
            Name of the Azure South Africa West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.UAECentral">
            <summary>
            Name of the Azure UAE Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.UAENorth">
            <summary>
            Name of the Azure UAE North region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USNatEast">
            <summary>
            Name of the Azure USNat East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USNatWest">
            <summary>
            Name of the Azure USNat West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USSecEast">
            <summary>
            Name of the Azure USSec East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.USSecWest">
            <summary>
            Name of the Azure USNat West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SwitzerlandNorth">
            <summary>
            Name of the Azure Switzerland North region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SwitzerlandWest">
            <summary>
            Name of the Azure Switzerland West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.GermanyNorth">
            <summary>
            Name of the Azure Germany North region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.GermanyWestCentral">
            <summary>
            Name of the Azure Germany West Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.NorwayEast">
            <summary>
            Name of the Azure Norway East region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.NorwayWest">
            <summary>
            Name of the Azure Norway West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.BrazilSoutheast">
            <summary>
            Name of the Azure Brazil Southeast region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.WestUS3">
            <summary>
            Name of the Azure West US 3 region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.JioIndiaCentral">
            <summary>
            Name of the Azure Jio India Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.JioIndiaWest">
            <summary>
            Name of the Azure Jio India West region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.EastUSSLV">
            <summary>
            Name of the Azure US SLV region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SwedenCentral">
            <summary>
            Name of the Azure Sweden Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.SwedenSouth">
            <summary>
            Name of the Azure Sweden South region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Regions.QatarCentral">
            <summary>
            Name of the Azure Qatar Central region in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RenameCollectionAwareClientRetryPolicy">
            <summary>
            This retry policy is designed to work with in a pair with ClientRetryPolicy.
            The inner retryPolicy must be a ClientRetryPolicy or a rety policy delegating to it.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedEstimatorRequestOptions">
            <summary>
            Request options for <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedEstimator"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedEstimatorRequestOptions.MaxItemCount">
            <summary>
            Gets or sets the maximum number of estimations to return per page.
            </summary>
            <remarks>
            If this value is greater than the number of leases, all estimations will be returned in the first page.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions">
            <summary>
            The Cosmos Change Feed request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions.PageSizeHint">
            <summary>
            Gets or sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum number of items to be returned in the enumeration operation.
            </value>
            <remarks>This is just a hint to the server which can return less or more items per page. If operations in the container are performed through stored procedures or transactional batch, <see href="https://docs.microsoft.com/azure/cosmos-db/stored-procedures-triggers-udfs#transactions">transaction scope</see> is preserved when reading items from the Change Feed. As a result, the number of items received could be higher than the specified value so that the items changed by the same transaction are returned as part of one atomic batch.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions.IfMatchEtag">
            <summary>
            IfMatchEtag is inherited from the base class but not used. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedRequestOptions.IfNoneMatchEtag">
            <summary>
            IfNoneMatchEtag is inherited from the base class but not used. 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ContainerRequestOptions">
            <summary>
            The cosmos container request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerRequestOptions.PopulateQuotaInfo">
            <summary>
             Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.ContainerRequestOptions.PopulateQuotaInfo"/> for document collection read requests in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para>
            PopulateQuotaInfo is used to enable/disable getting document collection quota related stats for document collection read requests.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ItemRequestOptions">
            <summary>
            Cosmos item request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.PreTriggers">
            <summary>
            Gets or sets the trigger to be invoked before the operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The trigger to be invoked before the operation.
            </value>
            <remarks>
            Only valid when used with Create, Replace and Delete methods for items.
            Currently only one PreTrigger is permitted per operation.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.PostTriggers">
            <summary>
            Gets or sets the trigger to be invoked after the operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The trigger to be invoked after the operation.
            </value>
            <remarks>
            Only valid when used with Create, Replace and Delete methods for items.
            Currently only one PostTriggers is permitted per operation.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.IndexingDirective">
            <summary>
            Gets or sets the indexing directive (Include or Exclude) for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The indexing directive to use with a request.
            </value>
            <seealso cref="T:Microsoft.Azure.Cosmos.IndexingPolicy"/>
            <seealso cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.IndexingDirective"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.SessionToken">
             <summary>
             Gets or sets the token for use with session consistency in the Azure Cosmos DB service.
             </summary>
             <value>
             The token for use with session consistency.
             </value>
            
             <remarks>
             One of the <see cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.ConsistencyLevel"/> for Azure Cosmos DB is Session. In fact, this is the default level applied to accounts.
             <para>
             When working with Session consistency, each new write request to Azure Cosmos DB is assigned a new SessionToken.
             The DocumentClient will use this token internally with each read/query request to ensure that the set consistency level is maintained.
            
             <para>
             In some scenarios you need to manage this Session yourself;
             Consider a web application with multiple nodes, each node will have its own instance of <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/>
             If you wanted these nodes to participate in the same session (to be able read your own writes consistently across web tiers)
             you would have to send the SessionToken from <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> of the write action on one node
             to the client tier, using a cookie or some other mechanism, and have that token flow back to the web tier for subsequent reads.
             If you are using a round-robin load balancer which does not maintain session affinity between requests, such as the Azure Load Balancer,
             the read could potentially land on a different node to the write request, where the session was created.
             </para>
            
             <para>
             If you do not flow the Azure Cosmos DB SessionToken across as described above you could end up with inconsistent read results for a period of time.
             </para>
            
             </para>
             </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.ConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            Azure Cosmos DB offers 5 different consistency levels. Strong, Bounded Staleness, Session, Consistent Prefix and Eventual - in order of strongest to weakest consistency. <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
            <para>
            While this is set at a database account level, Azure Cosmos DB allows a developer to override the default consistency level
            for each individual request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.EnableContentResponseOnWrite">
            <summary>
            Gets or sets the boolean to only return the headers and status code in
            the Cosmos DB response for write item operation like Create, Upsert, Patch and Replace.
            Setting the option to false will cause the response to have a null resource. This reduces networking and CPU load by not sending
            the resource back over the network and serializing it on the client.
            </summary>
            <example>
            <code language="c#">
            <![CDATA[
            ItemRequestOption requestOptions = new ItemRequestOptions() { EnableContentResponseOnWrite = false };
            ItemResponse itemResponse = await this.container.CreateItemAsync<ToDoActivity>(tests, new PartitionKey(test.status), requestOptions);
            Assert.AreEqual(HttpStatusCode.Created, itemResponse.StatusCode);
            Assert.IsNull(itemResponse.Resource);
            ]]>
            </code>
            </example>
            <remarks>
            This is optimal for workloads where the returned resource is not used.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemRequestOptions.DedicatedGatewayRequestOptions">
            <summary> 
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.DedicatedGatewayRequestOptions"/> for requests against the dedicated gateway.
            These options are only exercised when <see cref="T:Microsoft.Azure.Cosmos.ConnectionMode"/> is set to ConnectionMode.Gateway and the dedicated gateway endpoint is used for sending requests. 
            </summary>
            <remarks>
            Learn more about dedicated gateway <a href="https://azure.microsoft.com/services/cosmos-db/">here</a>. 
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PatchItemRequestOptions">
            <summary>
            Cosmos Patch request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PatchItemRequestOptions.FilterPredicate">
            <summary>
            Gets or sets condition to be checked before the patch operations in the Azure Cosmos DB service.
            </summary>
            <value>
            The condition to be checked before execution of operations.
            </value>
            <remarks>
            Condition can only be a from-clause of a sql statement.
            Creates a conditional SQL argument which is of format "FROM X where CONDITION",
            the condition has to be within the scope of the document which is supposed to be patched in the particular request.
            If the condition is satisfied the patch transaction will take place otherwise it will be returned with precondition failed.
            </remarks>
            <sample>
            PatchItemRequestOptions requestOptions = new PatchItemRequestOptions()
               {
                   FilterPredicate = "from c where c.taskNum = 3"
               };
            </sample>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.QueryRequestOptions">
            <summary>
            The Cosmos query request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.ResponseContinuationTokenLimitInKb">
            <summary>
             Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.QueryRequestOptions.ResponseContinuationTokenLimitInKb"/> request option for document query requests in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para> 
            ResponseContinuationTokenLimitInKb is used to limit the length of continuation token in the query response. Valid values are >= 0.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.EnableScanInQuery">
            <summary>
            Gets or sets the option to enable scans on the queries which couldn't be served
            as indexing was opted out on the requested paths in the Azure Cosmos DB service.
            </summary>
            <value>
            Option is true if scan on queries is enabled; otherwise, false.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.EnableLowPrecisionOrderBy">
            <summary>
            Gets or sets the option to enable low precision order by in the Azure Cosmos DB service.
            </summary>
            <value>
            The option to enable low-precision order by.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.MaxBufferedItemCount">
            <summary>
            Gets or sets the maximum number of items that can be buffered client side during 
            parallel query execution in the Azure Cosmos DB service. 
            A positive property value limits the number of buffered 
            items to the set value. If it is set to less than 0, the system automatically 
            decides the number of items to buffer.
            </summary>
            <value>
            The maximum count of items that can be buffered during parallel query execution.
            </value> 
            <remarks>
            This is only suggestive and cannot be abided by in certain cases.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.MaxItemCount">
            <summary>
            Gets or sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum number of items to be returned in the enumeration operation.
            </value> 
            <remarks>
            Used for query pagination.
            '-1' Used for dynamic page size.
            This is a maximum. Query can return 0 items in the page.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.MaxConcurrency">
            <summary>
            Gets or sets the number of concurrent operations run client side during 
            parallel query execution in the Azure Cosmos DB service. 
            A positive property value limits the number of 
            concurrent operations to the set value. If it is set to less than 0, the 
            system automatically decides the number of concurrent operations to run.
            </summary>
            <value>
            The maximum number of concurrent operations during parallel execution. 
            Defaults will be executed serially with no-parallelism
            </value> 
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.PartitionKey">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> for the current request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Only applicable to Item operations
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.PopulateIndexMetrics">
            <summary>
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.QueryRequestOptions.PopulateIndexMetrics"/> request option for document query requests in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para> 
            PopulateIndexMetrics is used to obtain the index metrics to understand how the query engine used existing indexes 
            and how it could use potential new indexes.
            The results will be displayed in FeedResponse.IndexMetrics. Please note that this options will incur overhead, so it should be 
            enabled only when debugging slow queries.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.ConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            Azure Cosmos DB offers 5 different consistency levels. Strong, Bounded Staleness, Session, Consistent Prefix and Eventual - in order of strongest to weakest consistency. <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
            <para>
            While this is set at a database account level, Azure Cosmos DB allows a developer to override the default consistency level
            for each individual request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.SessionToken">
             <summary>
             Gets or sets the token for use with session consistency in the Azure Cosmos DB service.
             </summary>
             <value>
             The token for use with session consistency.
             </value>
            
             <remarks>
             One of the <see cref="P:Microsoft.Azure.Cosmos.QueryRequestOptions.ConsistencyLevel"/> for Azure Cosmos DB is Session. In fact, this is the default level applied to accounts.
             <para>
             When working with Session consistency, each new write request to Azure Cosmos DB is assigned a new SessionToken.
             The CosmosClient will use this token internally with each read/query request to ensure that the set consistency level is maintained.
            
             <para>
             In some scenarios you need to manage this Session yourself;
             Consider a web application with multiple nodes, each node will have its own instance of <see cref="T:Microsoft.Azure.Cosmos.CosmosClient"/>
             If you wanted these nodes to participate in the same session (to be able read your own writes consistently across web tiers)
             you would have to send the SessionToken from <see cref="T:Microsoft.Azure.Cosmos.FeedResponse`1"/> of the write action on one node
             to the client tier, using a cookie or some other mechanism, and have that token flow back to the web tier for subsequent reads.
             If you are using a round-robin load balancer which does not maintain session affinity between requests, such as the Azure Load Balancer,
             the read could potentially land on a different node to the write request, where the session was created.
             </para>
            
             <para>
             If you do not flow the Azure Cosmos DB SessionToken across as described above you could end up with inconsistent read results for a period of time.
             </para>
            
             </para>
             </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.QueryRequestOptions.DedicatedGatewayRequestOptions">
            <summary> 
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.QueryRequestOptions.DedicatedGatewayRequestOptions"/> for requests against the dedicated gateway. Learn more about dedicated gateway <a href="https://azure.microsoft.com/en-us/services/cosmos-db/">here</a>. 
            These options are only exercised when <see cref="T:Microsoft.Azure.Cosmos.ConnectionMode"/> is set to ConnectionMode.Gateway and the dedicated gateway endpoint is used for sending requests. 
            These options have no effect otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.QueryRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RequestOptions">
            <summary>
            The default cosmos request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestOptions.IfMatchEtag">
            <summary>
            Gets or sets the If-Match (ETag) associated with the request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Most commonly used with the Delete* and Replace* methods of <see cref="T:Microsoft.Azure.Cosmos.Container"/> such as <see cref="M:Microsoft.Azure.Cosmos.Container.ReplaceItemAsync``1(``0,System.String,System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)"/>
            but can be used with other methods like <see cref="M:Microsoft.Azure.Cosmos.Container.ReadItemAsync``1(System.String,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)"/> for caching scenarios.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestOptions.IfNoneMatchEtag">
            <summary>
            Gets or sets the If-None-Match (ETag) associated with the request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Most commonly used to detect changes to the resource
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestOptions.Properties">
            <summary>
            Application opted Cosmos request context that flow through with the <see cref="T:Microsoft.Azure.Cosmos.RequestMessage" />.
            Context will be available through handlers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestOptions.IsEffectivePartitionKeyRouting">
            <summary>
            Gets or sets the boolean to use effective partition key routing in the cosmos db request.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RequestOptions.BaseConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the request in the Azure Cosmos DB service.
            Not every request supports consistency level. This allows each child to decide to expose it
            and use the same base logic
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            ConsistencyLevel compatibility will validated and set by RequestInvokeHandler
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestOptions.TryGetResourceUri(System.Uri@)">
            <summary>
            Gets the resource URI passed in as a request option. This is used by MongoDB and Cassandra implementation for performance reasons.
            </summary>
            <param name="resourceUri">The URI passed in from the request options</param>
            <returns>True if the object exists in the request options. False if the value was not passed in as a request option</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RequestOptions.SetSessionToken(Microsoft.Azure.Cosmos.RequestMessage,System.String)">
            <summary>
            Set the session token
            </summary>
            <param name="request">The current request.</param>
            <param name="sessionToken">The current session token.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.StandByFeedIteratorRequestOptions">
            <summary>
            The Cosmos Change Feed request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StandByFeedIteratorRequestOptions.MaxItemCount">
            <summary>
            Gets or sets the maximum number of items to be returned in the enumeration operation in the Azure Cosmos DB service.
            </summary>
            <value>
            The maximum number of items to be returned in the enumeration operation.
            </value> 
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StandByFeedIteratorRequestOptions.StartTime">
            <summary>
            Gets or sets a particular point in time to start to read the change feed.
            </summary>
            <remarks>
            Only applies in the case where no FeedToken is provided or the FeedToken was never used in a previous iterator.
            In order to read the Change Feed from the beginning, set this to DateTime.MinValue.ToUniversalTime().
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.StandByFeedIteratorRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions">
            <summary>
            The cosmos stored procedure request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.EnableScriptLogging">
            <summary>
             Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.EnableScriptLogging"/> for the current request in the Azure Cosmos DB service.
            </summary>
            <remarks>
            <para>
            EnableScriptLogging is used to enable/disable logging in JavaScript stored procedures.
            By default script logging is disabled.
            The log can also be accessible in response header (x-ms-documentdb-script-log-results).
            </para>
            </remarks>
            <example>
            To log, use the following in store procedure:
            <code language="JavaScript">
            <![CDATA[
            console.log("This is trace log");
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.SessionToken">
             <summary>
             Gets or sets the token for use with session consistency in the Azure Cosmos DB service.
             </summary>
             <value>
             The token for use with session consistency.
             </value>
            
             <remarks>
             One of the <see cref="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.ConsistencyLevel"/> for Azure Cosmos DB is Session. In fact, this is the default level applied to accounts.
             <para>
             When working with Session consistency, each new write request to Azure Cosmos DB is assigned a new SessionToken.
             The DocumentClient will use this token internally with each read/query request to ensure that the set consistency level is maintained.
            
             <para>
             In some scenarios you need to manage this Session yourself;
             Consider a web application with multiple nodes, each node will have its own instance of <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/>
             If you wanted these nodes to participate in the same session (to be able read your own writes consistently across web tiers)
             you would have to send the SessionToken from <see cref="T:Microsoft.Azure.Documents.Client.ResourceResponse`1"/> of the write action on one node
             to the client tier, using a cookie or some other mechanism, and have that token flow back to the web tier for subsequent reads.
             If you are using a round-robin load balancer which does not maintain session affinity between requests, such as the Azure Load Balancer,
             the read could potentially land on a different node to the write request, where the session was created.
             </para>
            
             <para>
             If you do not flow the Azure Cosmos DB SessionToken across as described above you could end up with inconsistent read results for a period of time.
             </para>
            
             </para>
             </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.ConsistencyLevel">
            <summary>
            Gets or sets the consistency level required for the request in the Azure Cosmos DB service.
            </summary>
            <value>
            The consistency level required for the request.
            </value>
            <remarks>
            Azure Cosmos DB offers 5 different consistency levels. Strong, Bounded Staleness, Session, Consistent Prefix and Eventual - in order of strongest to weakest consistency. <see cref="T:Microsoft.Azure.Cosmos.ConnectionPolicy"/>
            <para>
            While this is set at a database account level, Azure Cosmos DB allows a developer to override the default consistency level
            for each individual request.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.PopulateRequestOptions(Microsoft.Azure.Cosmos.RequestMessage)">
            <summary>
            Fill the CosmosRequestMessage headers with the set properties
            </summary>
            <param name="request">The <see cref="T:Microsoft.Azure.Cosmos.RequestMessage"/></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.Scripts">
            <summary>
            Represents script operations on an Azure Cosmos container.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.CreateStoredProcedureAsync(Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a stored procedure as an asynchronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="storedProcedureProperties">The Stored Procedure to create.</param>
             <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
              This creates and executes a stored procedure that appends a string to the first item returned from the query.
             <code language="c#">
             <![CDATA[
             string sprocBody = @"function simple(prefix)
                {
                    var collection = getContext().getCollection();
            
                    // Query documents and take 1st item.
                    var isAccepted = collection.queryDocuments(
                    collection.getSelfLink(),
                    'SELECT * FROM root r',
                    function(err, feed, options) {
                        if (err)throw err;
            
                        // Check the feed and if it's empty, set the body to 'no docs found',
                        // Otherwise just take 1st element from the feed.
                        if (!feed || !feed.length) getContext().getResponse().setBody(""no docs found"");
                        else getContext().getResponse().setBody(prefix + JSON.stringify(feed[0]));
                    });
            
                    if (!isAccepted) throw new Error(""The query wasn't accepted by the server. Try again/use continuation token between API and script."");
                }";
                
             Scripts scripts = this.container.Scripts;
             StoredProcedureProperties storedProcedure = new StoredProcedureProperties(id, sprocBody);
             StoredProcedureResponse storedProcedureResponse = await scripts.CreateStoredProcedureAsync(storedProcedure);
             
             // Execute the stored procedure
             CosmosItemResponse<string> sprocResponse = await scripts.ExecuteStoredProcedureAsync<string, string>(
                                           id, 
                                           "Item as a string: ", 
                                           new PartitionKey(testPartitionId));
             Console.WriteLine("sprocResponse.Resource");
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetStoredProcedureQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for stored procedures under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for sproc with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            string queryText = "SELECT * FROM s where s.id like @testId";
            QueryDefinition queryDefinition = new QueryDefinition(queryText);
            queryDefinition.WithParameter("@testId", "testSprocId");
            using (FeedIterator<StoredProcedureProperties> feedIterator = scripts.GetStoredProcedureQueryIterator<StoredProcedureProperties>(queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (StoredProcedureProperties storedProcedure in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(storedProcedure.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetStoredProcedureQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
             This method creates a query for stored procedures under a container using a SQL statement. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
             </summary>
             <param name="queryDefinition">The cosmos SQL query definition.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to read through the existing stored procedures.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This create the stream feed iterator for sproc with queryDefinition as input.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;
             string queryText = "SELECT * FROM s where s.id like @testId";
             QueryDefinition queryDefinition = new QueryDefinition(queryText);
             queryDefinition.WithParameter("@testId", "testSprocId");
             using (FeedIterator feedIterator = scripts.GetStoredProcedureQueryStreamIterator(queryDefinition))
             {
                 while (feedIterator.HasMoreResults)
                 {
                     // Stream iterator returns a response with status for errors
                     using(ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         // Handle failure scenario. 
                         if(!response.IsSuccessStatusCode)
                         {
                             // Log the response.Diagnostics and handle the error
                         }
            
                         // Process the response.Content Stream
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetStoredProcedureQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for stored procedures under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for sproc with queryText as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            using (FeedIterator<StoredProcedureProperties> feedIterator = this.scripts.GetStoredProcedureQueryIterator<StoredProcedureProperties>(
                "SELECT * FROM u where u.id like '%testId%'"))
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (StoredProcedureProperties properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetStoredProcedureQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
             This method creates a query for stored procedures under a container using a SQL statement. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
             </summary>
             <param name="queryText">The cosmos SQL query text.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to read through the existing stored procedures.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This create the stream feed iterator for sproc with queryText as input.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;
             string queryText = "SELECT * FROM s where s.id like '%testId%'";
             using (FeedIterator feedIterator = this.scripts.GetStoredProcedureQueryStreamIterator(queryText)
             {
                 while (feedIterator.HasMoreResults)
                 {
                     // Stream iterator returns a response with status for errors
                     using(ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         // Handle failure scenario. 
                         if(!response.IsSuccessStatusCode)
                         {
                             // Log the response.Diagnostics and handle the error
                         }
            
                         // Process the response.Content Stream
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ReadStoredProcedureAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The identifier of the Stored Procedure to read.</param>
            <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/>.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
             This reads an existing stored procedure.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            StoredProcedureResponse storedProcedure = await scripts.ReadStoredProcedureAsync("ExistingId");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ReplaceStoredProcedureAsync(Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> in the Azure Cosmos service as an asynchronous operation.
             </summary>
             <param name="storedProcedureProperties">The Stored Procedure to replace</param>
             <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>
             A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/>.
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This examples replaces an existing stored procedure.
             <code language="c#">
             <![CDATA[
             //Updated body
             string body = @"function AddTax() {
                 var item = getContext().getRequest().getBody();
            
                 // Validate/calculate the tax.
                 item.tax = item.cost* .15;
            
                 // Update the request -- this is what is going to be inserted.
                 getContext().getRequest().setBody(item);
             }";
             
             Scripts scripts = this.container.Scripts;
             StoredProcedureResponse response = await scripts.ReplaceStoredProcedureAsync(new StoredProcedureProperties("testTriggerId", body));
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.DeleteStoredProcedureAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="id">The identifier of the Stored Procedure to delete.</param>
            <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which will contain the response to the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This examples gets a reference to an existing stored procedure and deletes it.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            StoredProcedureResponse response = await scripts.DeleteStoredProcedureAsync("taxUdfId");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ExecuteStoredProcedureAsync``1(System.String,Microsoft.Azure.Cosmos.PartitionKey,System.Object[],Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Executes a stored procedure against a container as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <typeparam name="TOutput">The return type that is JSON serializable.</typeparam>
             <param name="storedProcedureId">The identifier of the Stored Procedure to execute.</param>
             <param name="partitionKey">The partition key for the item.</param>
             <param name="parameters">(Optional) An array of dynamic objects representing the parameters for the stored procedure.</param>
             <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
              This creates and executes a stored procedure that appends a string to the first item returned from the query.
             <code language="c#">
             <![CDATA[
             string sprocBody = @"function simple(prefix, postfix)
                {
                    var collection = getContext().getCollection();
            
                    // Query documents and take 1st item.
                    var isAccepted = collection.queryDocuments(
                    collection.getSelfLink(),
                    'SELECT * FROM root r',
                    function(err, feed, options) {
                        if (err)throw err;
            
                        // Check the feed and if it's empty, set the body to 'no docs found',
                        // Otherwise just take 1st element from the feed.
                        if (!feed || !feed.length) getContext().getResponse().setBody(""no docs found"");
                        else getContext().getResponse().setBody(prefix + JSON.stringify(feed[0]) + postfix);
                    });
            
                    if (!isAccepted) throw new Error(""The query wasn't accepted by the server. Try again/use continuation token between API and script."");
                }";
                
             Scripts scripts = this.container.Scripts;
             string sprocId = "appendString";
             StoredProcedureResponse storedProcedureResponse = await scripts.CreateStoredProcedureAsync(
                     sprocId,
                     sprocBody);
             
             // Execute the stored procedure
             StoredProcedureExecuteResponse<string> sprocResponse = await scripts.ExecuteStoredProcedureAsync<string>(
                                     sprocId,
                                     new PartitionKey(testPartitionId),
                                     new dynamic[] {"myPrefixString", "myPostfixString"});
                                     
             Console.WriteLine(sprocResponse.Resource);
             /// ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ExecuteStoredProcedureStreamAsync(System.String,Microsoft.Azure.Cosmos.PartitionKey,System.Object[],Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Executes a stored procedure against a container as an asynchronous operation in the Azure Cosmos service and obtains a Stream as response.
             </summary>
             <param name="storedProcedureId">The identifier of the Stored Procedure to execute.</param>
             <param name="partitionKey">The partition key for the item.</param>
             <param name="parameters">An array of dynamic objects representing the parameters for the stored procedure. This can be null if no parameters are required.</param>
             <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
              This creates and executes a stored procedure that appends a string to the first item returned from the query.
             <code language="c#">
             <![CDATA[
             string sprocBody = @"function simple(prefix, postfix)
                {
                    var collection = getContext().getCollection();
            
                    // Query documents and take 1st item.
                    var isAccepted = collection.queryDocuments(
                    collection.getSelfLink(),
                    'SELECT * FROM root r',
                    function(err, feed, options) {
                        if (err)throw err;
            
                        // Check the feed and if it's empty, set the body to 'no docs found',
                        // Otherwise just take 1st element from the feed.
                        if (!feed || !feed.length) getContext().getResponse().setBody(""no docs found"");
                        else getContext().getResponse().setBody(prefix + JSON.stringify(feed[0]) + postfix);
                    });
            
                    if (!isAccepted) throw new Error(""The query wasn't accepted by the server. Try again/use continuation token between API and script."");
                }";
                
             Scripts scripts = this.container.Scripts;
             string sprocId = "appendString";
             StoredProcedureResponse storedProcedureResponse = await scripts.CreateStoredProcedureAsync(
                     sprocId,
                     sprocBody);
             
             // Execute the stored procedure
             ResponseMessage sprocResponse = await scripts.ExecuteStoredProcedureStreamAsync(
                                     sprocId,
                                     new PartitionKey(testPartitionId),
                                     new dynamic[] {"myPrefixString", "myPostfixString"});
                                     
             using (StreamReader sr = new StreamReader(sprocResponse.Content))
             {
                 string stringResponse = await sr.ReadToEndAsync();
                 Console.WriteLine(stringResponse);
              }
             
             /// ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ExecuteStoredProcedureStreamAsync(System.String,System.IO.Stream,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Executes a stored procedure against a container as an asynchronous operation in the Azure Cosmos service and obtains a Stream as response.
             </summary>
             <param name="storedProcedureId">The identifier of the Stored Procedure to execute.</param>
             <param name="streamPayload">A <see cref="T:System.IO.Stream"/> containing the payload which should represent a JSON array or arraylike object of parameters. This is parsed using JSON.parse and Function.apply uses the result to call the stored procedure. This can be null if no parameters are required.</param>
             <param name="partitionKey">The partition key for the item.</param>
             <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>The task object representing the service response for the asynchronous operation which would contain any response set in the stored procedure. The response will contain status code (400) BadRequest if streamPayload represents anything other than a JSON array, object or null.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
              This creates and executes a stored procedure that appends a string to the first item returned from the query.
             <code language="c#">
             <![CDATA[
             string sprocBody = @"function simple(prefix, postfix)
                {
                    var collection = getContext().getCollection();
            
                    // Query documents and take 1st item.
                    var isAccepted = collection.queryDocuments(
                    collection.getSelfLink(),
                    'SELECT * FROM root r',
                    function(err, feed, options) {
                        if (err)throw err;
            
                        // Check the feed and if it's empty, set the body to 'no docs found',
                        // Otherwise just take 1st element from the feed.
                        if (!feed || !feed.length) getContext().getResponse().setBody(""no docs found"");
                        else getContext().getResponse().setBody(prefix + JSON.stringify(feed[0]) + postfix);
                    });
            
                    if (!isAccepted) throw new Error(""The query wasn't accepted by the server. Try again/use continuation token between API and script."");
                }";
                
             Scripts scripts = this.container.Scripts;
             string sprocId = "appendString";
             StoredProcedureResponse storedProcedureResponse = await scripts.CreateStoredProcedureAsync(
                     sprocId,
                     sprocBody);
            
             // Serialize the parameters into a stream
             string[] parameters = new string[] { "myPrefixString", "myPostfixString" };
             byte[] serializedBytes = JsonSerializer.SerializeToUtf8Bytes(parameters);
             MemoryStream streamPayload = new MemoryStream(serializedBytes);
             
             // Execute the stored procedure
             ResponseMessage sprocResponse = await scripts.ExecuteStoredProcedureStreamAsync(
                                     sprocId,
                                     streamPayload,
                                     new PartitionKey(testPartitionId));
                                     
             using (StreamReader sr = new StreamReader(sprocResponse.Content))
             {
                 string stringResponse = await sr.ReadToEndAsync();
                 Console.WriteLine(stringResponse);
              }
             
             /// ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.CreateTriggerAsync(Microsoft.Azure.Cosmos.Scripts.TriggerProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a trigger as an asynchronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="triggerProperties">The <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> object.</param>
             <param name="requestOptions">(Optional) The options for the stored procedure request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
              This creates a trigger then uses the trigger in a create item.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;
             TriggerResponse triggerResponse = await scripts.CreateTriggerAsync(
                 new TriggerProperties
                 {
                     Id = "addTax",
                     Body = @"function AddTax() {
                         var item = getContext().getRequest().getBody();
            
                         // calculate the tax.
                         item.tax = item.cost * .15;
            
                         // Update the request -- this is what is going to be inserted.
                         getContext().getRequest().setBody(item);
                     }",
                     TriggerOperation = TriggerOperation.All,
                     TriggerType = TriggerType.Pre
                 });
            
             ItemRequestOptions options = new ItemRequestOptions()
             {
                 PreTriggers = new List<string>() { triggerResponse.Id },
             };
            
             // Create a new item with trigger set in the request options
             ItemResponse<dynamic> createdItem = await this.container.Items.CreateItemAsync<dynamic>(item.status, item, options);
             double itemTax = createdItem.Resource.tax;
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetTriggerQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for triggers under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for Trigger with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM t where t.id like @testId")
                .WithParameter("@testId", "testTriggerId");
            using (FeedIterator<TriggerProperties> feedIterator = this.scripts.GetTriggerQueryIterator<TriggerProperties>(queryDefinition)
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (var properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetTriggerQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
             This method creates a query for triggers under a container using a SQL statement. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
             </summary>
             <param name="queryDefinition">The cosmos SQL query definition.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to read through the existing stored procedures.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This create the stream feed iterator for Trigger with queryDefinition as input.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;\
             QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM t where t.id like @testId")
              .WithParameter("@testId", "testTriggerId");
             using (FeedIterator feedIterator = this.scripts.GetTriggerQueryStreamIterator(queryDefinition)
             {
                 while (feedIterator.HasMoreResults)
                 {
                     // Stream iterator returns a response with status for errors
                     using(ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         // Handle failure scenario. 
                         if(!response.IsSuccessStatusCode)
                         {
                             // Log the response.Diagnostics and handle the error
                         }
            
                         // Process the response.Content Stream
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetTriggerQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for triggers under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for Trigger with queryText as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            using (FeedIterator<TriggerProperties> feedIterator = this.scripts.GetTriggerQueryIterator<TriggerProperties>(
                "SELECT * FROM t where t.id like '%testId%'")
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (var properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetTriggerQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for triggers under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the stream feed iterator for Trigger with queryText as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            string queryText = "SELECT * FROM t where t.id like '%testId%'";
            using (FeedIterator iter = this.scripts.GetTriggerQueryStreamIterator(queryText)
            {
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ReadTriggerAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The id of the trigger to read.</param>
            <param name="requestOptions">(Optional) The options for the trigger request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
             This reads an existing trigger
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            TriggerResponse response = await scripts.ReadTriggerAsync("ExistingId");
            TriggerProperties triggerProperties = response;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ReplaceTriggerAsync(Microsoft.Azure.Cosmos.Scripts.TriggerProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> in the Azure Cosmos service as an asynchronous operation.
             </summary>
             <param name="triggerProperties">The <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> object.</param>
             <param name="requestOptions">(Optional) The options for the trigger request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>
             A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> containing the updated resource record.
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This examples replaces an existing trigger.
             <code language="c#">
             <![CDATA[
             TriggerProperties triggerProperties = new TriggerProperties
             {
                 Id = "testTriggerId",
                 Body = @"function AddTax() {
                     var item = getContext().getRequest().getBody();
            
                     // Validate/calculate the tax.
                     item.tax = item.cost* .15;
            
                     // Update the request -- this is what is going to be inserted.
                     getContext().getRequest().setBody(item);
                 }",
                 TriggerOperation = TriggerOperation.All,
                 TriggerType = TriggerType.Post
             };
             
             Scripts scripts = this.container.Scripts;
             TriggerResponse response = await scripts.ReplaceTriggerAsync(triggerSettigs);
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.DeleteTriggerAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The id of the trigger to delete.</param>
            <param name="requestOptions">(Optional) The options for the trigger request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This examples gets a reference to an existing trigger and deletes it.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            TriggerResponse response = await scripts.DeleteTriggerAsync("existingId");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.CreateUserDefinedFunctionAsync(Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a user defined function as an asynchronous operation in the Azure Cosmos DB service.
             </summary>
             <param name="userDefinedFunctionProperties">The <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> object.</param>
             <param name="requestOptions">(Optional) The options for the user defined function request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A task object representing the service response for the asynchronous operation.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
              This creates a user defined function then uses the function in an item query.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;
             await scripts.UserDefinedFunctions.CreateUserDefinedFunctionAsync(
                 new UserDefinedFunctionProperties 
                 { 
                     Id = "calculateTax", 
                     Body = @"function(amt) { return amt * 0.05; }" 
                 });
            
             QueryDefinition sqlQuery = new QueryDefinition(
                 "SELECT VALUE udf.calculateTax(t.cost) FROM toDoActivity t where t.cost > @expensive and t.status = @status")
                 .WithParameter("@expensive", 9000)
                 .WithParameter("@status", "Done");
            
             using (FeedIterator<double> setIterator = this.container.Items.GetItemsQueryIterator<double>(
                 sqlQueryDefinition: sqlQuery,
                 partitionKey: "Done")
             {
                 while (setIterator.HasMoreResults)
                 {
                     foreach (var tax in await setIterator.ReadNextAsync())
                     {
                         Console.WriteLine(tax);
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetUserDefinedFunctionQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for user defined functions under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for UDF with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM u where u.id like @testId")
                .WithParameter("@testId", "testUDFId");
            using (FeedIterator<UserDefinedFunctionProperties> feedIterator = this.scripts.GetUserDefinedFunctionQueryIterator<UserDefinedFunctionProperties>(queryDefinition)
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (var properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetUserDefinedFunctionQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
             This method creates a query for user defined functions under a container using a SQL statement. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
             </summary>
             <param name="queryDefinition">The cosmos SQL query definition.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to read through the existing stored procedures.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This create the stream feed iterator for UDF with queryDefinition as input.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;
             QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM u where u.id like @testId")
               .WithParameter("@testId", "testUdfId");
             using (FeedIterator feedIterator = this.scripts.GetUserDefinedFunctionQueryStreamIterator(queryDefinition)
             {
                 while (feedIterator.HasMoreResults)
                 {
                     // Stream iterator returns a response with status for errors
                     using(ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         // Handle failure scenario. 
                         if(!response.IsSuccessStatusCode)
                         {
                             // Log the response.Diagnostics and handle the error
                         }
            
                         // Process the response.Content Stream
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetUserDefinedFunctionQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for user defined functions under a container using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to read through the existing stored procedures.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for UDF with queryText as input.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            using (FeedIterator<UserDefinedFunctionProperties> feedIterator = this.scripts.GetUserDefinedFunctionQueryIterator<UserDefinedFunctionProperties>(
                "SELECT * FROM u where u.id like '%testId%'")
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (var properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.GetUserDefinedFunctionQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
             This method creates a query for user defined functions under a container using a SQL statement. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
             </summary>
             <param name="queryText">The cosmos SQL query text.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to read through the existing stored procedures.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             This create the stream feed iterator for UDF with queryText as input.
             <code language="c#">
             <![CDATA[
             Scripts scripts = this.container.Scripts;
             using (FeedIterator feedIterator = this.scripts.GetUserDefinedFunctionQueryStreamIterator(
                 "SELECT * FROM u where u.id like '%testId%'")
             {
                 while (feedIterator.HasMoreResults)
                 {
                     // Stream iterator returns a response with status for errors
                     using(ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         // Handle failure scenario. 
                         if(!response.IsSuccessStatusCode)
                         {
                             // Log the response.Diagnostics and handle the error
                         }
            
                         // Process the response.Content Stream
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ReadUserDefinedFunctionAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="id">The id of the user defined function to read</param>
            <param name="requestOptions">(Optional) The options for the user defined function request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
             This reads an existing user defined function.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            UserDefinedFunctionResponse response = await scripts.ReadUserDefinedFunctionAsync("ExistingId");
            UserDefinedFunctionProperties udfProperties = response;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.ReplaceUserDefinedFunctionAsync(Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replaces a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> in the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="userDefinedFunctionProperties">The <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> object.</param>
            <param name="requestOptions">(Optional) The options for the user defined function request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> containing the updated resource record.
            </returns>
            <example>
            This examples replaces an existing user defined function.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            UserDefinedFunctionProperties udfProperties = new UserDefinedFunctionProperties
            {
                Id = "testUserDefinedFunId",
                Body = "function(amt) { return amt * 0.15; }",
            };
            
            UserDefinedFunctionResponse response = await scripts.ReplaceUserDefinedFunctionAsync(udfProperties);
            UserDefinedFunctionProperties udfProperties = response;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.Scripts.DeleteUserDefinedFunctionAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="id">The id of the user defined function to delete.</param>
            <param name="requestOptions">(Optional) The options for the user defined function request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This examples gets a reference to an existing user defined function and deletes it.
            <code language="c#">
            <![CDATA[
            Scripts scripts = this.container.Scripts;
            UserDefinedFunctionResponse response = await this.container.DeleteUserDefinedFunctionAsync("existingId");
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1">
            <summary>
            The cosmos stored procedure response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,`0,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.ETag">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.SessionToken">
            <summary>
            Gets the token for use with session consistency requests from the Azure Cosmos DB service.
            </summary>
            <value>
            The token for use with session consistency requests.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureExecuteResponse`1.ScriptLog">
            <summary>
            Gets the output from stored procedure console.log() statements.
            </summary>
            <value>
            Output from console.log() statements in a stored procedure.
            </value>
            <seealso cref="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.EnableScriptLogging"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse">
            <summary>
            The cosmos stored procedure response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.SessionToken">
            <summary>
            Gets the token for use with session consistency requests from the Azure Cosmos DB service.
            </summary>
            <value>
            The token for use with session consistency requests.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse.op_Implicit(Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse)~Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureResponse"/>
            </summary>
            <param name="response">CosmosUserDefinedFunctionResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.TriggerResponse">
            <summary>
            The cosmos trigger response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.Scripts.TriggerProperties,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.TriggerResponse.op_Implicit(Microsoft.Azure.Cosmos.Scripts.TriggerResponse)~Microsoft.Azure.Cosmos.Scripts.TriggerProperties">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.Scripts.TriggerResponse"/>
            </summary>
            <param name="response">CosmosUserDefinedFunctionResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse">
            <summary>
            The cosmos user defined function response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse.op_Implicit(Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse)~Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionResponse"/>
            </summary>
            <param name="response">UserDefinedFunctionResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties">
            <summary>
            Represents a stored procedure in the Azure Cosmos DB service.
            </summary>
            <remarks> 
            Azure Cosmos DB allows application logic written entirely in JavaScript to be executed directly inside the database engine under the database transaction.
            For additional details, refer to the server-side JavaScript API documentation.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.#ctor">
            <summary>
            Initializes a new instance of the Stored Procedure class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the Stored Procedure class for the Azure Cosmos DB service.
            </summary>
            <param name="id">The Id of the resource in the Azure Cosmos service.</param>
            <param name="body">The body of the Azure Cosmos DB stored procedure.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.Body">
            <summary>
            Gets or sets the body of the Azure Cosmos DB stored procedure.
            </summary>
            <value>The body of the stored procedure.</value>
            <remarks>Must be a valid JavaScript function. For e.g. "function () { getContext().getResponse().setBody('Hello World!'); }"</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.Id">
            <summary>
            Gets or sets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.LastModified">
            <summary>
            Gets the last modified timestamp associated with <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties" /> from the Azure Cosmos DB service.
            </summary>
            <value>The last modified timestamp associated with the resource.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.ResourceId">
            <summary>
            Gets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB 
            resource whether that is a database, a collection or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.TriggerOperation">
            <summary>
            Specifies the operations on which a trigger should be executed in the Azure Cosmos DB service.
            </summary> 
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerOperation.All">
            <summary>
            Specifies all operations.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerOperation.Create">
            <summary>
            Specifies create operations only.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerOperation.Update">
            <summary>
            Specifies update operations only.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerOperation.Delete">
            <summary>
            Specifies delete operations only.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerOperation.Replace">
            <summary>
            Specifies replace operations only.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.TriggerProperties">
            <summary>
            Represents a trigger in the Azure Cosmos DB service.
            </summary>
            <remarks> 
            Azure Cosmos DB supports pre and post triggers written in JavaScript to be executed on creates, updates and deletes. 
            For additional details, refer to the server-side JavaScript API documentation.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.Body">
            <summary>
            Gets or sets the body of the trigger for the Azure Cosmos DB service.
            </summary>
            <value>The body of the trigger.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.TriggerType">
            <summary>
            Gets or sets the type of the trigger for the Azure Cosmos DB service.
            </summary>
            <value>The body of the trigger.</value>
            <seealso cref="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.TriggerType"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.TriggerOperation">
            <summary>
            Gets or sets the operation the trigger is associated with for the Azure Cosmos DB service.
            </summary>
            <value>The operation the trigger is associated with.</value>
            <seealso cref="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.TriggerOperation"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.Id">
            <summary>
            Gets or sets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            Unlike <see cref="P:Microsoft.Azure.Documents.Resource.ResourceId"/>, which is set internally, this Id is settable by the user and is not immutable.
            </para>
            <para>
            When working with document resources, they too have this settable Id property. 
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database. 
            You can override this auto Id generation by setting the disableAutomaticIdGeneration parameter on the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance to true.
            This will prevent the SDK from generating new Ids. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.TriggerProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.TriggerType">
            <summary>
            Specifies the type of the trigger in the Azure Cosmos DB service.
            </summary> 
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerType.Pre">
            <summary>
            Trigger should be executed before the associated operation(s).
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Scripts.TriggerType.Post">
            <summary>
            Trigger should be executed after the associated operation(s).
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties">
             <summary>
             Represents a user defined function in the Azure Cosmos service.
             </summary> 
             <remarks>
             Azure Cosmos supports JavaScript user defined functions (UDFs) which are stored in the database and can be used inside queries. 
             Refer to https://docs.microsoft.com/azure/cosmos-db/sql-api-sql-query#javascript-integration for how to use UDFs within queries.
             Refer to https://docs.microsoft.com/azure/cosmos-db/programming#udf for more details about implementing UDFs in JavaScript.
             </remarks>
             <example>
             The following examples show how to register and use UDFs.
             <code language="c#">
             <![CDATA[
             await this.container.UserDefinedFunctions.CreateUserDefinedFunctionAsync(
                 new UserDefinedFunctionProperties 
                 { 
                     Id = "calculateTax", 
                     Body = @"function(amt) { return amt * 0.05; }" 
                 });
            
             QueryDefinition sqlQuery = new QueryDefinition(
                 "SELECT VALUE udf.calculateTax(t.cost) FROM toDoActivity t where t.cost > @expensive and t.status = @status")
                 .WithParameter("@expensive", 9000)
                 .WithParameter("@status", "Done");
            
             using (FeedIterator<double> feedIterator = this.container.Items.GetItemsQueryIterator<double>(
                 sqlQueryDefinition: sqlQuery,
                 partitionKey: "Done"))
             {
                 while (feedIterator.HasMoreResults)
                 {
                     foreach (var tax in await feedIterator.ReadNextAsync())
                     {
                         Console.WriteLine(tax);
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties.Body">
            <summary>
            Gets or sets the body of the user defined function for the Azure Cosmos DB service.
            </summary>
            <value>The body of the user defined function.</value>
            <remarks>This must be a valid JavaScript function e.g. "function (input) { return input.toLowerCase(); }".</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties.Id">
            <summary>
            Gets or sets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            Unlike <see cref="P:Microsoft.Azure.Documents.Resource.ResourceId"/>, which is set internally, this Id is settable by the user and is not immutable.
            </para>
            <para>
            When working with document resources, they too have this settable Id property. 
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database. 
            You can override this auto Id generation by setting the disableAutomaticIdGeneration parameter on the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance to true.
            This will prevent the SDK from generating new Ids. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Scripts.UserDefinedFunctionProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1">
            <summary>
            The Azure Cosmos DB ResourceFeedReader class can be used to iterate through the resources of the specified type under a 
            feed, e.g., collections under a database or documents under a collection. Supports paginated read of results.
            </summary>
            <typeparam name="T">Resource type</typeparam>
            <remarks>
            <para>
            The database entities that Azure Cosmos DB manages like databases, collections and documents are referred to as resources, and each set 
            of resources is referred to as a feed. For example, a collection has a feed of documents, as well as a feed of stored procedures.
            <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> objects can be used to perform a "read feed", i.e, enumerate the specified resources under the 
            specified Azure Cosmos DB feed link. For more details, refer to <a href="http://azure.microsoft.com/documentation/articles/documentdb-resources/">
            Azure Cosmos DB resource model and concepts</a>.
            </para>
            </remarks>
            <example>
            The following example shows how to create a ResourceFeedReader to read all documents in a collection using the default page size.
            <code style="c#">
            <![CDATA[
            var feedReader = client.CreateDocumentFeedReader(collection1.SelfLink);
            var count = 0;
            while (feedReader.HasMoreResults)
            {
                count += feedReader.ExecuteNextAsync().Result.Count;
            }
            ]]>
            </code>
            </example>
            <example>
            The following example shows how to create a ResourceFeedReader for documents against a partitioned database using a Range partition key, and 
            a custom page size.
            <code style="c#">
            <![CDATA[
            feedCount = 0;
            ResourceFeedReader<Document> feedReader = client.CreateDocumentFeedReader(
                databaseLink, 
                new FeedOptions() { MaxItemCount = 1 }, 
                new Range<long>(0, 800));
            
            while (feedReader.HasMoreResults)
            {
                var feed = feedReader.ExecuteNextAsync().Result;
                feedCount += feed.Count;
            }
            ]]>
            </code>
            </example>
            <seealso cref="N:Microsoft.Azure.Cosmos.Resource"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentClient"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResourceFeedReader`1.HasMoreResults">
            <summary>
            Gets a value indicating whether there are additional results to retrieve from the Azure Cosmos DB service.
            </summary>
            <returns>Returns true if there are additional results to retrieve. Returns false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReader`1.GetEnumerator">
            <summary>
            Retrieves an <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate over the resources from the Azure Cosmos DB service.
            </summary>
            <remarks>
            This call results in all pages for the feed being fetched synchronously.
            </remarks>
            <returns>An enumerator for the feed.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReader`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Retrieves an <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate over the resources from the Azure Cosmos DB service.
            </summary>
            <returns>An enumerator for the feed.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReader`1.ExecuteNextAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves the next page of results from the Azure Cosmos DB service.
            </summary>
            <param name="cancellationToken">(Optional) The <see cref="T:System.Threading.CancellationToken"/> allows for notification that operations should be cancelled.</param>
            <returns>The response from a single call to ReadFeed for the specified resource.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions">
            <summary>
            Client extensions for creating <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> objects in the Azure Cosmos DB service.
            </summary>
            <remarks>
            For additional details and examples, please refer to <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/>.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/>
            <seealso cref="N:Microsoft.Azure.Cosmos.Resource"/>
            <seealso cref="T:Microsoft.Azure.Cosmos.DocumentClient"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateDatabaseFeedReader(Microsoft.Azure.Cosmos.DocumentClient,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for databases in the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateDocumentFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions,System.Object)">
            <summary>
            Creates a Feed Reader for Documents in the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="documentsFeedOrDatabaseLink">The link for documents or self-link for database in case a partition resolver is used with the client</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <param name="partitionKey">The key used to determine the target collection</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreatePartitionKeyRangeFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for PartitionKeyRanges in the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="partitionKeyRangesLink">The link for partition key ranges</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateDocumentCollectionFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for DocumentCollections in the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="collectionsLink">The link for collections</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateUserFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Users from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="usersLink">The link for users</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateUserDefinedTypeFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for User Defined Types from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="userDefinedTypesLink">The link for user defined types</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreatePermissionFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Permissions from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="permissionsLink"></param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateStoredProcedureFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for StoredProcedures from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="storedProceduresLink">The link for stored procedures</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateTriggerFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Triggers from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="triggersLink">The link for triggers</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateUserDefinedFunctionFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for UserDefinedFunctions from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="userDefinedFunctionsLink">The link for userDefinedFunctions</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateAttachmentFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Attachments from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="attachmentsLink">The link for attachments</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateConflictFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Conflicts from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="conflictsLink">The link for conflicts</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateSchemaFeedReader(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Schemas from the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="schemasLink">The link for schemas</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateOfferFeedReader(Microsoft.Azure.Cosmos.DocumentClient,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for Offers in the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceFeedReaderClientExtensions.CreateSnapshotFeedReader(Microsoft.Azure.Cosmos.DocumentClient,Microsoft.Azure.Cosmos.FeedOptions)">
            <summary>
            Creates a Feed Reader for snapshots in the Azure Cosmos DB service.
            </summary>
            <param name="client">The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance.</param>
            <param name="options">the <see cref="T:Microsoft.Azure.Cosmos.FeedOptions"/> options for the request.</param>
            <returns>A <see cref="T:Microsoft.Azure.Cosmos.ResourceFeedReader`1"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceThrottleRetryPolicy.ShouldRetryAsync(System.Exception,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="exception">Exception that occured when the operation was tried</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceThrottleRetryPolicy.ShouldRetryAsync(Microsoft.Azure.Cosmos.ResponseMessage,System.Threading.CancellationToken)">
            <summary> 
            Should the caller retry the operation.
            </summary>
            <param name="cosmosResponseMessage"><see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> in return of the request</param>
            <param name="cancellationToken"></param>
            <returns>True indicates caller should retry, False otherwise</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceThrottleRetryPolicy.OnBeforeSendRequest(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Method that is called before a request is sent to allow the retry policy implementation
            to modify the state of the request.
            </summary>
            <param name="request">The request being sent to the service.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ResourceThrottleRetryPolicy.CheckIfRetryNeeded(System.Nullable{System.TimeSpan},System.TimeSpan@)">
            <summary>
            Returns True if the given <paramref name="retryAfter"/> is within retriable bounds
            </summary>
            <param name="retryAfter">Value of x-ms-retry-after-ms header</param>
            <param name="retryDelay">retryDelay</param>
            <returns>True if the exception is retriable; False otherwise</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ResourceToken">
            <summary>
            Resource token to be used to access resources.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResourceToken.ResourceLink">
            <summary> 
            Gets or sets the self-link of resource to which the token applies.
            </summary>
            <value>
            The self-link of the resource to which the token applies.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResourceToken.ResourcePartitionKey">
            <summary>
            Gets or sets optional partition key value for the token.
            A permission applies to resources when two conditions are met:
                  1. <see cref="P:Microsoft.Azure.Cosmos.ResourceToken.ResourceLink"/> is prefix of resource's link.
                        For example "/dbs/mydatabase/colls/mycollection" applies to "/dbs/mydatabase/colls/mycollection" and "/dbs/mydatabase/colls/mycollection/docs/mydocument"
                  2. <see cref="P:Microsoft.Azure.Cosmos.ResourceToken.ResourcePartitionKey"/> is superset of resource's partition key.
                        For example absent/empty partition key is superset of all partition keys.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ResourceToken.Token">
            <summary>
            Gets the access token granting the defined permission.
            </summary>
            <value>
            The access token granting the defined permission.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientContextCore.Client">
            <summary>
            The Cosmos client that is used for the request
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientContextCore.CreateLink(System.String,System.String,System.String)">
            <summary>
            Generates the URI link for the resource
            </summary>
            <param name="parentLink">The parent link URI (/dbs/mydbId) </param>
            <param name="uriPathSegment">The URI path segment</param>
            <param name="id">The id of the resource</param>
            <returns>A resource link in the format of {parentLink}/this.UriPathSegment/this.Name with this.Name being a Uri escaped version</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientContextCore.Dispose(System.Boolean)">
            <summary>
            Dispose of cosmos client
            </summary>
            <param name="disposing">True if disposing</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionKey">
            <summary>
            Provides operations for reading a specific client data encryption key (aka ClientEncryptionKey) by Id.
            See <see cref="T:Microsoft.Azure.Cosmos.Database"/> for operations to create and enumerate client encryption keys.
            See https://aka.ms/CosmosClientEncryption for more information on client-side encryption support in Azure Cosmos DB.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKey.Id">
            <summary>
            The unique identifier of the client encryption key.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKey.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads the properties of a client encryption key from the Azure Cosmos service as an asynchronous operation.
            This method is not meant to be invoked directly. Please see https://aka.ms/CosmosClientEncryption in order to use client-side encryption.
            </summary>
            <param name="requestOptions">(Optional) The options for the request.</param>
            <param name="cancellationToken">(Optional) Token representing request cancellation.</param>
            <returns>An awaitable response which wraps a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties"/> containing details of the client encryption key that was read.</returns>
            <exception cref="T:Microsoft.Azure.Cosmos.CosmosException">
            This exception can encapsulate many different types of errors.
            To determine the specific error always look at the StatusCode property.
            Some common codes you may get when reading a client encryption key are:
            <list type="table">
                <listheader>
                    <term>StatusCode</term>
                    <description>Reason for exception</description>
                </listheader>
                <item>
                    <term>404</term>
                    <description>
                    NotFound - This means the resource or parent resource you tried to read did not exist.
                    </description>
                </item>
                <item>
                    <term>429</term>
                    <description>
                    TooManyRequests - This means you have exceeded the number of request units per second.
                    Consult the CosmosException.RetryAfter value to see how long you should wait before retrying this operation.
                    </description>
                </item>
            </list>
            </exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKey.ReplaceAsync(Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replace a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties"/> from the Azure Cosmos service as an asynchronous operation.
            This method is not meant to be invoked directly. Please see https://aka.ms/CosmosClientEncryption in order to use client-side encryption.
            </summary>
            <param name="clientEncryptionKeyProperties">The <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties"/> object.</param>
            <param name="requestOptions">(Optional) The options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties"/> containing the replace resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore">
            <summary>
            Provides operations for reading a specific client encryption key by Id.
            See <see cref="T:Microsoft.Azure.Cosmos.Database"/> for operations to create a client encryption key.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore.#ctor">
            <summary>
            Only used for unit testing
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore.Id">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore.Database">
            <summary>
            Returns a reference to a database object that contains this encryption key. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore.ReplaceAsync(Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyInlineCore">
            <summary>
            This class acts as a wrapper over <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyCore"/> for environments that use SynchronizationContext.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyInlineCore.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties">
            <summary> 
            Details of an encryption key for use with the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.#ctor(System.String,System.String,System.Byte[],Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties"/>.
            </summary>
            <param name="id">Unique identifier for the client encryption key.</param>
            <param name="encryptionAlgorithm">Encryption algorithm that will be used along with this client encryption key to encrypt/decrypt data.</param>
            <param name="wrappedDataEncryptionKey">Wrapped (encrypted) form of the client encryption key.</param>
            <param name="encryptionKeyWrapMetadata">Metadata used by the configured key wrapping provider in order to unwrap the key.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.#ctor">
            <summary>
            For mocking.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.Id">
            <summary>
            The identifier of the resource.
            </summary>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.EncryptionAlgorithm">
            <summary>
            Encryption algorithm that will be used along with this client encryption key to encrypt/decrypt data.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.WrappedDataEncryptionKey">
            <summary>
            Wrapped form of the client encryption key.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.EncryptionKeyWrapMetadata">
            <summary>
            Metadata for the wrapping provider that can be used to unwrap the wrapped client encryption key.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.CreatedTime">
            <summary>
            Gets the creation time of the resource from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.LastModified">
            <summary>
            Gets the last modified time stamp associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The last modified time stamp associated with the resource.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.ResourceId">
            <summary>
            Gets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB 
            resource whether that is a database, a collection or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.Equals(System.Object)">
            <summary>
            Compares this instance of client encryption key properties to another object.
            </summary>
            <param name="obj">Object to compare with.</param>
            <returns>True if the other object is an instance of <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties"/> and the properties match, else false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.Equals(Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties)">
            <summary>
            Compares this instance of client encryption key properties to another.
            </summary>
            <param name="other">Instance to compare with.</param>
            <returns>True if properties match, else false.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyProperties.GetHashCode">
            <summary>
            Gets a hash code for the properties of this instance to optimize comparisons.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse">
            <summary>
            Response from the Cosmos DB service for a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKey"/> related request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.#ctor">
            <summary>
            Creates a client encryption key response as a no-op for mock testing.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.ClientEncryptionKey">
            <summary>
            The reference to the client encryption key that allows additional operations on it.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse.op_Implicit(Microsoft.Azure.Cosmos.ClientEncryptionKeyResponse)~Microsoft.Azure.Cosmos.ClientEncryptionKey">
            <summary>
            Get the client encryption key implicitly from an encryption key response.
            </summary>
            <param name="response">Response from which to get the client encryption key.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata">
            <summary>
            Metadata that a key wrapping provider can use to wrap/unwrap data encryption keys.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of key wrap metadata.
            </summary> 
            <param name="type">ProviderName of KeyStoreProvider.</param>
            <param name="name">Name of the metadata.</param>
            <param name="value">Value of the metadata.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.#ctor(Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata)">
            <summary>
            Creates a new instance of key wrap metadata based on an existing instance.
            </summary>
            <param name="source">Existing instance from which to initialize.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.Type">
            <summary>
            Serialized form of metadata.
            Note: This value is saved in the Cosmos DB service.
            Implementors of derived implementations should ensure that this does not have (private) key material or credential information.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.Name">
            <summary>
            Serialized form of metadata.
            Note: This value is saved in the Cosmos DB service.
            Implementors of derived implementations should ensure that this does not have (private) key material or credential information.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.Value">
            <summary>
            Serialized form of metadata.
            Note: This value is saved in the Cosmos DB service.
            Implementors of derived implementations should ensure that this does not have (private) key material or credential information.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata.Equals(Microsoft.Azure.Cosmos.EncryptionKeyWrapMetadata)">
            <summary>
            Returns whether the properties of the passed in key wrap metadata matches with those in the current instance.
            </summary>
            <param name="other">Key wrap metadata to be compared with current instance.</param>
            <returns>
            True if the properties of the key wrap metadata passed in matches with those in the current instance, else false.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Conflicts">
            <summary>
            Operations for reading/querying conflicts in a Azure Cosmos container.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.DeleteAsync(Microsoft.Azure.Cosmos.ConflictProperties,Microsoft.Azure.Cosmos.PartitionKey,System.Threading.CancellationToken)">
            <summary>
            Delete a conflict from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="conflict">The conflict to delete.</param>
            <param name="partitionKey">The partition key for the conflict.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A Task representing the asynchronous operation.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConflictProperties"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.ReadCurrentAsync``1(Microsoft.Azure.Cosmos.ConflictProperties,Microsoft.Azure.Cosmos.PartitionKey,System.Threading.CancellationToken)">
            <summary>
            Reads the item that originated the conflict.
            </summary>
            <param name="conflict">The conflict for which we want to read the item.</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The current state of the item associated with the conflict.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConflictProperties"/>
            <example>
            <code language="c#">
            <![CDATA[
            using (FeedIterator<ConflictProperties> conflictIterator = conflicts.GetConflictQueryIterator())
            {
                while (conflictIterator.HasMoreResults)
                {
                    foreach(ConflictProperties item in await conflictIterator.ReadNextAsync())
                    {
                        MyClass intendedChanges = conflicts.ReadConflictContent<MyClass>(item);
                        ItemResponse<MyClass> currentState = await conflicts.ReadCurrentAsync<MyClass>(item, intendedChanges.MyPartitionKey);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.ReadConflictContent``1(Microsoft.Azure.Cosmos.ConflictProperties)">
            <summary>
            Reads the content of the Conflict resource in the Azure Cosmos DB service.
            </summary>
            <param name="conflict">The conflict for which we want to read the content of.</param>
            <returns>The content of the conflict.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <seealso cref="T:Microsoft.Azure.Cosmos.ConflictProperties"/>
            <example>
            <code language="c#">
            <![CDATA[
            using (FeedIterator<ConflictProperties> conflictIterator = conflicts.GetConflictQueryIterator())
            {
                while (conflictIterator.HasMoreResults)
                {
                    foreach(ConflictProperties item in await conflictIterator.ReadNextAsync())
                    {
                        MyClass intendedChanges = conflicts.ReadConflictContent<MyClass>(item);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.GetConflictQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            Obtains an iterator to go through the <see cref="T:Microsoft.Azure.Cosmos.ConflictProperties"/> on an Azure Cosmos container.
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request <see cref="T:Microsoft.Azure.Cosmos.QueryRequestOptions"/></param>
            <returns>An iterator to go through the conflicts.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            using (FeedIterator<ConflictProperties> feedIterator = conflicts.GetConflictQueryIterator())
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<ConflictProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var conflict in response)
                    {
                        Console.WriteLine(conflict);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.GetConflictQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            Gets an iterator to go through all the conflicts for the container as the original ResponseMessage
            </summary>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the conflicts.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select * From c where c._rid = @rid")
                          .WithParameter("@rid", "TheRidValue");
            using (FeedIterator feedIterator = this.CosmosClient.GetConflictQueryStreamIterator(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status for errors
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario. 
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.GetConflictQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            Obtains an iterator to go through the <see cref="T:Microsoft.Azure.Cosmos.ConflictProperties"/> on an Azure Cosmos container.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the conflicts.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            using (FeedIterator<ConflictProperties> conflictIterator = conflicts.GetConflictQueryIterator())
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<ConflictProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var conflict in response)
                    {
                        Console.WriteLine(conflict);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Conflicts.GetConflictQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            Gets an iterator to go through all the conflicts for the container as the original ResponseMessage
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the conflicts.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            using (FeedIterator feedIterator = this.CosmosClient.GetConflictQueryStreamIterator(
                "select * From c where c._rid = \"TheRidValue\""))
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status for errors
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario. 
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container">
            <summary>
            Operations for reading, replacing, or deleting a specific, existing container or item in a container by id.
            There are two different types of operations.
            1. The object operations where it serializes and deserializes the item on request/response
            2. The stream response which takes a Stream containing a JSON serialized object and returns a response containing a Stream
            See <see cref="T:Microsoft.Azure.Cosmos.Database"/> for creating new containers, and reading/querying all containers.
            </summary>
            <remarks>
             Note: all these operations make calls against a fixed budget.
             You should design your system such that these calls scale sub linearly with your application.
             For instance, do not call `container.readAsync()` before every single `container.readItemAsync()` call to ensure the container exists;
             do this once on application start up.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Container.Id">
            <summary>
            The Id of the Cosmos container
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Container.Database">
            <summary>
            Returns the parent Database reference
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Container.Conflicts">
            <summary>
            Returns the conflicts
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Container.Scripts">
            <summary>
            Returns the scripts
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadContainerAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            Container container = this.database.GetContainer("containerId");
            ContainerProperties containerProperties = await container.ReadContainerAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            Container container = this.database.GetContainer("containerId");
            ResponseMessage response = await container.ReadContainerStreamAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReplaceContainerAsync(Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replace a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the replace resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            Update the container to disable automatic indexing
            <code language="c#">
            <![CDATA[
            ContainerProperties containerProperties = containerReadResponse;
            containerProperties.IndexingPolicy.Automatic = false;
            ContainerResponse response = await container.ReplaceContainerAsync(containerProperties);
            ContainerProperties replacedProperties = response;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReplaceContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replace a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>.</param>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> containing the replace resource record.
            </returns>
            <example>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <code language="c#">
            <![CDATA[
            ContainerProperties containerProperties = containerReadResponse;
            containerProperties.IndexingPolicy.Automatic = false;
            ResponseMessage response = await container.ReplaceContainerStreamAsync(containerProperties);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.DeleteContainerAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            Container container = this.database.GetContainer("containerId");
            ContainerResponse response = await container.DeleteContainerAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.DeleteContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            Container container = this.database.GetContainer("containerId");
            ResponseMessage response = await container.DeleteContainerStreamAsync();
            ]]>
            </code>
            </example>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which will contain information about the request issued.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadThroughputAsync(System.Threading.CancellationToken)">
            <summary>
            Gets container throughput in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>Provisioned throughput in request units per second</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <value>
            The provisioned throughput for this container.
            </value>
            <remarks>
            <para>
            Null value indicates a container with no throughput provisioned.
            </para>
            </remarks>
            <example>
            The following example shows how to get the throughput.
            <code language="c#">
            <![CDATA[
            int? throughput = await container.ReadThroughputAsync();
            ]]>
            </code>
            </example>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-container">Set throughput on a container</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadThroughputAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Gets container throughput in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="requestOptions">The options for the throughput request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The throughput response</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <value>
            The provisioned throughput for this container.
            </value>
            <example>
            The following example shows how to get the throughput
            <code language="c#">
            <![CDATA[
            RequestOptions requestOptions = new RequestOptions();
            ThroughputProperties throughputProperties = await container.ReadThroughputAsync(requestOptions);
            Console.WriteLine($"Throughput: {throughputProperties?.Throughput}");
            ]]>
            </code>
            </example>
            <example>
            The following example shows how to get throughput, MinThroughput and is replace in progress
            <code language="c#">
            <![CDATA[
            RequestOptions requestOptions = new RequestOptions();
            ThroughputResponse response = await container.ReadThroughputAsync(requestOptions);
            Console.WriteLine($"Throughput: {response.Resource?.Throughput}");
            Console.WriteLine($"MinThroughput: {response.MinThroughput}");
            Console.WriteLine($"IsReplacePending: {response.IsReplacePending}");
            ]]>
            </code>
            </example>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-container">Set throughput on a container</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReplaceThroughputAsync(System.Int32,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Sets throughput provisioned for a container in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="throughput">The Cosmos container throughput, expressed in Request Units per second.</param>
            <param name="requestOptions">(Optional) The options for the throughput request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The throughput response.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <value>
            The provisioned throughput for this container.
            </value>
            <example>
            The following example shows how to get the throughput.
            <code language="c#">
            <![CDATA[
            ThroughputResponse throughput = await this.cosmosContainer.ReplaceThroughputAsync(400);
            ]]>
            </code>
            </example>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-container">Set throughput on a container</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReplaceThroughputAsync(Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Sets throughput provisioned for a container in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="throughputProperties">The Cosmos container throughput expressed in Request Units per second.</param>
            <param name="requestOptions">(Optional) The options for the throughput request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The throughput response.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            The following example shows how to replace the fixed throughput.
            <code language="c#">
            <![CDATA[
            ThroughputResponse throughput = await this.cosmosContainer.ReplaceThroughputAsync(
                ThroughputProperties.CreateManualThroughput(10000));
            ]]>
            </code>
            </example>
            <example>
            The following example shows how to replace the autoscale provisioned throughput
            <code language="c#">
            <![CDATA[
            ThroughputResponse throughput = await this.cosmosContainer.ReplaceThroughputAsync(
                ThroughputProperties.CreateAutoscaleThroughput(10000));
            ]]>
            </code>
            </example>
            <remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-container">Set throughput on a container</seealso>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.CreateItemStreamAsync(System.IO.Stream,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Creates a Item as an asynchronous operation in the Azure Cosmos service.
            </summary>
            <param name="streamPayload">A <see cref="T:System.IO.Stream"/> containing the payload.</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
            <remarks>
            The Stream operation only throws on client side exceptions. This is to increase performance and prevent the overhead of throwing exceptions. Check the HTTP status code on the response to check if the operation failed.
            </remarks>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <example>
            This example creates an item in a Cosmos container.
            <code language="c#">
            <![CDATA[
            //Create the object in Cosmos
            using (ResponseMessage response = await this.Container.CreateItemStreamAsync(partitionKey: new PartitionKey("streamPartitionKey"), streamPayload: stream))
            {
                if (!response.IsSuccessStatusCode)
                {
                    //Handle and log exception
                    return;
                }
                
                //Read or do other operations with the stream
                using (StreamReader streamReader = new StreamReader(response.Content))
                {
                    string responseContentAsString = await streamReader.ReadToEndAsync();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.CreateItemAsync``1(``0,System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a item as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="item">A JSON serializable object that must contain an id property. <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> to implement a custom serializer</param>
             <param name="partitionKey"><see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> for the item. If not specified will be populated by extracting from {T}</param>
             <param name="requestOptions">(Optional) The options for the item request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> that was created contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
             <example>
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
             }
             
             ToDoActivity test = new ToDoActivity()
             {
                id = Guid.NewGuid().ToString(),
                status = "InProgress"
             };
            
             ItemResponse item = await this.container.CreateItemAsync<ToDoActivity>(test, new PartitionKey(test.status));
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadItemStreamAsync(System.String,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a item from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the read resource record.
            </returns>
            <remarks>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            The Stream operation only throws on client side exceptions. This is to increase performance and prevent the overhead of throwing exceptions. Check the HTTP status code on the response to check if the operation failed.
            </remarks>
            <example>
            Read a response as a stream.
            <code language="c#">
            <![CDATA[
            using(ResponseMessage response = await this.container.ReadItemStreamAsync("id", new PartitionKey("partitionKey")))
            {
                if (!response.IsSuccessStatusCode)
                {
                    //Handle and log exception
                    return;
                }
                
                //Read or do other operations with the stream
                using (StreamReader streamReader = new StreamReader(response.Content))
                {
                    string content = await streamReader.ReadToEndAsync();
                }
            }
            
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadItemAsync``1(System.String,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a item from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> which wraps the read resource record.
            </returns>
            <remarks>
            Items contain meta data that can be obtained by mapping these meta data attributes to properties in <typeparamref name="T"/>.
            * "_ts": Gets the last modified time stamp associated with the item from the Azure Cosmos DB service.
            * "_etag": Gets the entity tag associated with the item from the Azure Cosmos DB service.
            * "ttl": Gets the time to live in seconds of the item in the Azure Cosmos DB service.
            </remarks>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            public class ToDoActivity{
                public string id {get; set;}
                public string status {get; set;}
            }
            
            ToDoActivity toDoActivity = await this.container.ReadItemAsync<ToDoActivity>("id", new PartitionKey("partitionKey"));
            
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.UpsertItemStreamAsync(System.IO.Stream,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Upserts an item stream as an asynchronous operation in the Azure Cosmos service.
            </summary>
            <param name="streamPayload">A <see cref="T:System.IO.Stream"/> containing the payload.</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the read resource record.
            </returns>
            <remarks>
            The Stream operation only throws on client side exceptions. 
            This is to increase performance and prevent the overhead of throwing exceptions. 
            Check the HTTP status code on the response to check if the operation failed.
            </remarks>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <example>
            Upsert a Stream containing the item to Cosmos
            <code language="c#">
            <![CDATA[
            using(ResponseMessage response = await this.container.UpsertItemStreamAsync(stream, new PartitionKey("itemPartitionKey")))
            {
                if (!response.IsSuccessStatusCode)
                {
                    //Handle and log exception
                    return;
                }
                
                //Read or do other operations with the stream
                using (StreamReader streamReader = new StreamReader(response.Content))
                {
                    string content = await streamReader.ReadToEndAsync();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.UpsertItemAsync``1(``0,System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Upserts an item as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="item">A JSON serializable object that must contain an id property. <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> to implement a custom serializer</param>
             <param name="partitionKey"><see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> for the item. If not specified will be populated by extracting from {T}</param>
             <param name="requestOptions">(Optional) The options for the item request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>The <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> that was upserted contained within a <see cref="T:System.Threading.Tasks.Task"/> object representing the service response for the asynchronous operation.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
             <example>
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
             }
             
             ToDoActivity test = new ToDoActivity()
             {
                id = Guid.NewGuid().ToString(),
                status = "InProgress"
             };
            
             ItemResponse<ToDoActivity> item = await this.container.UpsertItemAsync<ToDoActivity>(test, new PartitionKey(test.status));
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReplaceItemStreamAsync(System.IO.Stream,System.String,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replaces a item in the Azure Cosmos service as an asynchronous operation.
            </summary>
            <remarks>
            The item's partition key value is immutable. 
            To change an item's partition key value you must delete the original item and insert a new item.
            </remarks>
            <param name="streamPayload">A <see cref="T:System.IO.Stream"/> containing the payload.</param>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the replace resource record.
            </returns>
            <remarks>
            The Stream operation only throws on client side exceptions. 
            This is to increase performance and prevent the overhead of throwing exceptions. 
            Check the HTTP status code on the response to check if the operation failed.
            </remarks>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <example>
            Replace an item in Cosmos
            <code language="c#">
            <![CDATA[
            using(ResponseMessage response = await this.container.ReplaceItemStreamAsync(stream, "itemId", new PartitionKey("itemPartitionKey"))
            {
                if (!response.IsSuccessStatusCode)
                {
                    //Handle and log exception
                    return;
                }
                
                //Read or do other operations with the stream
                using (StreamReader streamReader = new StreamReader(response.Content))
                {
                    string content = await streamReader.ReadToEndAsync();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReplaceItemAsync``1(``0,System.String,System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Replaces a item in the Azure Cosmos service as an asynchronous operation.
             </summary>
             <remarks>
             The item's partition key value is immutable. 
             To change an item's partition key value you must delete the original item and insert a new item.
             </remarks>
             <param name="item">A JSON serializable object that must contain an id property. <see cref="T:Microsoft.Azure.Cosmos.CosmosSerializer"/> to implement a custom serializer.</param>
             <param name="id">The Cosmos item id of the existing item.</param>
             <param name="partitionKey"><see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> for the item. If not specified will be populated by extracting from {T}</param>
             <param name="requestOptions">(Optional) The options for the item request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>
             A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> which wraps the updated resource record.
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
             <example>
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
             }
             
             ToDoActivity test = new ToDoActivity()
             {
                id = Guid.NewGuid().ToString(),
                status = "InProgress"
             };
            
             ItemResponse item = await this.container.ReplaceItemAsync<ToDoActivity>(test, test.id, new PartitionKey(test.status));
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadManyItemsStreamAsync(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,Microsoft.Azure.Cosmos.PartitionKey}},Microsoft.Azure.Cosmos.ReadManyRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads multiple items from a container using Id and PartitionKey values.
            </summary>
            <param name="items">List of item.Id and <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/></param>
            <param name="readManyRequestOptions">Request Options for ReadMany Operation</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the response.
            </returns>
            <example>
            <code language="c#">
            <![CDATA[
            IReadOnlyList<(string, PartitionKey)> itemList = new List<(string, PartitionKey)>
            {
                ("Id1", new PartitionKey("pkValue1")),
                ("Id2", new PartitionKey("pkValue2")),
                ("Id3", new PartitionKey("pkValue3"))
            };
            
            using (ResponseMessage responseMessage = await this.Container.ReadManyItemsStreamAsync(itemList))
            {
                using (Stream stream = response.ReadBodyAsync())
                {
                    //Read or do other operations with the stream
                    using (StreamReader streamReader = new StreamReader(stream))
                    {
                        string content = streamReader.ReadToEndAsync();
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.ReadManyItemsAsync``1(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.String,Microsoft.Azure.Cosmos.PartitionKey}},Microsoft.Azure.Cosmos.ReadManyRequestOptions,System.Threading.CancellationToken)">
             <summary>
             Reads multiple items from a container using Id and PartitionKey values.
             </summary>
             <param name="items">List of item.Id and <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/></param>
             <param name="readManyRequestOptions">Request Options for ReadMany Operation</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>
             A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.FeedResponse`1"/> which wraps the typed items.
             </returns>
             <example>
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
             }
             
             IReadOnlyList<(string, PartitionKey)> itemList = new List<(string, PartitionKey)>
             {
                 ("Id1", new PartitionKey("pkValue1")),
                 ("Id2", new PartitionKey("pkValue2")),
                 ("Id3", new PartitionKey("pkValue3"))
             };
            
             FeedResponse<ToDoActivity> feedResponse = this.Container.ReadManyItemsAsync<ToDoActivity>(itemList);
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.PatchItemAsync``1(System.String,Microsoft.Azure.Cosmos.PartitionKey,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.PatchOperation},Microsoft.Azure.Cosmos.PatchItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Patches an item in the Azure Cosmos service as an asynchronous operation.
            </summary>
            <remarks>
            The item's partition key value is immutable. 
            To change an item's partition key value you must delete the original item and insert a new item.
            The patch operations are atomic and are executed sequentially.
            By default, resource body will be returned as part of the response. User can request no content by setting <see cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.EnableContentResponseOnWrite"/> flag to false.
            </remarks>
            <param name="id">The Cosmos item id of the item to be patched.</param>
            <param name="partitionKey"><see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> for the item</param>
            <param name="patchOperations">Represents a list of operations to be sequentially applied to the referred Cosmos item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> which wraps the updated resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            public class ToDoActivity{
                public string id {get; set;}
                public string status {get; set;}
                public string description {get; set;}
                public int frequency {get; set;}
            }
            
            ToDoActivity toDoActivity = await this.container.ReadItemAsync<ToDoActivity>("id", new PartitionKey("partitionKey"));
            /* toDoActivity = {
                "id" : "someId",
                "status" : "someStatusPK",
                "description" : "someDescription",
                "frequency" : 7
            }*/
            
            List<PatchOperation> patchOperations = new List<PatchOperation>()
                                                        {
                                                            PatchOperation.CreateAddOperation("/daysOfWeek", new string[]{"Monday", "Thursday"}),
                                                            PatchOperation.CreateReplaceOperation("/frequency", 2),
                                                            PatchOperation.CreateRemoveOperation("/description")
                                                        };
            
            ItemResponse item = await this.container.PatchItemAsync<dynamic>(toDoActivity.id, new PartitionKey(toDoActivity.status), patchOperations);
            /* item = {
                "id" : "someId",
                "status" : "someStatusPK",
                "description" : null,
                "frequency" : 2,
                "daysOfWeek" : ["Monday", "Thursday"]
            }*/
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.PatchItemStreamAsync(System.String,Microsoft.Azure.Cosmos.PartitionKey,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.PatchOperation},Microsoft.Azure.Cosmos.PatchItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Patches an item in the Azure Cosmos service as an asynchronous operation.
            </summary>
            <remarks>
            The item's partition key value is immutable. 
            To change an item's partition key value you must delete the original item and insert a new item.
            The patch operations are atomic and are executed sequentially.
            By default, resource body will be returned as part of the response. User can request no content by setting <see cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.EnableContentResponseOnWrite"/> flag to false.
            </remarks>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="patchOperations">Represents a list of operations to be sequentially applied to the referred Cosmos item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the patched resource record.
            </returns>
            <remarks>
            https://aka.ms/cosmosdb-dot-net-exceptions#stream-api
            This is to increase performance and prevent the overhead of throwing exceptions. 
            Check the HTTP status code on the response to check if the operation failed.
            </remarks>
            <example>
            <see cref="M:Microsoft.Azure.Cosmos.Container.PatchItemAsync``1(System.String,Microsoft.Azure.Cosmos.PartitionKey,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.PatchOperation},Microsoft.Azure.Cosmos.PatchItemRequestOptions,System.Threading.CancellationToken)"/>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.DeleteItemStreamAsync(System.String,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a item from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the delete resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <remarks>
            The Stream operation only throws on client side exceptions. This is to increase performance and prevent the overhead of throwing exceptions. Check the HTTP status code on the response to check if the operation failed.
            </remarks>
            <example>
            Delete an item from Cosmos
            <code language="c#">
            <![CDATA[
            using(ResponseMessage response = await this.container.DeleteItemStreamAsync("itemId", new PartitionKey("itemPartitionKey")))
            {
                if (!response.IsSuccessStatusCode)
                {
                    //Handle and log exception
                    return;
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.DeleteItemAsync``1(System.String,Microsoft.Azure.Cosmos.PartitionKey,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a item from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            <code language="c#">
            <![CDATA[
            public class ToDoActivity{
                public string id {get; set;}
                public string status {get; set;}
            }
            
            ItemResponse item = await this.container.DeleteItemAsync<ToDoActivity>("partitionKey", "id");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetItemQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
             This method creates a query for items under a container in an Azure Cosmos database using a SQL statement with parameterized values. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
            </summary>
            <param name="queryDefinition">The Cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the items.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
            <example>
            Create a query to get all the ToDoActivity that have a cost greater than 9000 for the specified partition
            <code language="c#">
            <![CDATA[
            public class ToDoActivity{
                public string id {get; set;}
                public string status {get; set;}
                public int cost {get; set;}
            }
            
            QueryDefinition queryDefinition = new QueryDefinition("select * from ToDos t where t.cost > @expensive")
                .WithParameter("@expensive", 9000);
            using (FeedIterator feedIterator = this.Container.GetItemQueryStreamIterator(
                queryDefinition,
                null,
                new QueryRequestOptions() { PartitionKey = new PartitionKey("Error")}))
            {
                while (feedIterator.HasMoreResults)
                {
                    using (ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        using (StreamReader sr = new StreamReader(response.Content))
                        using (JsonTextReader jtr = new JsonTextReader(sr))
                        {
                            JObject result = JObject.Load(jtr);
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetItemQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
             This method creates a query for items under a container in an Azure Cosmos database using a SQL statement with parameterized values. It returns a FeedIterator.
             For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
            </summary>
            <param name="queryDefinition">The Cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the items.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
            <example>
            Create a query to get all the ToDoActivity that have a cost greater than 9000
            <code language="c#">
            <![CDATA[
            public class ToDoActivity{
                public string id {get; set;}
                public string status {get; set;}
                public int cost {get; set;}
            }
            
            QueryDefinition queryDefinition = new QueryDefinition("select * from ToDos t where t.cost > @expensive")
                .WithParameter("@expensive", 9000);
            using (FeedIterator<ToDoActivity> feedIterator = this.Container.GetItemQueryIterator<ToDoActivity>(
                queryDefinition,
                null,
                new QueryRequestOptions() { PartitionKey = new PartitionKey("Error")}))
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach(var item in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(item.cost); 
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetItemQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
              This method creates a query for items under a container in an Azure Cosmos database using a SQL statement with parameterized values. It returns a FeedIterator.
              For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
             </summary>
             <param name="queryText">The Cosmos SQL query text.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to go through the items.</returns>
             <remarks>
             Query as a stream only supports single partition queries 
             </remarks>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
             <example>
             1. Create a query to get all the ToDoActivity that have a cost greater than 9000 for the specified partition
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
                 public int cost {get; set;}
             }
             
             using (FeedIterator feedIterator = this.Container.GetItemQueryStreamIterator(
                 "select * from ToDos t where t.cost > 9000",
                 null,
                 new QueryRequestOptions() { PartitionKey = new PartitionKey("Error")}))
             {
                 while (feedIterator.HasMoreResults)
                 {
                     using (ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         using (StreamReader sr = new StreamReader(response.Content))
                         using (JsonTextReader jtr = new JsonTextReader(sr))
                         {
                             JObject result = JObject.Load(jtr);
                         }
                     }
                 }
             }
             ]]>
             </code>
             </example>
             <example>
             2. Creates a FeedIterator to get all the ToDoActivity.
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
                 public int cost {get; set;}
             }
            
             using (FeedIterator feedIterator = this.Container.GetItemQueryStreamIterator(
                 null,
                 null,
                 new QueryRequestOptions() { PartitionKey = new PartitionKey("Error")}))
             {
                 while (feedIterator.HasMoreResults)
                 {
                     using (ResponseMessage response = await feedIterator.ReadNextAsync())
                     {
                         using (StreamReader sr = new StreamReader(response.Content))
                         using (JsonTextReader jtr = new JsonTextReader(sr))
                         {
                             JObject result = JObject.Load(jtr);
                         }
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetItemQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
             <summary>
              This method creates a query for items under a container in an Azure Cosmos database using a SQL statement with parameterized values. It returns a FeedIterator.
              For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/>.
             </summary>
             <param name="queryText">The Cosmos SQL query text.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <returns>An iterator to go through the items.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
             <example>
             1. Create a query to get all the ToDoActivity that have a cost greater than 9000
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
                 public int cost {get; set;}
             }
             
             using (FeedIterator<ToDoActivity> feedIterator = this.Container.GetItemQueryIterator<ToDoActivity>(
                 "select * from ToDos t where t.cost > 9000",
                 null,
                 new QueryRequestOptions() { PartitionKey = new PartitionKey("Error")}))
             {
                 while (feedIterator.HasMoreResults)
                 {
                     foreach(var item in await feedIterator.ReadNextAsync())
                     {
                         Console.WriteLine(item.cost);
                     }
                 }
             }
             ]]>
             </code>
             </example>
             <example>
             2. Create a FeedIterator to get all the ToDoActivity.
             <code language="c#">
             <![CDATA[
             public class ToDoActivity{
                 public string id {get; set;}
                 public string status {get; set;}
                 public int cost {get; set;}
             }
            
             using (FeedIterator<ToDoActivity> feedIterator = this.Container.GetItemQueryIterator<ToDoActivity>(
                 null,
                 null,
                 new QueryRequestOptions() { PartitionKey = new PartitionKey("Error")}))
             {
                 while (feedIterator.HasMoreResults)
                 {
                     foreach(var item in await feedIterator.ReadNextAsync())
                     {
                         Console.WriteLine(item.cost); 
                     }
                 }
             }
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetItemLinqQueryable``1(System.Boolean,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions,Microsoft.Azure.Cosmos.CosmosLinqSerializerOptions)">
             <summary>
             This method creates a LINQ query for items under a container in an Azure Cosmos DB service.
             IQueryable extension method ToFeedIterator() should be use for asynchronous execution with FeedIterator, please refer to example 2.
             </summary>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
             <remarks>
             LINQ execution is synchronous which will cause issues related to blocking calls. 
             It is recommended to always use ToFeedIterator(), and to do the asynchronous execution.
             </remarks>
             <typeparam name="T">The type of object to query.</typeparam>
             <param name="allowSynchronousQueryExecution">(Optional)the option which allows the query to be executed synchronously via IOrderedQueryable.</param>
             <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the item query request.</param>
             <param name="linqSerializerOptions">(Optional) The options to configure Linq Serializer Properties. This overrides properties in CosmosSerializerOptions while creating client</param>
             <returns>(Optional) An IOrderedQueryable{T} that can evaluate the query.</returns>
             <example>
             1. This example below shows LINQ query generation and blocked execution.
             <code language="c#">
             <![CDATA[
             public class Book 
             {
                 public string Title {get; set;}
                 
                 public Author Author {get; set;}
                 
                 public int Price {get; set;}
             }
             
             public class Author
             {
                 public string FirstName {get; set;}
                 public string LastName {get; set;}
             }
              
             // Query by the Title property
             Book book = container.GetItemLinqQueryable<Book>(true)
                                  .Where(b => b.Title == "War and Peace")
                                  .AsEnumerable()
                                  .FirstOrDefault();
             
             // Query a nested property
             Book otherBook = container.GetItemLinqQueryable<Book>(true)
                                       .Where(b => b.Author.FirstName == "Leo")
                                       .AsEnumerable()
                                       .FirstOrDefault();
             
             // Perform iteration on books
             foreach (Book matchingBook in container.GetItemLinqQueryable<Book>(true)
                                        .Where(b => b.Price > 100))
             {
                 // Iterate through books
             }
             ]]>
             </code>
             </example>
             <example>
             2. This example below shows LINQ query generation and asynchronous execution with FeedIterator.
             <code language="c#">
             <![CDATA[
            
             // LINQ query generation
             using (FeedIterator<Book> setIterator = container.GetItemLinqQueryable<Book>()
                                  .Where(b => b.Title == "War and Peace")
                                  .ToFeedIterator())
             {                   
                 //Asynchronous query execution
                 while (setIterator.HasMoreResults)
                 {
                     foreach(var item in await setIterator.ReadNextAsync())
                     {
                         Console.WriteLine(item.Price); 
                     }
                 }
             }
             ]]>
             </code>
             </example>
             <remarks>
             The Azure Cosmos DB LINQ provider compiles LINQ to SQL statements. Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-linq-to-sql for the list of expressions supported by the Azure Cosmos DB LINQ provider. ToString() on the generated IQueryable returns the translated SQL statement. The Azure Cosmos DB provider translates JSON.NET and DataContract serialization attributes for members to their JSON property names.
             </remarks>
             <seealso cref="T:Microsoft.Azure.Cosmos.CosmosSerializationOptions"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangesHandler`1">
            <summary>
            Delegate to receive the changes within a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> execution.
            </summary>
            <param name="changes">The changes that happened.</param>
            <param name="cancellationToken">A cancellation token representing the current cancellation status of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the changes.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangesEstimationHandler">
            <summary>
            Delegate to receive the estimation of pending changes to be read by the associated <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.
            </summary>
            <param name="estimatedPendingChanges">An estimation in number of transactions.</param>
            <param name="cancellationToken">A cancellation token representing the current cancellation status of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the estimation.</returns>
            <remarks>
            The estimation over the Change Feed identifies volumes of transactions. If operations in the container are performed through stored procedures, transactional batch or bulk, a group of operations may share the same <see href="https://docs.microsoft.com/azure/cosmos-db/stored-procedures-triggers-udfs#transactions">transaction scope</see> and represented by a single transaction. 
            In those cases, the estimation might not exactly represent number of items, but it is still valid to understand if the pending volume is increasing, decreasing, or on a steady state.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedProcessorBuilder``1(System.String,Microsoft.Azure.Cosmos.Container.ChangesHandler{``0})">
            <summary>
            Initializes a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> for change feed processing.
            </summary>
            <param name="processorName">A name that identifies the Processor and the particular work it will do.</param>
            <param name="onChangesDelegate">Delegate to receive changes.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedEstimatorBuilder(System.String,Microsoft.Azure.Cosmos.Container.ChangesEstimationHandler,System.Nullable{System.TimeSpan})">
            <summary>
            Initializes a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> for change feed monitoring.
            </summary>
            <param name="processorName">The name of the Processor the Estimator is going to measure.</param>
            <param name="estimationDelegate">Delegate to receive estimation.</param>
            <param name="estimationPeriod">Time interval on which to report the estimation. Default is 5 seconds.</param>
            <remarks>
            The goal of the Estimator is to measure progress of a particular processor. In order to do that, the <paramref name="processorName"/> and other parameters, like the leases container, need to match that of the Processor to measure.
            </remarks>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedEstimator(System.String,Microsoft.Azure.Cosmos.Container)">
            <summary>
            Gets a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedEstimator"/> for change feed monitoring.
            </summary>
            <param name="processorName">The name of the Processor the Estimator is going to measure.</param>
            <param name="leaseContainer">Instance of a Cosmos Container that holds the leases.</param>
            <remarks>
            The goal of the Estimator is to measure progress of a particular processor. In order to do that, the <paramref name="processorName"/> and other parameters, like the leases container, need to match that of the Processor to measure.
            </remarks>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedEstimator"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.CreateTransactionalBatch(Microsoft.Azure.Cosmos.PartitionKey)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/>
            that can be used to perform operations across multiple items
            in the container with the provided partition key in a transactional manner.
            </summary>
            <param name="partitionKey">The partition key for all items in the batch.</param>
            <returns>A new instance of <see cref="T:Microsoft.Azure.Cosmos.TransactionalBatch"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetFeedRangesAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a list of <see cref="T:Microsoft.Azure.Cosmos.FeedRange"/> that can be used to parallelize Feed operations.
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A list of <see cref="T:Microsoft.Azure.Cosmos.FeedRange"/>.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedStreamIterator(Microsoft.Azure.Cosmos.ChangeFeedStartFrom,Microsoft.Azure.Cosmos.ChangeFeedMode,Microsoft.Azure.Cosmos.ChangeFeedRequestOptions)">
             <summary>
              This method creates an iterator to consume a Change Feed.
             </summary>
             <param name="changeFeedStartFrom">Where to start the changefeed from.</param>
             <param name="changeFeedMode">Defines the mode on which to consume the change feed.</param>
             <param name="changeFeedRequestOptions">(Optional) The options for the Change Feed consumption.</param>
             <seealso cref="M:Microsoft.Azure.Cosmos.Container.GetFeedRangesAsync(System.Threading.CancellationToken)"/>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#stream-api</exception>
             <example>
             <code language="c#">
             <![CDATA[
             ChangeFeedRequestOptions options = new ChangeFeedRequestOptions()
             {
                 PageSizeHint = 10,
             }
             
             FeedIterator feedIterator = this.Container.GetChangeFeedStreamIterator(
                 ChangeFeedStartFrom.Beginning(),
                 ChangeFeedMode.Incremental,
                 options);
            
             while (feedIterator.HasMoreResults)
             {
                 using (ResponseMessage response = await feedIterator.ReadNextAsync())
                 {
                     if (response.StatusCode == NotModified) 
                     {
                         // No new changes
                         // Capture response.ContinuationToken and break or sleep for some time
                     }
                     else 
                     {
                         using (StreamReader sr = new StreamReader(response.Content))
                         using (JsonTextReader jtr = new JsonTextReader(sr))
                         {
                             JObject result = JObject.Load(jtr);
                         }
                     }
                 }
             }
             ]]>
             </code>
             </example>
             <returns>An iterator to go through the Change Feed.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedIterator``1(Microsoft.Azure.Cosmos.ChangeFeedStartFrom,Microsoft.Azure.Cosmos.ChangeFeedMode,Microsoft.Azure.Cosmos.ChangeFeedRequestOptions)">
             <summary>
              This method creates an iterator to consume a Change Feed.
             </summary>
             <param name="changeFeedStartFrom">Where to start the changefeed from.</param>
             <param name="changeFeedMode">Defines the mode on which to consume the change feed.</param>
             <param name="changeFeedRequestOptions">(Optional) The options for the Change Feed consumption.</param>
             <seealso cref="M:Microsoft.Azure.Cosmos.Container.GetFeedRangesAsync(System.Threading.CancellationToken)"/>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions#typed-api</exception>
             <example>
             <code language="c#">
             <![CDATA[
             ChangeFeedRequestOptions options = new ChangeFeedRequestOptions()
             {
                 PageSizeHint = 10,
             }
             
             FeedIterator<MyItem> feedIterator = this.Container.GetChangeFeedIterator<MyItem>(
                 ChangeFeedStartFrom.Beginning(),
                 ChangeFeedMode.Incremental,
                 options);
                 
                 while (feedIterator.HasMoreResults)
                 {
                     FeedResponse<MyItem> response = await feedIterator.ReadNextAsync();
            
                     if (response.StatusCode == NotModified) 
                     {
                         // No new changes
                         // Capture response.ContinuationToken and break or sleep for some time
                     }
                     else 
                     {
                         foreach (var item in response)
                         {
                             Console.WriteLine(item);
                         }
                     }
                 }
             ]]>
             </code>
             </example>
             <returns>An iterator to go through the Change Feed.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedHandler`1">
            <summary>
            Delegate to receive the changes within a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> execution.
            </summary>
            <param name="context">The context related to the changes.</param>
            <param name="changes">The changes that happened.</param>
            <param name="cancellationToken">A cancellation token representing the current cancellation status of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the changes.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedHandlerWithManualCheckpoint`1">
            <summary>
            Delegate to receive the changes within a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> execution with manual checkpoint.
            </summary>
            <param name="context">The context related to the changes.</param>
            <param name="changes">The changes that happened.</param>
            <param name="checkpointAsync">A task representing an asynchronous checkpoint on the progress of a lease.</param>
            <param name="cancellationToken">A cancellation token representing the current cancellation status of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the changes.</returns>
            <example>
            <code language="c#">
            <![CDATA[
            (ChangeFeedProcessorContext context, IReadOnlyCollection<T> changes, Func<Task> checkpointAsync, CancellationToken cancellationToken) =>
            {
                // consume changes
                
                // On certain condition, we can checkpoint
                await checkpointAsync();
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedStreamHandler">
            <summary>
            Delegate to receive the changes within a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> execution.
            </summary>
            <param name="context">The context related to the changes.</param>
            <param name="changes">The changes that happened.</param>
            <param name="cancellationToken">A cancellation token representing the current cancellation status of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the changes.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedStreamHandlerWithManualCheckpoint">
            <summary>
            Delegate to receive the changes within a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> execution with manual checkpoint.
            </summary>
            <param name="context">The context related to the changes.</param>
            <param name="changes">The changes that happened.</param>
            <param name="checkpointAsync">A task representing an asynchronous checkpoint on the progress of a lease.</param>
            <param name="cancellationToken">A cancellation token representing the current cancellation status of the <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessor"/> instance.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the changes.</returns>
            <example>
            <code language="c#">
            <![CDATA[
            (ChangeFeedProcessorContext context, Stream stream, Func<Task> checkpointAsync, CancellationToken cancellationToken) =>
            {
                // consume stream
                
                // On certain condition, we can checkpoint
                await checkpointAsync();
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedMonitorErrorDelegate">
            <summary>
            Delegate to notify errors during change feed operations.
            </summary>
            <param name="leaseToken">A unique identifier for the lease.</param>
            <param name="exception">The exception that happened.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the notification.</returns>
            <example>
            <code language="c#">
            <![CDATA[
            (string leaseToken, Exception exception) =>
            {
                if (exception is ChangeFeedProcessorUserException userException)
                {
                    Console.WriteLine($"Current instance's delegate had an unhandled when processing lease {leaseToken}.");
                    Console.WriteLine($"Diagnostics {userException.ExceptionContext.Diagnostics}");
                    Console.WriteLine($"Headers {userException.ExceptionContext.Headers}");
                    Console.WriteLine(userException.ToString());
                }
                else 
                {
                    Console.WriteLine($"Current instance faced an exception when processing lease {leaseToken}.");
                    Console.WriteLine(exception.ToString());
                }
                
                return Task.CompletedTask;
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedMonitorLeaseAcquireDelegate">
            <summary>
            Delegate to notify events of leases being acquired by a change feed processor.
            </summary>
            <param name="leaseToken">A unique identifier for the lease.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the notification.</returns>
            <example>
            <code language="c#">
            <![CDATA[
            (string leaseToken) =>
            {
                Console.WriteLine($"Current instance released lease {leaseToken} and stopped processing it.");
                
                return Task.CompletedTask;
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Container.ChangeFeedMonitorLeaseReleaseDelegate">
            <summary>
            Delegate to notify events of leases being releases by a change feed processor.
            </summary>
            <param name="leaseToken">A unique identifier for the lease.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation that is going to be done with the notification.</returns>
            <example>
            <code language="c#">
            <![CDATA[
            (string leaseToken) =>
            {
                Console.WriteLine($"Current instance acquired lease {leaseToken} and will start processing it.");
                
                return Task.CompletedTask;
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedProcessorBuilder``1(System.String,Microsoft.Azure.Cosmos.Container.ChangeFeedHandler{``0})">
            <summary>
            Initializes a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> for change feed processing.
            </summary>
            <param name="processorName">A name that identifies the Processor and the particular work it will do.</param>
            <param name="onChangesDelegate">Delegate to receive changes.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedProcessorBuilderWithManualCheckpoint``1(System.String,Microsoft.Azure.Cosmos.Container.ChangeFeedHandlerWithManualCheckpoint{``0})">
            <summary>
            Initializes a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> for change feed processing with manual checkpoint.
            </summary>
            <param name="processorName">A name that identifies the Processor and the particular work it will do.</param>
            <param name="onChangesDelegate">Delegate to receive changes.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedProcessorBuilder(System.String,Microsoft.Azure.Cosmos.Container.ChangeFeedStreamHandler)">
            <summary>
            Initializes a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> for change feed processing.
            </summary>
            <param name="processorName">A name that identifies the Processor and the particular work it will do.</param>
            <param name="onChangesDelegate">Delegate to receive changes.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Container.GetChangeFeedProcessorBuilderWithManualCheckpoint(System.String,Microsoft.Azure.Cosmos.Container.ChangeFeedStreamHandlerWithManualCheckpoint)">
            <summary>
            Initializes a <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/> for change feed processing with manual checkpoint.
            </summary>
            <param name="processorName">A name that identifies the Processor and the particular work it will do.</param>
            <param name="onChangesDelegate">Delegate to receive changes.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ChangeFeedProcessorBuilder"/></returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ContainerCore">
            <summary>
            Operations for reading, replacing, or deleting a specific, existing container by id.
            
            <see cref="T:Microsoft.Azure.Cosmos.Database"/> for creating new containers, and reading/querying all containers;
            </summary>
            <summary>
            Used to perform operations on items. There are two different types of operations.
            1. The object operations where it serializes and deserializes the item on request/response
            2. The stream response which takes a Stream containing a JSON serialized object and returns a response containing a Stream
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.GetCachedContainerPropertiesAsync(System.Boolean,Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            Gets the container's Properties by using the internal cache.
            In case the cache does not have information about this container, it may end up making a server call to fetch the data.
            </summary>
            <param name="forceRefresh">Forces the cache to refresh</param>
            <param name="trace">The trace.</param>
            <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing the <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> for this container.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.GetPartitionKeyPathTokensAsync(Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            Used by typed API only. Exceptions are allowed.
            </summary>
            <param name="trace"></param>
            <param name="cancellationToken"></param>
            <returns>Returns the partition key path</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.GetNonePartitionKeyValueAsync(Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            Instantiates a new instance of the <see cref="T:Microsoft.Azure.Documents.Routing.PartitionKeyInternal"/> object.
            </summary>
            <remarks>
            The function selects the right partition key constant for inserting documents that don't have
            a value for partition key. The constant selection is based on whether the collection is migrated
            or user partitioned
            
            For non-existing container will throw <see cref="T:Microsoft.Azure.Documents.DocumentClientException"/> with 404 as status code
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerCore.cachedUriSegmentWithoutId">
            <summary>
            Cache the full URI segment without the last resource id.
            This allows only a single con-cat operation instead of building the full URI string each time.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.TryExecuteQueryAsync(Microsoft.Azure.Cosmos.Query.Core.QueryPlan.QueryFeatures,Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.FeedRangeInternal,Microsoft.Azure.Cosmos.QueryRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Used in the compute gateway to support legacy gateway interface.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.GetItemQueryStreamIteratorInternal(Microsoft.Azure.Cosmos.Query.Core.SqlQuerySpec,System.Boolean,System.String,Microsoft.Azure.Cosmos.FeedRangeInternal,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            Helper method to create a stream feed iterator.
            It decides if it is a query or read feed and create
            the correct instance.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.GetResourceSegmentUriWithoutId">
            <summary>
            Gets the full resource segment URI without the last id.
            </summary>
            <returns>Example: /dbs/*/colls/*/{this.pathSegment}/ </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerCore.ContcatCachedUriWithId(System.String)">
            <summary>
            Gets the full resource URI using the cached resource URI segment 
            </summary>
            <param name="resourceId">The resource id</param>
            <returns>
            A document link in the format of {CachedUriSegmentWithoutId}/{0}/ with {0} being a Uri escaped version of the <paramref name="resourceId"/>
            </returns>
            <remarks>Would be used when creating an <see cref="T:Microsoft.Azure.Documents.Attachment"/>, or when replacing or deleting a item in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerInternal.ValidatePartitionKey(System.Object,Microsoft.Azure.Cosmos.RequestOptions)">
            <summary>
            Throw an exception if the partition key is null or empty string
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerInternal.PatchItemStreamAsync(System.String,Microsoft.Azure.Cosmos.PartitionKey,System.IO.Stream,Microsoft.Azure.Cosmos.ItemRequestOptions,System.Threading.CancellationToken)">
            <summary>
            Patches an item in the Azure Cosmos service as an asynchronous operation.
            </summary>
            <remarks>
            By default, resource body will be returned as part of the response. User can request no content by setting <see cref="P:Microsoft.Azure.Cosmos.ItemRequestOptions.EnableContentResponseOnWrite"/> flag to false.
            </remarks>
            <param name="id">The Cosmos item id</param>
            <param name="partitionKey">The partition key for the item.</param>
            <param name="streamPayload">Represents a stream containing the list of operations to be sequentially applied to the referred Cosmos item.</param>
            <param name="requestOptions">(Optional) The options for the item request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which wraps a <see cref="T:System.IO.Stream"/> containing the patched resource record.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ContainerResponse">
            <summary>
            The cosmos container response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.Container,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.Container">
            <summary>
            The reference to the cosmos container. This allows additional operations on the container
            or for easy access to other references like Items, StoredProcedures, etc..
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerResponse.op_Implicit(Microsoft.Azure.Cosmos.ContainerResponse)~Microsoft.Azure.Cosmos.Container">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.Container"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/>
            </summary>
            <param name="response">ContainerResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ItemResponse`1">
            <summary>
            The cosmos item response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemResponse`1.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.ItemResponse`1"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ItemResponse`1.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,`0,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the CosmosResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ItemResponse`1.ETag">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosClientContext">
            <summary>
            This class is used to get access to different client level operations without directly referencing the client object.
            This makes it easy to pass a reference to the client, and it makes it easy to mock for unit tests.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosClientContext.Client">
            <summary>
            The Cosmos client that is used for the request
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientContext.CreateLink(System.String,System.String,System.String)">
            <summary>
            Generates the URI link for the resource
            </summary>
            <param name="parentLink">The parent link URI (/dbs/mydbId) </param>
            <param name="uriPathSegment">The URI path segment</param>
            <param name="id">The id of the resource</param>
            <returns>A resource link in the format of {parentLink}/this.UriPathSegment/this.Name with this.Name being a Uri escaped version</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientContext.ProcessResourceOperationStreamAsync(System.String,Microsoft.Azure.Documents.ResourceType,Microsoft.Azure.Documents.OperationType,Microsoft.Azure.Cosmos.RequestOptions,Microsoft.Azure.Cosmos.ContainerInternal,System.Nullable{Microsoft.Azure.Cosmos.PartitionKey},System.String,System.IO.Stream,System.Action{Microsoft.Azure.Cosmos.RequestMessage},Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            This is a wrapper around ExecUtil method. This allows the calls to be mocked so logic done 
            in a resource can be unit tested.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientContext.ProcessResourceOperationStreamAsync(System.String,Microsoft.Azure.Documents.ResourceType,Microsoft.Azure.Documents.OperationType,Microsoft.Azure.Cosmos.RequestOptions,Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.FeedRange,System.IO.Stream,System.Action{Microsoft.Azure.Cosmos.RequestMessage},Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            This is a wrapper around ExecUtil method. This allows the calls to be mocked so logic done 
            in a resource can be unit tested.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosClientContext.ProcessResourceOperationAsync``1(System.String,Microsoft.Azure.Documents.ResourceType,Microsoft.Azure.Documents.OperationType,Microsoft.Azure.Cosmos.RequestOptions,Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.FeedRange,System.IO.Stream,System.Action{Microsoft.Azure.Cosmos.RequestMessage},System.Func{Microsoft.Azure.Cosmos.ResponseMessage,``0},Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            This is a wrapper around request invoker method. This allows the calls to be mocked so logic done 
            in a resource can be unit tested.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosException">
            <summary>
            The Cosmos Client exception
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosException.#ctor(System.String,System.Net.HttpStatusCode,System.Int32,System.String,System.Double)">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.CosmosException"/>
            </summary>
            <param name="message">The message associated with the exception.</param>
            <param name="statusCode">The <see cref="T:System.Net.HttpStatusCode"/> associated with the exception.</param>
            <param name="subStatusCode">A sub status code associated with the exception.</param>
            <param name="activityId">An ActivityId associated with the operation that generated the exception.</param>
            <param name="requestCharge">A request charge associated with the operation that generated the exception.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.ResponseBody">
            <summary>
            The body of the cosmos response message as a string
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.StatusCode">
            <summary>
            Gets the request completion status code from the Azure Cosmos DB service.
            </summary>
            <value>The request completion status code</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.SubStatusCode">
            <summary>
            Gets the request completion sub status code from the Azure Cosmos DB service.
            </summary>
            <value>The request completion status code</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.RequestCharge">
            <summary>
            Gets the request charge for this request from the Azure Cosmos DB service.
            </summary>
            <value>
            The request charge measured in request units.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.ActivityId">
            <summary>
            Gets the activity ID for the request from the Azure Cosmos DB service.
            </summary>
            <value>
            The activity ID for the request.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.RetryAfter">
            <summary>
            Gets the retry after time. This tells how long a request should wait before doing a retry.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.Headers">
            <summary>
            Gets the response headers
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.Diagnostics">
            <summary>
            Gets the diagnostics for the request
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.StackTrace">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosException.Error">
            <summary>
            Gets the internal error object.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosException.TryGetHeader(System.String,System.String@)">
            <summary>
            Try to get a header from the cosmos response message
            </summary>
            <param name="headerName"></param>
            <param name="value"></param>
            <returns>A value indicating if the header was read.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosException.ToString">
            <summary>
            Create a custom string with all the relevant exception information
            </summary>
            <returns>A string representation of the exception.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosNullReferenceException">
            <summary>
            The exception is a wrapper for NullReferenceExceptions. This wrapper
            adds a way to access the CosmosDiagnostics and appends additional information
            to the message for easier troubleshooting.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosNullReferenceException.#ctor(System.NullReferenceException,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Create an instance of CosmosNullReferenceException
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosNullReferenceException.Source">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosNullReferenceException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosNullReferenceException.StackTrace">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosNullReferenceException.Data">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosNullReferenceException.Diagnostics">
            <summary>
            Gets the diagnostics for the request
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosNullReferenceException.HelpLink">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosNullReferenceException.GetBaseException">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosNullReferenceException.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosObjectDisposedException">
            <summary>
            The exception is a wrapper for ObjectDisposedExceptions. This wrapper
            adds a way to access the CosmosDiagnostics and appends additional information
            to the message for easier troubleshooting.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.#ctor(System.ObjectDisposedException,Microsoft.Azure.Cosmos.CosmosClient,Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Create an instance of CosmosObjectDisposedException
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.Source">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.StackTrace">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.Data">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.Diagnostics">
            <summary>
            Gets the diagnostics for the request
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.HelpLink">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.GetBaseException">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosObjectDisposedException.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosOperationCanceledException">
            <summary>
            The exception that is thrown in a thread upon cancellation of an operation that
             the thread was executing. This extends the OperationCanceledException to include the
             diagnostics of the operation that was canceled.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.#ctor(System.OperationCanceledException,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            Create an instance of CosmosOperationCanceledException
            </summary>
            <param name="originalException">The original operation canceled exception</param>
            <param name="diagnostics"></param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.Source">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.StackTrace">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.Data">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.Diagnostics">
            <summary>
            Gets the diagnostics for the request
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.HelpLink">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.GetBaseException">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosOperationCanceledException.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosQuotaResponse">
            <summary>
            The Cosmos resource response. 
            This contains a list of shared properties accross the different response types.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosQuotaResponse.#ctor(System.String)">
            <summary>
            A class to parse all the quota response.
            </summary>
            <param name="quotaInfo">Example string: functions=0;storedProcedures=0;triggers=0;documentSize=0;documentsSize=0;documentsCount=0;collectionSize=0;</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosQuotaResponse.ParseQuotaString(System.String)">
            <summary>
            Parse the string into the dictionary
            </summary>
            <param name="quotaInfo">Example string: functions=0;storedProcedures=0;triggers=0;documentSize=0;documentsSize=0;documentsCount=0;collectionSize=0;</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosQuotaResponse.ToString">
            <summary>
            Override the to string method to return the original string from the header
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosResponseFactory">
            <summary>
            This response factory converts response messages
            to the corresponding type response using the
            CosmosClient serializer
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosResponseFactory.CreateItemFeedResponse``1(Microsoft.Azure.Cosmos.ResponseMessage)">
            <summary>
            Creates a FeedResponse from a response message
            </summary>
            <typeparam name="T">The user type of the serialized item</typeparam>
            <param name="responseMessage">The response message from the stream API</param>
            <returns>An instance of FeedResponse<typeparamref name="T"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosResponseFactory.CreateItemResponse``1(Microsoft.Azure.Cosmos.ResponseMessage)">
            <summary>
            Creates a FeedResponse from a response message
            </summary>
            <typeparam name="T">The user</typeparam>
            <param name="responseMessage">The response message from the stream API</param>
            <returns>An instance of FeedResponse<typeparamref name="T"/></returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosResponseFactory.CreateStoredProcedureExecuteResponse``1(Microsoft.Azure.Cosmos.ResponseMessage)">
            <summary>
            Creates a StoredProcedureExecuteResponse from a response message
            </summary>
            <typeparam name="T">The user</typeparam>
            <param name="responseMessage">The response message from the stream API</param>
            <returns>An instance of FeedResponse<typeparamref name="T"/></returns>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CosmosResponseFactoryCore.serializerCore">
            <summary>
            This is used for all meta data types
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Database">
             <summary>
             Operations for reading or deleting an existing database.
            
             See <see cref="P:Microsoft.Azure.Cosmos.Database.Client"/> for creating new databases, and reading/querying all databases; use `client.Databases`.
             </summary>
             <remarks>
             Note: all these operations make calls against a fixed budget.
             You should design your system such that these calls scale sub-linearly with your application.
             For instance, do not call `database.ReadAsync()` before every single `container.ReadItemAsync()` call to ensure the database exists;
             do this once on application start up.
             </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Database.Id">
            <summary>
            The Id of the Cosmos database
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Database.Client">
            <summary>
            The parent Cosmos client instance related the database instance
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            // Reads a Database resource where database_id is the ID property of the Database resource you wish to read.
            Database database = this.cosmosClient.GetDatabase(database_id);
            DatabaseResponse response = await database.ReadAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.DeleteAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a Database from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            // Delete a Cosmos database
            Database database = cosmosClient.GetDatabase("myDbId");
            DatabaseResponse response = await database.DeleteAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.ReadThroughputAsync(System.Threading.CancellationToken)">
            <summary>
            Gets database throughput in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>Provisioned throughput in request units per second</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <value>
            The provisioned throughput for this database.
            </value>
            <remarks>
            Null value indicates a database with no throughput provisioned.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-database">Set throughput on a database</seealso>
            <example>
            The following example shows how to get database throughput.
            <code language="c#">
            <![CDATA[
            int? throughput = await database.ReadThroughputAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.ReadThroughputAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Gets database throughput in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="requestOptions">The options for the throughput request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The throughput response.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <value>
            The provisioned throughput for this database.
            </value>
            <remarks>
            Null value indicates a database with no throughput provisioned.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-database">Set throughput on a database</seealso>
            <example>
            The following example shows how to get the throughput
            <code language="c#">
            <![CDATA[
             RequestOptions requestOptions = new RequestOptions();
            ThroughputProperties throughputProperties = await database.ReadThroughputAsync(requestOptions);
            Console.WriteLine($"Throughput: {throughputProperties?.Throughput}");
            ]]>
            </code>
            </example>
            <example>
            The following example shows how to get throughput, MinThroughput and is replace in progress
            <code language="c#">
            <![CDATA[
            RequestOptions requestOptions = new RequestOptions();
            ThroughputResponse response = await database.ReadThroughputAsync(requestOptions);
            Console.WriteLine($"Throughput: {response.Resource?.Throughput}");
            Console.WriteLine($"MinThroughput: {response.MinThroughput}");
            Console.WriteLine($"IsReplacePending: {response.IsReplacePending}");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.ReplaceThroughputAsync(Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Sets throughput provisioned for a database in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="throughputProperties">The Cosmos database throughput expressed in Request Units per second.</param>
            <param name="requestOptions">(Optional) The options for the throughput request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The throughput response.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <value>
            The provisioned throughput for this database.
            </value>
            <example>
            The following example shows how to replace the manual throughput.
            <code language="c#">
            <![CDATA[
            ThroughputResponse throughput = await this.cosmosDatabase.ReplaceThroughputAsync(
                ThroughputProperties.CreateManualThroughput(10000));
            ]]>
            </code>
            </example>
            <example>
            The following example shows how to replace the autoscale provisioned throughput.
            <code language="c#">
            <![CDATA[
            ThroughputResponse throughput = await this.cosmosDatabase.ReplaceThroughputAsync(
                ThroughputProperties.CreateAutoscaleThroughput(10000));
            ]]>
            </code>
            </example>
            <remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput#set-throughput-on-a-database">Set throughput on a database</seealso>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerAsync(Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a container as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
             <param name="throughputProperties">(Optional) The throughput provisioned for a container in measurement of Requests Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             ContainerProperties containerProperties = new ContainerProperties()
             {
                 Id = Guid.NewGuid().ToString(),
                 PartitionKeyPath = "/pk",
                 IndexingPolicy = new IndexingPolicy()
                {
                     Automatic = false,
                     IndexingMode = IndexingMode.Lazy,
                }
             };
            
             ContainerResponse response = await this.cosmosDatabase.CreateContainerAsync(
                 containerProperties,
                 ThroughputProperties.CreateAutoscaleThroughput(10000));
             ]]>
             </code>
             </example>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerIfNotExistsAsync(Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             <para>Check if a container exists, and if it doesn't, create it.
             Only the container id is used to verify if there is an existing container. Other container properties such as throughput are not validated and can be different then the passed properties.</para>
             </summary>
             <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
             <param name="throughputProperties">(Optional) The throughput provisioned for a container in measurement of Requests Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Common success StatusCodes for the CreateDatabaseIfNotExistsAsync operation</description>
                 </listheader>
                 <item>
                     <term>201</term><description>Created - New database is created.</description>
                 </item>
                 <item>
                     <term>200</term><description>OK - This means the database already exists.</description>
                 </item>
             </list>
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             ContainerProperties containerProperties = new ContainerProperties()
             {
                 Id = Guid.NewGuid().ToString(),
                 PartitionKeyPath = "/pk",
                 IndexingPolicy = new IndexingPolicy()
                {
                     Automatic = false,
                     IndexingMode = IndexingMode.Lazy,
                }
             };
            
             ContainerResponse response = await this.cosmosDatabase.CreateContainerIfNotExistsAsync(
                  containerProperties,
                  ThroughputProperties.CreateAutoscaleThroughput(5000));
             ]]>
             </code>
             </example>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerProperties,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a container as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
             <param name="throughputProperties">(Optional) The throughput provisioned for a container in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the container request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> containing the created resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             Creates a container as an asynchronous operation in the Azure Cosmos service and return stream response.
             <code language="c#">
             <![CDATA[
             ContainerProperties containerProperties = new ContainerProperties()
             {
                 Id = Guid.NewGuid().ToString(),
                 PartitionKeyPath = "/pk",
             };
            
             using(ResponseMessage response = await this.cosmosDatabase.CreateContainerStreamAsync(
                 containerProperties,
                 ThroughputProperties.CreateAutoscaleThroughput(10000)))
             {
             }
             ]]>
             </code>
             </example>
             <seealso cref="M:Microsoft.Azure.Cosmos.Database.DefineContainer(System.String,System.String)"/>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.ReplaceThroughputAsync(System.Int32,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Sets throughput provisioned for a database in measurement of request units per second in the Azure Cosmos service.
            </summary>
            <param name="throughput">The Cosmos database throughput expressed in Request Units per second.</param>
            <param name="requestOptions">(Optional) The options for the throughput request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>The throughput response.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <value>
            The provisioned throughput for this database.
            </value>
            <example>
            The following example shows how to get the throughput.
            <code language="c#">
            <![CDATA[
            ThroughputResponse throughput = await this.cosmosDatabase.ReplaceThroughputAsync(10000);
            ]]>
            </code>
            </example>
            <remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.ReadStreamAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            // Reads a Database resource where database_id is the ID property of the Database resource you wish to read.
            Database database = this.cosmosClient.GetDatabase(database_id);
            ResponseMessage response = await database.ReadContainerStreamAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.DeleteStreamAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            // Delete a Database resource where database_id is the ID property of the Database resource you wish to delete.
            Database database = this.cosmosClient.GetDatabase(database_id);
            await database.DeleteStreamAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetContainer(System.String)">
            <summary>
            Returns a reference to a container object. 
            </summary>
            <param name="id">The Cosmos container id.</param>
            <returns>Cosmos container reference</returns>
            <remarks>
            Returns a Container reference. Reference doesn't guarantee existence.
            Please ensure container already exists or is created through a create operation.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            Database db = this.cosmosClient.GetDatabase("myDatabaseId");
            Container container = db.GetContainer("testcontainer");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerAsync(Microsoft.Azure.Cosmos.ContainerProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a container as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
             <param name="throughput">(Optional) The throughput provisioned for a container in measurement of Requests Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             ContainerProperties containerProperties = new ContainerProperties()
             {
                 Id = Guid.NewGuid().ToString(),
                 PartitionKeyPath = "/pk",
                 IndexingPolicy = new IndexingPolicy()
                {
                     Automatic = false,
                     IndexingMode = IndexingMode.Lazy,
                }
             };
            
             ContainerResponse response = await this.cosmosDatabase.CreateContainerAsync(containerProperties);
             ]]>
             </code>
             </example>
             <seealso cref="M:Microsoft.Azure.Cosmos.Database.DefineContainer(System.String,System.String)"/>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerAsync(System.String,System.String,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a container as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="id">The Cosmos container id</param>
             <param name="partitionKeyPath">The path to the partition key. Example: /location</param>
             <param name="throughput">(Optional) The throughput provisioned for a container in measurement of Requests Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             ContainerResponse response = await this.cosmosDatabase.CreateContainerAsync(Guid.NewGuid().ToString(), "/pk");
             ]]>
             </code>
             </example>
             <seealso cref="M:Microsoft.Azure.Cosmos.Database.DefineContainer(System.String,System.String)"/>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerIfNotExistsAsync(Microsoft.Azure.Cosmos.ContainerProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             <para>Check if a container exists, and if it doesn't, create it.
             Only the container id is used to verify if there is an existing container. Other container properties such as throughput are not validated and can be different then the passed properties.</para>
             </summary>
             <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
             <param name="throughput">(Optional) The throughput provisioned for a container in measurement of Requests Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.
             <list type="table">
                 <listheader>
                     <term>StatusCode</term><description>Common success StatusCodes for the CreateDatabaseIfNotExistsAsync operation</description>
                 </listheader>
                 <item>
                     <term>201</term><description>Created - New database is created.</description>
                 </item>
                 <item>
                     <term>200</term><description>OK - This means the database already exists.</description>
                 </item>
             </list>
             </returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             ContainerProperties containerProperties = new ContainerProperties()
             {
                 Id = Guid.NewGuid().ToString(),
                 PartitionKeyPath = "/pk",
                 IndexingPolicy = new IndexingPolicy()
                {
                     Automatic = false,
                     IndexingMode = IndexingMode.Lazy,
                }
             };
            
             ContainerResponse response = await this.cosmosDatabase.CreateContainerIfNotExistsAsync(containerProperties);
             ]]>
             </code>
             </example>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerIfNotExistsAsync(System.String,System.String,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Check if a container exists, and if it doesn't, create it.
             This will make a read operation, and if the container is not found it will do a create operation.
             </summary>
             <param name="id">The Cosmos container id</param>
             <param name="partitionKeyPath">The path to the partition key. Example: /location</param>
             <param name="throughput">(Optional) The throughput provisioned for a container in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ContainerResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             ContainerResponse response = await this.cosmosDatabase.CreateContainerIfNotExistsAsync(Guid.NewGuid().ToString(), "/pk");
             ]]>
             </code>
             </example>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a container as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="containerProperties">The <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> object.</param>
             <param name="throughput">(Optional) The throughput provisioned for a container in measurement of Request Units per second in the Azure Cosmos DB service.</param>
             <param name="requestOptions">(Optional) The options for the container request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> containing the created resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
             Creates a container as an asynchronous operation in the Azure Cosmos service and return stream response.
             <code language="c#">
             <![CDATA[
             ContainerProperties containerProperties = new ContainerProperties()
             {
                 Id = Guid.NewGuid().ToString(),
                 PartitionKeyPath = "/pk",
             };
            
             using(ResponseMessage response = await this.cosmosDatabase.CreateContainerStreamAsync(containerProperties))
             {
             }
             ]]>
             </code>
             </example>
             <seealso cref="M:Microsoft.Azure.Cosmos.Database.DefineContainer(System.String,System.String)"/>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetUser(System.String)">
            <summary>
            Returns a reference to a user object.
            </summary>
            <param name="id">The Cosmos user id.</param>
            <returns>Cosmos user reference</returns>
            <remarks>
            Returns a User reference. Reference doesn't guarantee existence.
            Please ensure user already exists or is created through a create operation.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            Database db = this.cosmosClient.GetDatabase("myDatabaseId");
            User user = await db.GetUser("userId");
            UserResponse response = await user.ReadAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.CreateUserAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a user as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="id">The Cosmos user id</param>
             <param name="requestOptions">(Optional) The options for the user request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             UserResponse response = await this.cosmosDatabase.CreateUserAsync(Guid.NewGuid().ToString());
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.UpsertUserAsync(System.String,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Upserts a user as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="id">The Cosmos user id.</param>
             <param name="requestOptions">(Optional) The options for the user request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             UserResponse response = await this.cosmosDatabase.UpsertUserAsync(Guid.NewGuid().ToString());
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetContainerQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for containers under an database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryDefinition">The Cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the containers</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for containers with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM c where c.status like @status");
                .WithParameter("@status", "start%");
            using (FeedIterator<ContainerProperties> feedIterator = this.cosmosDatabase.GetContainerQueryIterator<ContainerProperties>(queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<ContainerProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var container in response)
                    {
                        Console.WriteLine(container);
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Container.ReadContainerAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)" /> is recommended for single container look-up.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetContainerQueryStreamIterator(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for containers under an database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryDefinition">The Cosmos SQL query definition.</param>
            <param name="continuationToken">The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <returns>An iterator to go through the containers</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the stream feed iterator for containers with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            string queryText = "SELECT c.id FROM c where c.status like 'start%'";
            QueryDefinition queryDefinition = new QueryDefinition(queryText);
            using (FeedIterator feedIterator = this.cosmosDatabase.GetContainerQueryStreamIterator(queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    using (ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        response.EnsureSuccessStatusCode();
                        using (StreamReader sr = new StreamReader(response.Content))
                        using (JsonTextReader jtr = new JsonTextReader(sr))
                        {
                            // The stream content contains the following JSON structure
                            // {"_rid":"FwsdAA==","DocumentCollections":[{"id":"container1"},{"id":"container2"}],"_count":2}
                            JObject result = JObject.Load(jtr);
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
            <example>
            This creates feed iterator to get a list of all the container ids
            <code language="c#">
            <![CDATA[
            using (FeedIterator feedIterator = this.cosmosDatabase.GetContainerQueryStreamIterator(
                  new QueryDefinition("select value c.id From c ")))
              {
                  while (feedIterator.HasMoreResults)
                  {
                      using (ResponseMessage response = await feedIterator.ReadNextAsync())
                      {
                           response.EnsureSuccessStatusCode();
                           using (StreamReader streamReader = new StreamReader(response.Content))
                           using (JsonTextReader jsonTextReader = new JsonTextReader(streamReader))
                           {
                                // The stream content contains the following JSON structure
                                // {"_rid":"7p8wAA==","DocumentCollections":["container1","container2"],"_count":2}
                                JObject jObject = await JObject.LoadAsync(jsonTextReader);
                            }
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Container.ReadContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)" /> is recommended for single container look-up.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetContainerQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for containers under an database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The Cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the item query request.</param>
            <returns>An iterator to go through the containers</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            1. This create the type feed iterator for containers with queryText as input,
            <code language="c#">
            <![CDATA[
            string queryText = "SELECT * FROM c where c.status like 'start%'";
            using (FeedIterator<ContainerProperties> feedIterator = this.cosmosDatabase.GetContainerQueryIterator<ContainerProperties>(queryText))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<ContainerProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var container in response)
                    {
                        Console.WriteLine(container);
                    }
                }
            }
            ]]>
            </code>
            </example>
            <example>
            2. This create the type feed iterator for containers without queryText, retrieving all containers.
            <code language="c#">
            <![CDATA[
            using (FeedIterator<ContainerProperties> feedIterator = this.cosmosDatabase.GetContainerQueryIterator<ContainerProperties>())
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<ContainerProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var container in response)
                    {
                       Console.WriteLine(container);
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Container.ReadContainerAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)" /> is recommended for single container look-up.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetContainerQueryStreamIterator(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for containers under an database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The Cosmos SQL query text.</param>
            <param name="continuationToken">The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the container request.</param>
            <returns>An iterator to go through the containers</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the stream feed iterator for containers with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            using (FeedIterator feedIterator = this.cosmosDatabase.GetContainerQueryStreamIterator(
                "SELECT c.id FROM c where c.status like 'start%'"))
            {
                while (feedIterator.HasMoreResults)
                {
                    using (ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        response.EnsureSuccessStatusCode();
                        using (StreamReader sr = new StreamReader(response.Content))
                        using (JsonTextReader jtr = new JsonTextReader(sr))
                        {
                            // The stream content contains the following JSON structure
                            // {"_rid":"FwsdAA==","DocumentCollections":[{"id":"container1"},{"id":"container2"}],"_count":2}
                            JObject result = JObject.Load(jtr);
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
            <example>
            This creates feed iterator to get a list of all the container ids
            <code language="c#">
            <![CDATA[
            using (FeedIterator feedIterator = this.cosmosDatabase.GetContainerQueryStreamIterator(
                  "select value c.id From c "))
              {
                  while (feedIterator.HasMoreResults)
                  {
                      using (ResponseMessage response = await feedIterator.ReadNextAsync())
                      {
                           response.EnsureSuccessStatusCode();
                           using (StreamReader streamReader = new StreamReader(response.Content))
                           using (JsonTextReader jsonTextReader = new JsonTextReader(streamReader))
                           {
                                // The stream content contains the following JSON structure
                                // {"_rid":"7p8wAA==","DocumentCollections":["container1","container2"],"_count":2}
                                JObject jObject = await JObject.LoadAsync(jsonTextReader);
                            }
                    }
                }
            }
            ]]>
            </code>
            </example>
            <remarks>
            Refer to https://docs.microsoft.com/azure/cosmos-db/sql-query-getting-started for syntax and examples.
            <para>
            <see cref="M:Microsoft.Azure.Cosmos.Container.ReadContainerStreamAsync(Microsoft.Azure.Cosmos.ContainerRequestOptions,System.Threading.CancellationToken)" /> is recommended for single container look-up.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetUserQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for users under an database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The Cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the user query request.</param>
            <returns>An iterator to go through the users</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            1. This create the type feed iterator for users with queryText as input,
            <code language="c#">
            <![CDATA[
            string queryText = "SELECT * FROM c where c.status like 'start%'";
            using (FeedIterator<UserProperties> HasMoreResults = this.cosmosDatabase.GetUserQueryIterator<UserProperties>(queryText))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<UserProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var user in response)
                    {
                        Console.WriteLine(user);
                    }
                }
            }
            ]]>
            </code>
            </example>
            <example>
            2. This create the type feed iterator for users without queryText, retrieving all users.
            <code language="c#">
            <![CDATA[
            using (FeedIterator<UserProperties> feedIterator = this.cosmosDatabase.GetUserQueryIterator<UserProperties>())
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<UserProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var user in response)
                    {
                        Console.WriteLine(user);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.GetUserQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for users under an database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryDefinition">The Cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the user query request.</param>
            <returns>An iterator to go through the users</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for users with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM c where c.status like @status")
                .WithParameter("@status", "start%");
            using (FeedIterator<UserProperties> resultSet = this.cosmosDatabase.GetUserQueryIterator<UserProperties>(queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (UserProperties properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Database.DefineContainer(System.String,System.String)">
             <summary>
             Creates a containerBuilder.
             </summary>
             <param name="name">Azure Cosmos container name to create.</param>
             <param name="partitionKeyPath">The path to the partition key. Example: /partitionKey</param>
             <returns>A fluent definition of an Azure Cosmos container.</returns>
             <example>
            
             <code language="c#">
             <![CDATA[
             CosmosContainerResponse container = await this.cosmosDatabase.DefineContainer("TestContainer", "/partitionKey")
                 .UniqueKey()
                     .Path("/path1")
                     .Path("/path2")
                     .Attach()
                 .IndexingPolicy()
                     .IndexingMode(IndexingMode.Consistent)
                     .AutomaticIndexing(false)
                     .IncludedPaths()
                         .Path("/includepath1")
                         .Path("/includepath2")
                         .Attach()
                     .ExcludedPaths()
                         .Path("/excludepath1")
                         .Path("/excludepath2")
                         .Attach()
                     .CompositeIndex()
                         .Path("/root/leaf1")
                         .Path("/root/leaf2", CompositePathSortOrder.Descending)
                         .Attach()
                     .CompositeIndex()
                         .Path("/root/leaf3")
                         .Path("/root/leaf4")
                         .Attach()
                     .Attach()
                 .CreateAsync(5000 /* throughput /*); 
             ]]>
             </code>
             </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DatabaseCore">
             <summary>
             Operations for reading or deleting an existing database.
            
             <see cref="P:Microsoft.Azure.Cosmos.DatabaseCore.Client"/> for or creating new databases, and reading/querying all databases; use `client.Databases`.
             </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DatabaseResponse">
            <summary>
            The cosmos database response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DatabaseResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DatabaseResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.DatabaseProperties,Microsoft.Azure.Cosmos.Database,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.Database">
            <summary>
            The reference to the cosmos database. 
            This allows additional operations for the database and easier access to the container operations
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DatabaseResponse.op_Implicit(Microsoft.Azure.Cosmos.DatabaseResponse)~Microsoft.Azure.Cosmos.Database">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.Database"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.DatabaseResponse"/>
            </summary>
            <param name="response">DatabaseResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedIterator">
            <summary>
            Cosmos Result set iterator that keeps track of the continuation token when retrieving results form a query.
            </summary>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select c.id From c where c.status = @status")
                          .WithParameter("@status", "Failure");
            using (FeedIterator feedIterator = this.Container.GetItemQueryStreamIterator(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status code
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedIterator.HasMoreResults">
            <summary>
            Tells if there is more results that need to be retrieved from the service
            </summary>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select c.id From c where c.status = @status")
                          .WithParameter("@status", "Failure");
            using (FeedIterator feedIterator = this.Container.GetItemQueryStreamIterator(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status code
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIterator.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A query response from cosmos service</returns>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select c.id From c where c.status = @status")
                          .WithParameter("@status", "Failure");
            using (FeedIterator feedIterator = this.Container.GetItemQueryStreamIterator(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    // Stream iterator returns a response with status code
                    using(ResponseMessage response = await feedIterator.ReadNextAsync())
                    {
                        // Handle failure scenario
                        if(!response.IsSuccessStatusCode)
                        {
                            // Log the response.Diagnostics and handle the error
                        }
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIterator.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the FeedIterator and optionally
            releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIterator.Dispose">
            <summary>
            Releases the unmanaged resources used by the FeedIterator and optionally
            releases the managed resources.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedIteratorCore">
            <summary>
            Cosmos feed stream iterator. This is used to get the query responses with a Stream content for non-partitioned results
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedIteratorCore.requestOptions">
            <summary>
            The query options for the result set
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedIteratorCore.ContinuationToken">
            <summary>
            The Continuation Token
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIteratorCore.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A query response from cosmos service</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedIteratorCore`1">
            <summary>
            Cosmos feed iterator that keeps track of the continuation token when retrieving results form a query.
            </summary>
            <typeparam name="T">The response object type that can be deserialized</typeparam>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIteratorCore`1.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A query response from cosmos service</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedIteratorInternal">
            <summary>
            Internal feed iterator API for casting and mocking purposes.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedIteratorInternal`1">
            <summary>
            Internal API for FeedIterator<typeparamref name="T"/> for inheritance and mocking purposes.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.FeedIterator`1">
            <summary>
            Cosmos Result set iterator that keeps track of the continuation token when retrieving results form a query.
            </summary>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select c.id From c where c.status = @status")
                          .WithParameter("@status", "Failure");
            using (FeedIterator<MyItem> feedIterator = this.Container.GetItemQueryIterator<MyItem>(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<MyItem> response = await feedIterator.ReadNextAsync();
                    foreach (var item in response)
                    {
                        Console.WriteLine(item);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.FeedIterator`1.HasMoreResults">
            <summary>
            Tells if there is more results that need to be retrieved from the service
            </summary>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select c.id From c where c.status = @status")
                          .WithParameter("@status", "Failure");
            using (FeedIterator<MyItem> feedIterator = this.Container.GetItemQueryIterator<MyItem>(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<MyItem> response = await feedIterator.ReadNextAsync();
                    foreach (var item in response)
                    {
                        Console.WriteLine(item);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIterator`1.ReadNextAsync(System.Threading.CancellationToken)">
            <summary>
            Get the next set of results from the cosmos service
            </summary>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A query response from cosmos service</returns>
            <example>
            Example on how to fully drain the query results.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("select c.id From c where c.status = @status")
                          .WithParameter("@status", "Failure");
            using (FeedIterator<MyItem> feedIterator = this.Container.GetItemQueryIterator<MyItem>(
                queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<MyItem> response = await feedIterator.ReadNextAsync();
                    foreach (var item in response)
                    {
                        Console.WriteLine(item);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIterator`1.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the FeedIterator and optionally
            releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.FeedIterator`1.Dispose">
            <summary>
            Releases the unmanaged resources used by the FeedIterator and optionally
            releases the managed resources.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.OfferAutoscaleAutoUpgradeProperties.#ctor">
            <summary>
            Default constructor for serialization
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferAutoscaleAutoUpgradeProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferAutoscaleAutoUpgradeProperties.AutoscaleThroughputProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.OfferAutoscaleProperties.#ctor">
            <summary>
            Default constructor for serialization
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferAutoscaleProperties.MaxThroughput">
            <summary>
            The maximum throughput the autoscale will scale to.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferAutoscaleProperties.AutoscaleAutoUpgradeProperties">
            <summary>
            Scales the maximum through put automatically
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferAutoscaleProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.OfferContentProperties.#ctor">
            <summary>
            Default constructor for serialization
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferContentProperties.OfferThroughput">
            <summary>
            Represents customizable throughput chosen by user for his collection in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferContentProperties.OfferAutoscaleSettings">
            <summary>
            Represents customizable throughput chosen by user for his collection in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferContentProperties.OfferIsRUPerMinuteThroughputEnabled">
            <summary>
            Represents Request Units(RU)/Minute throughput is enabled/disabled for collection in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferContentProperties.OfferLastReplaceTimestamp">
            <summary>
            Represents time stamp when offer was last replaced by user for collection in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.OfferContentProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Permission">
            <summary>
            Operations for reading, replacing, or deleting a specific permission by id. Permissions are used to create ResourceTokens. Resource tokens provide access to the application resources within a database. Resource tokens:
            <list type="bullet">
            <item>
            <description>Provide access to specific containers, partition keys, documents, attachments, stored procedures, triggers, and UDFs.</description>
            </item>
            <item>
            <description>Are created when a user is granted permissions to a specific resource.</description>
            </item>
            <item>
            <description>Are recreated when a permission resource is acted upon on by POST, GET, or PUT call.</description>
            </item>
            <item>
            <description>Use a hash resource token specifically constructed for the user, resource, and permission.</description>
            </item>
            <item>
            <description>Are time bound with a customizable validity period. The default valid timespan is one hour. Token lifetime, however, may be explicitly specified, up to a maximum of 24 hours.</description>
            </item>
            <item>
            <description>Provide a safe alternative to giving out the master key.</description>
            </item>
            <item>
            <description>Enable clients to read, write, and delete resources in the Cosmos DB account according to the permissions they've been granted.</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Permission.Id">
            <summary>
            The Id of the Cosmos Permission
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Permission.ReadAsync(System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> from the Azure Cosmos service as an asynchronous operation. Each read will return a new ResourceToken with its respective expiration. 
            </summary>
            <param name="tokenExpiryInSeconds">(Optional) The expiry time for resource token in seconds. This value can range from 10 minutes (or 600 seconds), to 24 hours (or 86,400 seconds). The default value for this is 1 hour (or 3,600 seconds). This does not change the default value for future tokens.</param>
            <param name="requestOptions">(Optional) The options for the permission request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            User user = this.database.GetUser("userId");
            Permission permission= user.GetPermission("permissionId");
            PermissionProperties permissionProperties = await permission.ReadAsync(tokenExpiryInSeconds: 9000);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Permission.ReplaceAsync(Microsoft.Azure.Cosmos.PermissionProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replace a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> from the Azure Cosmos service as an asynchronous operation. This will not revoke existing ResourceTokens.
            </summary>
            <param name="permissionProperties">The <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> object.</param>
            <param name="tokenExpiryInSeconds">(Optional) The expiry time for resource token in seconds. This value can range from 10 seconds, to 24 hours (or 86,400 seconds). The default value for this is 1 hour (or 3,600 seconds). This does not change the default value for future tokens.</param>
            <param name="requestOptions">(Optional) The options for the user request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> containing the replace resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>        
            <code language="c#">
            <![CDATA[
            PermissionProperties permissionProperties = permissionReadResponse;
            permissionProperties.Id = "newuser";
            PermissionResponse response = await permission.ReplaceAsync(permissionProperties, tokenExpiryInSeconds: 9000);
            PermissionProperties replacedProperties = response;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Permission.DeleteAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> from the Azure Cosmos DB service as an asynchronous operation. This will not revoke existing ResourceTokens.
            </summary>
            <param name="requestOptions">(Optional) The options for the user request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            User user = this.database.GetUser("userId");
            Permission permission = user.GetPermission("permissionId");
            PermissionResponse response = await permission.DeleteAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PermissionCore">
            <summary>
            Operations for reading, replacing, or deleting a specific, existing user by id.
            
            <see cref="T:Microsoft.Azure.Cosmos.User"/> for creating new users, and reading/querying all user;
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionCore.Id">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PermissionMode">
            <summary> 
            These are the access permissions for creating or replacing a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties" /> resource in the Azure Cosmos DB service.
            </summary>
            <remarks>
            A Permission resource associates an access permission of a user on a particular resource.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PermissionMode.Read">
            <summary>
            Read permission mode will provide the user with Read only access to a resource.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PermissionMode.All">
            <summary>
            All permission mode will provide the user with full access(read, insert, replace and delete) to a resource.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PermissionResponse">
            <summary>
            The cosmos permission response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PermissionResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PermissionResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.PermissionProperties,Microsoft.Azure.Cosmos.Permission,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.Permission">
            <summary>
            The reference to the cosmos permission. This allows additional operations on the permission
            or for easy access permissions
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PermissionResponse.op_Implicit(Microsoft.Azure.Cosmos.PermissionResponse)~Microsoft.Azure.Cosmos.Permission">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.Permission"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/>
            </summary>
            <param name="response">PermissionResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Response`1">
            <summary>
            The cosmos resource response class
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.Headers">
            <summary>
            Gets the current <see cref="T:Microsoft.Azure.Cosmos.ResponseMessage"/> HTTP headers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.Resource">
            <summary>
            The content of the response.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Response`1.op_Implicit(Microsoft.Azure.Cosmos.Response{`0})~`0">
            <summary>
            Get Resource implicitly from <see cref="T:Microsoft.Azure.Cosmos.Response`1"/>
            </summary>
            <param name="response">The Azure Cosmos DB service response.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.StatusCode">
            <summary>
            Gets the request completion status code from the Azure Cosmos DB service.
            This can be used to in scenario like CreateDatabaseIfNotExists to help determine if the database was created or already existed.
            </summary>
            <remarks>This is only used for success scenarios. The operation will throw a CosmosException on failures. For more info: https://aka.ms/cosmosdb-dot-net-exceptions</remarks>
            <value>The request completion status code</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.RequestCharge">
            <summary>
            Gets the request charge for this request from the Azure Cosmos DB service.
            </summary>
            <value>
            The request charge measured in request units.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.ActivityId">
            <summary>
            Gets the activity ID for the request from the Azure Cosmos DB service.
            </summary>
            <value>
            The activity ID for the request.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Response`1.Diagnostics">
            <summary>
            Gets the cosmos diagnostics information for the current request to Azure Cosmos DB service
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.AccountConsistency">
            <summary>
            Represents the consistency policy of a database account of the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountConsistency.DefaultConsistencyLevel">
            <summary>
            Get or set the default consistency level in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountConsistency.MaxStalenessPrefix">
            <summary>
            For bounded staleness consistency, the maximum allowed staleness
            in terms difference in sequence numbers (aka version) in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountConsistency.MaxStalenessIntervalInSeconds">
            <summary>
            For bounded staleness consistency, the maximum allowed staleness
            in terms time interval in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountConsistency.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.AccountProperties">
            <summary> 
            Represents a <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/>. A AccountProperties is the container for databases in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.AccountProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.WritableRegions">
            <summary>
            Gets the list of locations representing the writable regions of
            this database account from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ReadableRegions">
            <summary>
            Gets the list of locations representing the readable regions of
            this database account from the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.Id">
            <summary>
            Gets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            Unlike <see cref="P:Microsoft.Azure.Documents.Resource.ResourceId"/>, which is set internally, this Id is settable by the user and is not immutable.
            </para>
            <para>
            When working with document resources, they too have this settable Id property. 
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database. 
            You can override this auto Id generation by setting the disableAutomaticIdGeneration parameter on the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance to true.
            This will prevent the SDK from generating new Ids. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ResourceId">
            <summary>
            Gets or sets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB 
            resource whether that is a database, a collection or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.MaxMediaStorageUsageInMB">
            <summary>
            Gets the storage quota for media storage in the databaseAccount from the Azure Cosmos DB service.
            </summary>
            <value>
            The storage quota in measured MBs.
            </value>
            <remarks>
            This value is retrieved from the gateway.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.MediaStorageUsageInMB">
            <summary>
            Gets the current attachment content (media) usage in MBs from the Azure Cosmos DB service.
            </summary>
            <value>
            The attachment content (media) usage in MBs.
            </value>
            <remarks>
            The value is retrieved from the gateway. The value is returned from cached information updated periodically 
            and is not guaranteed to be real time.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ConsumedDocumentStorageInMB">
            <summary>
            The cumulative sum of current sizes of created collection in MB
            Value is returned from cached information which is updated periodically and is not guaranteed to be real time
            TODO remove this property tfs 4442779
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ReservedDocumentStorageInMB">
            <summary>
            The cumulative sum of maximum sizes of created collection in MB
            Value is returned from cached information which is updated periodically and is not guaranteed to be real time
            TODO remove this property tfs 4442779
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ProvisionedDocumentStorageInMB">
            <summary>
            The provisioned documented storage capacity for the database account
            Value is returned from cached information which is updated periodically and is not guaranteed to be real time
            TODO remove this property tfs 4442779
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.Consistency">
            <summary>
            Gets the <see cref="P:Microsoft.Azure.Cosmos.AccountProperties.Consistency"/> from the Azure Cosmos DB service.
            </summary>
            <value>
            The ConsistencySetting.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.AddressesLink">
            <summary>
            Gets the self-link for Address Routing Table in the databaseAccount
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.ReplicationPolicy">
            <summary>
            Gets the ReplicationPolicy properties
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.SystemReplicationPolicy">
            <summary>
            Gets the SystemReplicationPolicy 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.AccountRegion">
            <summary>
            The AccountLocation class represents an Azure Cosmos DB database account in a specific region.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountRegion.Name">
            <summary>
            Gets the name of the database account location in the Azure Cosmos DB service. For example,
            "West US" as the name of the database account location in the West US region.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountRegion.Endpoint">
            <summary>
            Gets the URL of the database account location in the Azure Cosmos DB service. For example,
            "https://contoso-WestUS.documents.azure.com:443/" as the URL of the 
            database account location in the West US region.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.AccountRegion.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.BoundingBoxProperties">
            <summary>
            Represents bounding box for geometry spatial path in the Azure Cosmos DB service
            </summary>
            <example>
            <![CDATA[
               {
                  "id": "DocumentCollection Id",
                  "indexingPolicy":{
                        "spatialIndexes":
                        [{  
                            "path":"/'region'/?",
                            "types":["Polygon"],
                            "boundingBox": 
                            {
                               "xmin":0, 
                               "ymin":0,
                               "xmax":10, 
                               "ymax":10
                            }
                        }]
                       },
                  "geospatialConfig": 
                  {
                      "type": "Geometry"
                  }
               }
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BoundingBoxProperties.Xmin">
            <summary>
            Gets the x-coordinate of the lower-left corner of the bounding box.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BoundingBoxProperties.Ymin">
            <summary>
            Gets the y-coordinate of the lower-left corner of the bounding box.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BoundingBoxProperties.Xmax">
            <summary>
            Gets the x-coordinate of the upper-right corner of the bounding box.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BoundingBoxProperties.Ymax">
            <summary>
            Gets the y-coordinate of the upper-right corner of the bounding box.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.BoundingBoxProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ChangeFeedPolicy">
            <summary>
            Represents the change feed policy configuration for a container in the Azure Cosmos DB service.
            </summary> 
            <example>
            The example below creates a new container with a custom change feed policy for full fidelity change feed with a retention window of 5 minutes - so intermediary snapshots of changes as well as deleted documents would be
            available for processing for 5 minutes before they vanish. 
            Processing the change feed with <see cref="P:Microsoft.Azure.Cosmos.ChangeFeedMode.FullFidelity"/> will only be able within this retention window - if you attempt to process a change feed after more
            than the retention window (5 minutes in this sample) an error (Status Code 400) will be returned. 
            It would still be possible to process changes using <see cref="P:Microsoft.Azure.Cosmos.ChangeFeedMode.Incremental"/> mode even when configuring a full fidelity change
            feed policy with retention window on the container and when using Incremental mode it doesn't matter whether your are out of the retention window or not.
            <code language="c#">
            <![CDATA[
                ContainerProperties containerProperties = new ContainerProperties("MyCollection", "/country");
                containerProperties.ChangeFeedPolicy.FullFidelityRetention = TimeSpan.FromMinutes(5);
                
                CosmosContainerResponse containerCreateResponse = await client.GetDatabase("dbName").CreateContainerAsync(containerProperties, 5000);
                ContainerProperties createdContainerProperties = containerCreateResponse.Container;
            ]]>
            </code>
            </example>
            <seealso cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedPolicy.FullFidelityRetention">
            <summary>
            Gets or sets a value that indicates for how long operation logs have to be retained.
            </summary>
            <remarks>
            Minimum granularity supported is minutes.
            </remarks>
            <value>
            Value is in TimeSpan.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedPolicy.FullFidelityNoRetention">
            <summary>
            Disables the retention log.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ChangeFeedPolicy.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath">
            <summary>
            Path that needs encryption and the associated settings within <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionPolicy"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath.Path">
            <summary>
            Gets or sets the path to be encrypted. Must be a top level path, eg. /salary
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath.ClientEncryptionKeyId">
            <summary>
            Gets or sets the identifier of the Client Encryption Key to be used to encrypt the path.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath.EncryptionType">
            <summary>
            Gets or sets the type of encryption to be performed. Eg - Deterministic, Randomized
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath.EncryptionAlgorithm">
            <summary>
            Gets or sets the encryption algorithm which will be used. Eg - AEAD_AES_256_CBC_HMAC_SHA256
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ClientEncryptionPolicy">
            <summary>
            Client encryption policy.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionPolicy.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.ClientEncryptionIncludedPath})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionPolicy"/> class.
            </summary>
            <param name="includedPaths">List of paths to include in the policy definition.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionPolicy.IncludedPaths">
            <summary>
            Paths of the item that need encryption along with path-specific settings.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionPolicy.PolicyFormatVersion">
            <summary>
            Version of the client encryption policy definition.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ClientEncryptionPolicy.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ClientEncryptionPolicy.ValidatePartitionKeyPathsAreNotEncrypted(System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{System.String}})">
            <summary>
            Ensures that partition key paths are not specified in the client encryption policy for encryption.
            </summary>
            <param name="partitionKeyPathTokens">Tokens corresponding to validated partition key.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CompositePathSortOrder">
            <summary>
            Defines the target data type of an index path specification in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CompositePathSortOrder.Ascending">
            <summary>
            Ascending sort order for composite paths.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CompositePathSortOrder.Descending">
            <summary>
            Descending sort order for composite paths.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CompositePath">
            <summary>
            DOM for a composite path.
            A composite path is used in a composite index.
            For example if you want to run a query like "SELECT * FROM c ORDER BY c.age, c.height",
            then you need to add "/age" and "/height" as composite paths to your composite index.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CompositePath.Path">
            <summary>
            Gets or sets the full path in a document used for composite indexing.
            We do not support wild cards in the path.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CompositePath.Order">
            <summary>
            Gets or sets the sort order for the composite path.
            For example if you want to run the query "SELECT * FROM c ORDER BY c.age asc, c.height desc",
            then you need to make the order for "/age" "ascending" and the order for "/height" "descending".
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CompositePath.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ConflictProperties">
            <summary>
            Represents a conflict in the Azure Cosmos DB service.
            </summary>
            <remarks>
            On rare occasions, during an async operation (insert, replace and delete), a version conflict may occur on a resource during fail over or multi master scenarios.
            The conflicting resource is persisted as a Conflict resource.  
            Inspecting Conflict resources will allow you to determine which operations and resources resulted in conflicts.
            This is not related to operations returning a Conflict status code.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictProperties.Id">
            <summary>
            Gets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictProperties.OperationKind">
            <summary>
            Gets the operation that resulted in the conflict in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ConflictResolutionMode">
            <summary>
            Specifies the supported conflict resolution modes, as specified in <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionPolicy"/>
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConflictResolutionMode.LastWriterWins">
            <summary>
            Last writer wins conflict resolution mode
            </summary>
            <remarks>
            Setting the ConflictResolutionMode to "LastWriterWins" indicates that conflict resolution should be done by inspecting a field in the conflicting documents
            and picking the document which has the higher value in that path. See <see cref="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.ResolutionPath"/> for details on how to specify the path
            to be checked for conflict resolution.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConflictResolutionMode.Custom">
            <summary>
            Custom conflict resolution mode
            </summary>
            <remarks>
            Setting the ConflictResolutionMode to "Custom" indicates that conflict resolution is custom handled by a user. 
            The user could elect to register a user specified <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> for handling conflicting resources.
            Should the user not register a user specified StoredProcedure, conflicts will default to being made available as Conflict resources, 
            which the user can inspect and manually resolve.
            See <see cref="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.ResolutionProcedure"/> for details on how to specify the stored procedure
            to run for conflict resolution.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ConflictResolutionPolicy">
            <summary>
            Represents the conflict resolution policy configuration for specifying how to resolve conflicts 
            in case writes from different regions result in conflicts on items in the container in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionPolicy"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.Mode">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionMode"/> in the Azure Cosmos DB service. By default it is <see cref="F:Microsoft.Azure.Cosmos.ConflictResolutionMode.LastWriterWins"/>.
            </summary>
            <value>
            One of the values of the <see cref="T:Microsoft.Azure.Cosmos.ConflictResolutionMode"/> enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.ResolutionPath">
            <summary>
            Gets or sets the path which is present in each item in the Azure Cosmos DB service for last writer wins conflict-resolution.
            This path must be present in each item and must be an integer value.
            In case of a conflict occurring on a item, the item with the higher integer value in the specified path will be picked.
            If the path is unspecified, by default the time stamp path will be used.
            </summary>
            <remarks>
            This value should only be set when using <see cref="F:Microsoft.Azure.Cosmos.ConflictResolutionMode.LastWriterWins"/>
            </remarks>
            <value>
            <![CDATA[The path to check values for last-writer wins conflict resolution. That path is a rooted path of the property in the item, such as "/name/first".]]>
            </value>
            <example>
            <![CDATA[
            conflictResolutionPolicy.ConflictResolutionPath = "/name/first";
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.ResolutionProcedure">
            <summary>
            Gets or sets the <see cref="T:Microsoft.Azure.Cosmos.Scripts.StoredProcedureProperties"/> which is used for conflict resolution in the Azure Cosmos DB service.
            This stored procedure may be created after the <see cref="T:Microsoft.Azure.Cosmos.Container"/> is created and can be changed as required. 
            </summary>
            <remarks>
            1. This value should only be set when using <see cref="F:Microsoft.Azure.Cosmos.ConflictResolutionMode.Custom"/>
            2. In case the stored procedure fails or throws an exception, the conflict resolution will default to registering conflicts in the conflicts feed"/>.
            3. The user can provide the stored procedure id.
            </remarks>
            <value>
            <![CDATA[The stored procedure to perform conflict resolution.]]>
            </value>
            <example>
            <![CDATA[
            conflictResolutionPolicy.ConflictResolutionProcedure = "dbs/databaseName/colls/containerName/sprocs/storedProcedureName";
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ConflictResolutionPolicy.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ConsistencyLevel">
            <summary> 
            These are the consistency levels supported by the Azure Cosmos DB service.
            </summary>
            <remarks>
            The requested Consistency Level must match or be weaker than that provisioned for the database account.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/consistency-levels"/>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConsistencyLevel.Strong">
            <summary>
            Strong Consistency guarantees that read operations always return the value that was last written.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConsistencyLevel.BoundedStaleness">
            <summary>
            Bounded Staleness guarantees that reads are not too out-of-date. This can be configured based on number of operations (MaxStalenessPrefix) 
            or time (MaxStalenessIntervalInSeconds).  For more information on MaxStalenessPrefix and MaxStalenessIntervalInSeconds, please see <see cref="T:Microsoft.Azure.Cosmos.AccountConsistency"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConsistencyLevel.Session">
            <summary>
            Session Consistency guarantees monotonic reads (you never read old data, then new, then old again), monotonic writes (writes are ordered) 
            and read your writes (your writes are immediately visible to your reads) within any single session. 
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConsistencyLevel.Eventual">
            <summary>
            Eventual Consistency guarantees that reads will return a subset of writes. All writes 
            will be eventually be available for reads.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.ConsistencyLevel.ConsistentPrefix">
            <summary>
            ConsistentPrefix Consistency guarantees that reads will return some prefix of all writes with no gaps.
            All writes will be eventually be available for reads.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ContainerProperties">
             <summary>
             Represents a document container in the Azure Cosmos DB service. A container is a named logical container for documents.
             </summary>
             <remarks>
             A database may contain zero or more named containers and each container consists of zero or more JSON documents.
             Being schema-free, the documents in a container do not need to share the same structure or fields. Since containers are application resources,
             they can be authorized using either the master key or resource keys.
             </remarks>
             <seealso href="https://docs.microsoft.com/azure/cosmos-db/databases-containers-items"/>
             <example>
             The example below creates a new partitioned container with 50000 Request-per-Unit throughput.
             The partition key is the first level 'country' property in all the documents within this container.
             <code language="c#">
             <![CDATA[
                 Container container = await client.GetDatabase("dbName").Containers.CreateAsync("MyCollection", "/country", 50000);
                 ContainerProperties containerProperties = container.Resource;
             ]]>
             </code>
             </example>
             <example>
             The example below creates a new container with a custom indexing policy.
             <code language="c#">
             <![CDATA[
                 ContainerProperties containerProperties = new ContainerProperties("MyCollection", "/country");
                 containerProperties.IndexingPolicy.Automatic = true;
                 containerProperties.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
            
                 CosmosContainerResponse containerCreateResponse = await client.GetDatabase("dbName").CreateContainerAsync(containerProperties, 50000);
                 ContainerProperties createdContainerProperties = containerCreateResponse.Container;
             ]]>
             </code>
             </example>
             <example>
             The example below deletes this container.
             <code language="c#">
             <![CDATA[
                 Container container = client.GetDatabase("dbName").Containers["MyCollection"];
                 await container.DeleteAsync();
             ]]>
             </code>
             </example>
             <seealso cref="T:Microsoft.Azure.Cosmos.IndexingPolicy"/>
             <seealso cref="T:Microsoft.Azure.Cosmos.UniqueKeyPolicy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerProperties.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="id">The Id of the resource in the Azure Cosmos service.</param>
            <param name="partitionKeyPath">The path to the partition key. Example: /location</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.PartitionKeyDefinitionVersion">
             <summary>
             Gets or sets the <see cref="T:Microsoft.Azure.Cosmos.PartitionKeyDefinitionVersion"/>
            
             The partition key definition version 1 uses a hash function that computes
             hash based on the first 100 bytes of the partition key. This can cause
             conflicts for documents with partition keys greater than 100 bytes.
            
             The partition key definition version 2 uses a hash function that computes
             hash based on the first 2 KB of the partition key.
             </summary>
             <returns>The Partition Key Definition Version of the container</returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.ConflictResolutionPolicy">
            <summary>
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.ConflictResolutionPolicy" />
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.Id">
            <summary>
            Gets or sets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier.
            Unlike <see cref="P:Microsoft.Azure.Documents.Resource.ResourceId"/>, which is set internally, this Id is settable by the user and is not immutable.
            </para>
            <para>
            When working with document resources, they too have this settable Id property.
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database.
            You can override this auto Id generation by setting the disableAutomaticIdGeneration parameter on the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance to true.
            This will prevent the SDK from generating new Ids.
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.UniqueKeyPolicy">
            <summary>
            Gets or sets the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.UniqueKeyPolicy"/> that guarantees uniqueness of documents in container in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.LastModified">
            <summary>
            Gets the last modified time stamp associated with <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties" /> from the Azure Cosmos DB service.
            </summary>
            <value>The last modified time stamp associated with the resource.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.ClientEncryptionPolicy">
            <summary>
            Gets the client encryption policy information for storing items in a container from the Azure Cosmos service.
            </summary>
            <value>
            It is an optional property.
            By default, ClientEncryptionPolicy is set to null meaning the feature is turned off for the container.
            </value>
            <remarks>
            <para>
            The <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.ClientEncryptionPolicy"/> will be applied to all the items in the container as the default policy.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.IndexingPolicy">
            <summary>
            Gets the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.IndexingPolicy"/> associated with the container from the Azure Cosmos DB service.
            </summary>
            <value>
            The indexing policy associated with the container.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.ChangeFeedPolicy">
            <summary>
            Gets the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.ChangeFeedPolicy"/> associated with the container from the Azure Cosmos DB service.
            </summary>
            <value>
            The change feed policy associated with the container.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.GeospatialConfig">
            <summary>
            Gets the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.GeospatialConfig"/> associated with the collection from the Azure Cosmos DB service.
            </summary>
            <value>
            Geospatial type of collection i.e. geography or geometry
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.PartitionKeyPath">
            <summary>
            JSON path used for containers partitioning
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.TimeToLivePropertyPath">
            <summary>
            Gets or sets the time to live base time stamp property path.
            </summary>
            <value>
            It is an optional property.
            This property should be only present when DefaultTimeToLive is set. When this property is present, time to live
            for a item is decided based on the value of this property in item.
            By default, TimeToLivePropertyPath is set to null meaning the time to live is based on the _ts property in item.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive">
             <summary>
             Gets or sets the default time to live in seconds for item in a container from the Azure Cosmos service.
             </summary>
             <value>
             It is an optional property.
            
             The unit of measurement is seconds. The maximum allowed value is 2147483647.
             A valid value must be either a nonzero positive integer, '-1' or <c>null</c>.
            
             By default, DefaultTimeToLive is set to null meaning the time to live is turned off for the container.
             </value>
             <remarks>
             <para>
             The <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> will be applied to all the items in the container as the default time-to-live policy.
             The individual item could override the default time-to-live policy by setting its time to live.
             </para>
             <para>
             When the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> is <c>null</c>, the time-to-live will be turned off for the container.
             It means all the items will never expire. The individual item's  time to live will be disregarded.
             </para>
             <para>
             When the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> is '-1', the time-to-live will be turned on for the container.
             By default, all the items will never expire. The individual item could be given a specific time-to-live value by setting its
             time to live. The item's time to live will be honored, and the expired items
             will be deleted in background.
             </para>
             <para>
             When the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> is a nonzero positive integer, the time-to-live will be turned on for the container.
             And a default time-to-live in seconds will be applied to all the items. A item will be expired after the
             specified <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.DefaultTimeToLive"/> value in seconds since its last write time.
             </para>
             </remarks>
             <example>
             The example below disables time-to-live on a container.
             <code language="c#">
             <![CDATA[
                 container.DefaultTimeToLive = null;
             ]]>
             </code>
             </example>
             <example>
             The example below enables time-to-live on a container. By default, all the items never expire.
             <code language="c#">
             <![CDATA[
                 container.DefaultTimeToLive = -1;
             ]]>
             </code>
             </example>
             <example>
             The example below enables time-to-live on a container. By default, the item will expire after 1000 seconds
             since its last write time.
             <code language="c#">
             <![CDATA[
                 container.DefaultTimeToLive = 1000;
             ]]>
             </code>
             </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.AnalyticalStoreTimeToLiveInSeconds">
             <summary>
             Gets or sets the time to live for analytical store in seconds at container scope for the Azure Cosmos service.
            
             Analytical store when enabled captures all the item changes in the container. AnalyticalStoreTimeToLiveInSeconds
             defines the time to live for the changes in analytical store.
             </summary>
             <value>
             It is an optional property.
            
             The unit of measurement is seconds. The maximum allowed value is 2147483647.
             A valid value must be either a nonzero positive integer, '-1' or <c>null</c>.
            
             By default, AnalyticalStoreTimeToLiveInSeconds is set to null meaning analytical store is turned-off.
             </value>
             <remarks>
             <para>
             The <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.AnalyticalStoreTimeToLiveInSeconds"/> is applicable to all the item changes in the container.
             It cannot be overriden or customizable per item.
             </para>
             <para>
             When the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.AnalyticalStoreTimeToLiveInSeconds"/> is <c>null</c> analytical store is turned-off.
             It means all the item changes in the container are disregarded.
             </para>
             <para>
             When the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.AnalyticalStoreTimeToLiveInSeconds"/> is '-1', all the items changes will be captured
             by analytical store and will never expire.
             </para>
             <para>
             When the <see cref="P:Microsoft.Azure.Cosmos.ContainerProperties.AnalyticalStoreTimeToLiveInSeconds"/> is a nonzero positive integer, all the items
             changes will be captured by analytical store and expired after the specified time to live.
             </para>
             </remarks>
             <example>
             The example below disables analytical store on a container.
             <code language="c#">
             <![CDATA[
                 container.AnalyticalStoreTimeToLiveInSeconds = null;
             ]]>
             </code>
             </example>
             <example>
             The example below enables analytical store on container capturing all changes and never expire.
             <code language="c#">
             <![CDATA[
                 container.AnalyticalStoreTimeToLiveInSeconds = -1;
             ]]>
             </code>
             </example>
             <example>
             The example below enables analytical store on container capturing all changes and expire after 180days.
             <code language="c#">
             <![CDATA[
                 container.AnalyticalStoreTimeToLiveInSeconds = (int)TimeSpan.FromDays(6 * 30).TotalSeconds;
             ]]>
             </code>
             </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value>
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerProperties.GetNoneValue">
            <summary>
            The function selects the right partition key constant mapping for <see cref="F:Microsoft.Azure.Cosmos.PartitionKey.None"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerProperties.CreateWithResourceId(System.String)">
            <summary>
            Only collection cache needs this contract. None are expected to use it.
            </summary>
            <param name="resourceId">The resource identifier for the container.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerProperties.#ctor(System.String,Microsoft.Azure.Documents.PartitionKeyDefinition)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="id">The Id of the resource in the Azure Cosmos service.</param>
            <param name="partitionKeyDefinition">The partition key definition.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.PartitionKey">
            <summary>
            Gets or sets <see cref="T:Microsoft.Azure.Documents.PartitionKeyDefinition"/> object in the Azure Cosmos DB service.
            </summary>
            <value>
            <see cref="T:Microsoft.Azure.Documents.PartitionKeyDefinition"/> object.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ContainerProperties.ResourceId">
            <summary>
            Gets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB
            resource whether that is a database, a container or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ContainerProperties.ValidateRequiredProperties">
            <summary>
            Throws an exception if an invalid id or partition key is set.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosResource">
            <summary> 
             Represents an abstract resource type in the Azure Cosmos DB service.
             All Azure Cosmos DB resources, such as <see cref="T:Microsoft.Azure.Cosmos.Database"/>, <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/>, and <see cref="T:Microsoft.Azure.Documents.Document"/> extend this abstract type.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DatabaseProperties">
            <summary>
            Represents a database in the Azure Cosmos DB account.
            </summary>
            <remarks>
            Each Azure Cosmos DB database account can have zero or more databases. A database in Azure Cosmos DB is a logical container for 
            document collections and users.
            Refer to <see>https://docs.microsoft.com/azure/cosmos-db/databases-containers-items#databases</see> for more details on databases.
            </remarks>
            <example>
            The example below creates a new Database with an Id property of 'MyDatabase'.
            <code language="c#">
            <![CDATA[ 
            using (CosmosClient client = new CosmosClient("connection string"))
            {
                DatabaseProperties db1 = await client.CreateDatabaseAsync("MyDatabase");
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DatabaseProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DatabaseProperties.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="id">The Id of the resource in the Azure Cosmos service.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseProperties.Id">
            <summary>
            Gets or sets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            </para>
            <para>
            When working with document resources, they too have this settable Id property. 
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database. 
            You can override this auto Id generation by setting the disableAutomaticIdGeneration parameter on the <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> instance to true.
            This will prevent the SDK from generating new Ids. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseProperties.LastModified">
            <summary>
            Gets the last modified time stamp associated with <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties" /> from the Azure Cosmos DB service.
            </summary>
            <value>The last modified time stamp associated with the resource.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseProperties.ResourceId">
            <summary>
            Gets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB 
            resource whether that is a database, a collection or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DatabaseProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DataType">
            <summary>
            Defines the target data type of an index path specification in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.DataType.Number">
            <summary>
            Represents a numeric data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.DataType.String">
            <summary>
            Represents a string data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.DataType.Point">
            <summary>
            Represent a point data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.DataType.LineString">
            <summary>
            Represent a line string data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.DataType.Polygon">
            <summary>
            Represent a polygon data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.DataType.MultiPolygon">
            <summary>
            Represent a multi-polygon data type.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.DedicatedGatewayRequestOptions">
            <summary>
            The Dedicated Gateway request options
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.DedicatedGatewayRequestOptions.MaxIntegratedCacheStaleness">
            <summary> 
            Gets or sets the staleness value associated with the request in the Azure CosmosDB service. 
            </summary> 
            <value>Default value is null.</value> 
            <remarks> 
            For requests where the <see cref="T:Microsoft.Azure.Cosmos.ConsistencyLevel"/> is <see cref="F:Microsoft.Azure.Cosmos.ConsistencyLevel.Eventual"/> or <see cref="F:Microsoft.Azure.Cosmos.ConsistencyLevel.Session"/>, responses from the integrated cache are guaranteed to be no staler than value indicated by this MaxIntegratedCacheStaleness. 
            Cache Staleness is supported in milliseconds granularity. Anything smaller than milliseconds will be ignored.
            </remarks> 
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ExcludedPath">
            <summary> 
            Specifies a path within a JSON document to be excluded while indexing data for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ExcludedPath.Path">
            <summary>
            Gets or sets the path to be excluded from indexing in the Azure Cosmos DB service.
            </summary>
            <value>
            The path to be excluded from indexing.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ExcludedPath.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.GeospatialConfig">
            <summary>
            Represents geospatial configuration for a collection in the Azure Cosmos DB service
            </summary>
            <example>
            <![CDATA[
               {
                  "id": "CollectionId",
                  "indexingPolicy":...,
                  "geospatialConfig": 
                  {
                      "type": "Geography"
                  }
               }
            ]]>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.GeospatialConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.GeospatialConfig"/> class for the Azure Cosmos DB service.
            </summary>
            <remarks>
            Geospatial type is set to Geography by default.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.GeospatialConfig.#ctor(Microsoft.Azure.Cosmos.GeospatialType)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.GeospatialConfig"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="geospatialType">Specifies GeospatialType of collection, which can be either Geography or Geometry</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.GeospatialConfig.GeospatialType">
            <summary>
            Gets or sets the geospatial type (geography or geometry) in the Azure Cosmos DB service.
            </summary>
            <value>
            One of the values of the <see cref="T:Microsoft.Azure.Documents.GeospatialType"/> enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.GeospatialConfig.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.GeospatialType">
            <summary>
            Specifies the supported geospatial types in the Azure Cosmos DB service.
            </summary> 
        </member>
        <member name="F:Microsoft.Azure.Cosmos.GeospatialType.Geography">
            <summary>
            Represents data in round-earth coordinate system.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.GeospatialType.Geometry">
            <summary>
            Represents data in Eucledian(flat) coordinate system.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.HashIndex">
            <summary>
            Represents details of the hash index setting in an Azure Cosmos DB service.
            </summary>
            <remarks>
            Can be used to serve queries like: SELECT * FROM docs d WHERE d.prop = 5.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.HashIndex.#ctor(Microsoft.Azure.Cosmos.DataType)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.HashIndex"/> class with specified DataType for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <seealso cref="P:Microsoft.Azure.Cosmos.HashIndex.DataType"/>
            <example>
            Here is an example to instantiate HashIndex class passing in the DataType:
            <code language="c#">
            <![CDATA[
            HashIndex hashIndex = new HashIndex(DataType.String);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.HashIndex.#ctor(Microsoft.Azure.Cosmos.DataType,System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.HashIndex"/> class with specified DataType and precision for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <param name="precision">Specifies the precision to be used for the data type associated with this index.</param>
            <seealso cref="P:Microsoft.Azure.Cosmos.HashIndex.DataType"/>
            <example>
            Here is an example to instantiate HashIndex class passing in the DataType and precision:
            <code language="c#">
            <![CDATA[
            HashIndex hashIndex = new HashIndex(DataType.String, 3);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.HashIndex.DataType">
            <summary>
            Gets or sets the data type for which this index should be applied in the Azure Cosmos DB service.
            </summary>
            <value>
            The data type for which this index should be applied.
            </value>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.HashIndex.Precision">
            <summary>
            Gets or sets the precision for this particular index in the Azure Cosmos DB service.
            </summary>
            <value>
            The precision for this particular index. Returns null, if not set.
            </value>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.HashIndex.Clone">
            <summary>
            Creates a copy of the hash index for the Azure Cosmos DB service.
            </summary>
            <returns>A clone of the hash index.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IncludedPath">
            <summary> 
            Specifies a path within a JSON document to be included in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IncludedPath.Path">
            <summary>
            Gets or sets the path to be indexed in the Azure Cosmos DB service.
            </summary>
            <value>
            The path to be indexed.
            </value>
            <remarks>
            Some valid examples: /"prop"/?, /"prop"/**, /"prop"/"subprop"/?, /"prop"/[]/?
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IncludedPath.Indexes">
            <summary>
            Gets or sets the collection of <see cref="T:Microsoft.Azure.Cosmos.Index"/> objects to be applied for this included path in the Azure Cosmos DB service.
            </summary>
            <value>
            The collection of the <see cref="T:Microsoft.Azure.Cosmos.Index"/> objects to be applied for this included path.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IncludedPath.IsFullIndex">
            <summary>
            Gets or sets whether this is a full index used for collection types.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IncludedPath.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Index">
            <summary>
            Base class for IndexingPolicy Indexes in the Azure Cosmos DB service, you should use a concrete Index like HashIndex or RangeIndex.
            </summary> 
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Index.#ctor(Microsoft.Azure.Cosmos.IndexKind)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Index"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Index.Kind">
            <summary>
            Gets or sets the kind of indexing to be applied in the Azure Cosmos DB service.
            </summary>
            <value>
            One of the values of the <see cref="T:Microsoft.Azure.Documents.IndexKind"/> enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Index.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Index.Range(Microsoft.Azure.Cosmos.DataType)">
            <summary>
            Returns an instance of the <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> class with specified DataType for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> type.</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.DataType"/>
            <example>
            Here is an example to create RangeIndex instance passing in the DataType:
            <code language="c#">
            <![CDATA[
            RangeIndex rangeIndex = Index.Range(DataType.Number);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Index.Range(Microsoft.Azure.Cosmos.DataType,System.Int16)">
            <summary>
            Returns an instance of the <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> class with specified DataType and precision for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <param name="precision">Specifies the precision to be used for the data type associated with this index.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> type.</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.DataType"/>
            <example>
            Here is an example to create RangeIndex instance passing in the DataType and precision:
            <code language="c#">
            <![CDATA[
            RangeIndex rangeIndex = Index.Range(DataType.Number, -1);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Index.Hash(Microsoft.Azure.Cosmos.DataType)">
            <summary>
            Returns an instance of the <see cref="T:Microsoft.Azure.Cosmos.HashIndex"/> class with specified DataType for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.HashIndex"/> type.</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.DataType"/>
            <example>
            Here is an example to create HashIndex instance passing in the DataType:
            <code language="c#">
            <![CDATA[
            HashIndex hashIndex = Index.Hash(DataType.String);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Index.Hash(Microsoft.Azure.Cosmos.DataType,System.Int16)">
            <summary>
            Returns an instance of the <see cref="T:Microsoft.Azure.Cosmos.HashIndex"/> class with specified DataType and precision for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <param name="precision">Specifies the precision to be used for the data type associated with this index.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.HashIndex"/> type.</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.DataType"/>
            <example>
            Here is an example to create HashIndex instance passing in the DataType and precision:
            <code language="c#">
            <![CDATA[
            HashIndex hashIndex = Index.Hash(DataType.String, 3);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Index.Spatial(Microsoft.Azure.Cosmos.DataType)">
            <summary>
            Returns an instance of the <see cref="T:Microsoft.Azure.Cosmos.SpatialIndex"/> class with specified DataType for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.SpatialIndex"/> type.</returns>
            <seealso cref="T:Microsoft.Azure.Cosmos.DataType"/>
            <example>
            Here is an example to create SpatialIndex instance passing in the DataType:
            <code language="c#">
            <![CDATA[
            SpatialIndex spatialIndex = Index.Spatial(DataType.Point);
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IndexingDirective">
            <summary> 
            Specifies whether or not the resource in the Azure Cosmos DB database is to be indexed.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexingDirective.Default">
            <summary>
            Use any pre-defined/pre-configured defaults.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexingDirective.Include">
            <summary>
            Index the resource.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexingDirective.Exclude">
            <summary>
             Do not index the resource.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IndexingMode">
            <summary> 
            Specifies the supported indexing modes in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexingMode.Consistent">
            <summary>
            Index is updated synchronously with a create, update or delete operation.
            </summary>
            <remarks>
            With consistent indexing, query consistency is the same as the default consistency level for the database account. 
            The index is always kept up to date with the data.
            
            The default IndexingMode is Consistent.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexingMode.Lazy">
            <summary>
            Index is updated asynchronously with respect to a create, update or delete operation.
            </summary>
            <remarks>
            With lazy indexing, queries are eventually consistent. 
            The index is updated when the collection is operating below full throughput capacity (Request units per second). 
            
            Write operations will consume fewer request units (RequestCharge) at the time of write.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexingMode.None">
            <summary>
            No index is provided.
            </summary>
            <remarks>
            Setting IndexingMode to "None" drops the index. Use this if you don't want to maintain the index for a document collection, to save the storage cost or improve the write throughput. Your queries will degenerate to scans of the entire collection.
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IndexingPolicy">
            <summary>
            Represents the indexing policy configuration for a collection in the Azure Cosmos DB service.
            </summary> 
            <remarks>
            Indexing policies can used to configure which properties (JSON paths) are included/excluded, whether the index is updated consistently
            or offline (lazy), automatic vs. opt-in per-document, as well as the precision and type of index per path.
            <para>
            Refer to https://docs.microsoft.com/azure/cosmos-db/index-policy for additional information on how to specify
            indexing policies.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.IndexingPolicy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.IndexingPolicy"/> class for the Azure Cosmos DB service.
            </summary>
            <remarks>
            Indexing mode is set to consistent.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.Automatic">
            <summary>
            Gets or sets a value that indicates whether automatic indexing is enabled for a collection in the Azure Cosmos DB service.
            </summary>
            <remarks>
            In automatic indexing, documents can be explicitly excluded from indexing using <see cref="T:Microsoft.Azure.Documents.Client.RequestOptions"/>.  
            In manual indexing, documents can be explicitly included.
            </remarks>
            <value>
            True, if automatic indexing is enabled; otherwise, false.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.IndexingMode">
            <summary>
            Gets or sets the indexing mode (consistent or lazy) in the Azure Cosmos DB service.
            </summary>
            <value>
            One of the values of the <see cref="T:Microsoft.Azure.Cosmos.IndexingMode"/> enumeration.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.IncludedPaths">
            <summary>
            Gets the collection containing <see cref="T:Microsoft.Azure.Cosmos.IncludedPath"/> objects in the Azure Cosmos DB service.
            </summary>
            <value>
            The collection containing <see cref="T:Microsoft.Azure.Cosmos.IncludedPath"/> objects.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.ExcludedPaths">
            <summary>
            Gets the collection containing <see cref="T:Microsoft.Azure.Cosmos.ExcludedPath"/> objects in the Azure Cosmos DB service.
            </summary>
            <value>
            The collection containing <see cref="T:Microsoft.Azure.Cosmos.ExcludedPath"/> objects.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.CompositeIndexes">
            <summary>
            Gets the composite indexes for additional indexes
            </summary>
            <example>
            <![CDATA[
              "composite": [
                 [
                    {
                       "path": "/joining_year",
                       "order": "ascending"
                    },
                    {
                       "path": "/level",
                       "order": "descending"
                    }
                 ],
                 [
                    {
                       "path": "/country"
                    },
                    {
                       "path": "/city"
                    }
                 ]
              ]
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.SpatialIndexes">
            <summary>
            Collection of spatial index definitions to be used
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.IndexingPolicy.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.IndexKind">
            <summary>
            These are the indexing types available for indexing a path in the Azure Cosmos DB service.
            </summary>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexKind.Hash">
            <summary>
            The index entries are hashed to serve point look up queries.
            </summary>
            <remarks>
            Can be used to serve queries like: SELECT * FROM docs d WHERE d.prop = 5
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexKind.Range">
            <summary>
            The index entries are ordered. Range indexes are optimized for inequality predicate queries with efficient range scans.
            </summary>
            <remarks>
            Can be used to serve queries like: SELECT * FROM docs d WHERE d.prop > 5
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.IndexKind.Spatial">
            <summary>
            The index entries are indexed to serve spatial queries.
            </summary>
            <remarks>
            Can be used to serve queries like: SELECT * FROM Root r WHERE ST_DISTANCE({"type":"Point","coordinates":[71.0589,42.3601]}, r.location) $LE 10000
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.OperationKind">
            <summary>
            These are the operation types resulted in a version conflict on a resource. 
            </summary>
            <remarks>
            When a version conflict occurs during an async operation, retrieving the <see cref="T:Microsoft.Azure.Cosmos.ConflictProperties"/> instance will allow you 
            to determine which resource and operation cause the conflict.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.OperationKind.Invalid">
            <summary>
            An invalid operation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.OperationKind.Create">
            <summary>
            A create operation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.OperationKind.Replace">
            <summary>
            An replace operation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.OperationKind.Delete">
            <summary>
            A delete operation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.OperationKind.Read">
            <summary>
            This operation does not apply to Conflict.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PartitionKeyDefinitionVersion">
            <summary>
            Partitioning version.
            </summary> 
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PartitionKeyDefinitionVersion.V1">
            <summary>
            Original version of hash partitioning.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.PartitionKeyDefinitionVersion.V2">
            <summary>
            Enhanced version of hash partitioning - offers better distribution of long partition keys and uses less storage.
            </summary>
            <remarks>This version should be used for any practical purpose, but it is available in newer SDKs only.</remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Internal.PermissionMode">
            <summary> 
            These are the access permissions for creating or replacing a <see cref="T:Microsoft.Azure.Documents.Permission" /> resource in the Azure Cosmos DB service.
            </summary>
            <remarks>
            A Permission resource associates an access permission of a user on a particular resource.
            </remarks>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Internal.PermissionMode.Read">
            <summary>
            Read permission mode will provide the user with Read only access to a resource.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Internal.PermissionMode.All">
            <summary>
            All permission mode will provide the user with full access(read, insert, replace and delete) to a resource.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.PermissionProperties">
            <summary> 
            Represents a permission in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PermissionProperties.#ctor(System.String,Microsoft.Azure.Cosmos.PermissionMode,Microsoft.Azure.Cosmos.Container,System.Nullable{Microsoft.Azure.Cosmos.PartitionKey})">
            <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> with permission to <see cref="T:Microsoft.Azure.Cosmos.Container"/>.
            </summary>
            <param name="id">The permission id.</param>
            <param name="permissionMode">The <see cref="P:Microsoft.Azure.Cosmos.PermissionProperties.PermissionMode"/>.</param>
            <param name="container">The <see cref="T:Microsoft.Azure.Cosmos.Container"/> object.</param>
            <param name="resourcePartitionKey">(Optional) The partition key value for the permission in the Azure Cosmos DB service.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PermissionProperties.#ctor(System.String,Microsoft.Azure.Cosmos.PermissionMode,Microsoft.Azure.Cosmos.Container,Microsoft.Azure.Cosmos.PartitionKey,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> with permission to Cosmos item.
            </summary>
            <param name="id">The permission id.</param>
            <param name="permissionMode">The <see cref="P:Microsoft.Azure.Cosmos.PermissionProperties.PermissionMode"/>.</param>
            <param name="container">The <see cref="T:Microsoft.Azure.Cosmos.Container"/> object.</param>
            <param name="resourcePartitionKey">The <see cref="T:Microsoft.Azure.Cosmos.PartitionKey"/> of the resource in the Azure Cosmos service.</param>
            <param name="itemId">The cosmos item id</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.PermissionProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.Id">
            <summary>
            Gets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            </para>
            <para>
            When working with document resources, they too have this settable Id property. 
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database.
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.ResourceUri">
            <summary> 
            Gets the self-uri of resource to which the permission applies in the Azure Cosmos DB service.
            </summary>
            <value>
            The-uri of the resource to which the permission applies.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.ResourcePartitionKey">
            <summary>
            Gets optional partition key value for the permission in the Azure Cosmos DB service.
            A permission applies to resources when two conditions are met:
                  1. <see cref="P:Microsoft.Azure.Cosmos.PermissionProperties.ResourceUri"/> is prefix of resource's link.
                        For example "/dbs/mydatabase/colls/mycollection" applies to "/dbs/mydatabase/colls/mycollection" and "/dbs/mydatabase/colls/mycollection/docs/mydocument"
                  2. <see cref="P:Microsoft.Azure.Cosmos.PermissionProperties.ResourcePartitionKey"/> is superset of resource's partition key.
                        For example absent/empty partition key is superset of all partition keys.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.PermissionMode">
            <summary>
            Gets the permission mode in the Azure Cosmos DB service.
            </summary>
            <value>
            The <see cref="P:Microsoft.Azure.Cosmos.PermissionProperties.PermissionMode"/> mode: Read or All.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.Token">
            <summary>
            Gets the access token granting the defined permission from the Azure Cosmos DB service.
            </summary>
            <value>
            The access token granting the defined permission.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.LastModified">
            <summary>
            Gets the last modified time stamp associated with <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties" /> from the Azure Cosmos DB service.
            </summary>
            <value>The last modified time stamp associated with the resource.</value>
            <remarks>ResourceToken generation and reading does not apply.</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.ResourceId">
            <summary>
            Gets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB 
            resource whether that is a database, a collection or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.PermissionProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RangeIndex">
            <summary>
            Specifies an instance of the <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> class in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Can be used to serve queries like: SELECT * FROM docs d WHERE d.prop > 5.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RangeIndex.#ctor(Microsoft.Azure.Cosmos.DataType)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> class with specified DataType for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <seealso cref="P:Microsoft.Azure.Cosmos.RangeIndex.DataType"/>
            <example>
            Here is an example to instantiate RangeIndex class passing in the DataType:
            <code language="c#">
            <![CDATA[
            RangeIndex rangeIndex = new RangeIndex(DataType.Number);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RangeIndex.#ctor(Microsoft.Azure.Cosmos.DataType,System.Int16)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.RangeIndex"/> class with specified DataType and precision for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification.</param>
            <param name="precision">Specifies the precision to be used for the data type associated with this index.</param>
            <seealso cref="P:Microsoft.Azure.Cosmos.RangeIndex.DataType"/>
            <example>
            Here is an example to instantiate RangeIndex class passing in the DataType and precision:
            <code language="c#">
            <![CDATA[
            RangeIndex rangeIndex = new RangeIndex(DataType.Number, -1);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RangeIndex.DataType">
            <summary>
            Gets or sets the data type for which this index should be applied in the Azure Cosmos DB service.
            </summary>
            <value>
            The data type for which this index should be applied.
            </value>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RangeIndex.Precision">
            <summary>
            Gets or sets the precision for this particular index in the Azure Cosmos DB service.
            </summary>
            <value>
            The precision for this particular index. Returns null, if not set.
            </value>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RangeIndex.Clone">
            <summary>
            Creates a copy of the range index for the Azure Cosmos DB service.
            </summary>
            <returns>A clone of the range index.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.SpatialIndex">
            <summary>
            Specifies an instance of the <see cref="T:Microsoft.Azure.Cosmos.SpatialIndex"/> class in the Azure Cosmos DB service. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.SpatialIndex.#ctor(Microsoft.Azure.Cosmos.DataType)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.SpatialIndex"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="dataType">Specifies the target data type for the index path specification</param>
            <seealso cref="P:Microsoft.Azure.Cosmos.SpatialIndex.DataType"/>
            <example>
            Here is an example to instantiate SpatialIndex class passing in the DataType
            <code language="c#">
            <![CDATA[
            SpatialIndex spatialIndex = new SpatialIndex(DataType.Point);
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.SpatialIndex.DataType">
            <summary>
            Gets or sets the data type for which this index should be applied in the Azure Cosmos DB service.
            </summary>
            <value>
            The data type for which this index should be applied.
            </value>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/index-policy"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.SpatialPath">
            <summary>
            Spatial index specification
            </summary>
            <example>
            <![CDATA[
                "spatialIndexes":
                [
                    {  
                        "path":"/'region'/?",
                        "types":["Polygon"],
                        "boundingBox": 
                            {
                               "xmin":0, 
                               "ymin":0,
                               "xmax":10, 
                               "ymax":10
                            }
                   }
              ]
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.SpatialPath.Path">
            <summary>
            Path in JSON document to index
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.SpatialPath.SpatialTypes">
            <summary>
            Path's spatial type
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.SpatialPath.BoundingBox">
            <summary>
            Gets or sets the bounding box
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.SpatialPath.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.SpatialType">
            <summary>
            Defines the target data type of an index path specification in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SpatialType.Point">
            <summary>
            Represent a point data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SpatialType.LineString">
            <summary>
            Represent a line string data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SpatialType.Polygon">
            <summary>
            Represent a polygon data type.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SpatialType.MultiPolygon">
            <summary>
            Represent a multi-polygon data type.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ThroughputProperties">
            <summary>
            Represents a throughput of the resources in the Azure Cosmos DB service.
            It is the standard pricing for the resource in the Azure Cosmos DB service.
            </summary>
            <remarks>
            It contains provisioned container throughput in measurement of request units per second in the Azure Cosmos service.
            </remarks>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/request-units">Request Units</seealso>
            <seealso href="https://docs.microsoft.com/azure/cosmos-db/set-throughput">Set throughput on resources</seealso>
            <example>
            The example below fetch the ThroughputProperties on testContainer.
            <code language="c#">
            <![CDATA[ 
            ThroughputProperties throughputProperties = await testContainer.ReadThroughputAsync().Resource;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputProperties.#ctor">
            <summary>
            Default constructor for serialization
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputProperties.#ctor(Microsoft.Azure.Cosmos.OfferContentProperties)">
            <summary>
            Create a instance for fixed throughput
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.LastModified">
            <summary>
            Gets the last modified time stamp associated with <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties" /> from the Azure Cosmos DB service.
            </summary>
            <value>The last modified time stamp associated with the resource.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.Throughput">
            <summary>
            Gets the provisioned throughput for a resource in measurement of request units per second in the Azure Cosmos service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.AutoscaleMaxThroughput">
            <summary>
            The maximum throughput the autoscale will scale to.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.AutoUpgradeMaxThroughputIncrementPercentage">
            <summary>
            The amount to increment if the maximum RUs is getting throttled.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputProperties.CreateManualThroughput(System.Int32)">
            <summary>
            The Throughput properties for manual provisioned throughput offering
            </summary>
            <param name="throughput">The current provisioned throughput for the resource.</param>
            <returns>Returns a ThroughputProperties for manual throughput</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputProperties.CreateAutoscaleThroughput(System.Int32)">
            <summary>
            The Throughput properties for autoscale provisioned throughput offering
            </summary>
            <param name="autoscaleMaxThroughput">The maximum throughput the resource can scale to.</param>
            <returns>Returns a ThroughputProperties for autoscale provisioned throughput</returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.OfferRID">
            <summary>
            Gets the offer rid.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.ResourceRID">
            <summary>
            Gets the resource rid.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.OfferVersion">
            <summary>
            Gets the version of this offer resource in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UniqueKey">
            <summary>
            Represents a unique key on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
            </summary>
            <remarks>
            1) For partitioned collections, the value of partition key is implicitly a part of each unique key.
            2) Uniqueness constraint is also enforced for missing values.
            For instance, if unique key policy defines a unique key with single property path, there could be only one document that has missing value for this property.
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.UniqueKeyPolicy"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UniqueKey.Paths">
            <summary>
            Gets the paths, a set of which must be unique for each document in the Azure Cosmos DB service.
            </summary>
            <value>
            <![CDATA[The paths to enforce uniqueness on. Each path is a rooted path of the unique property in the document, such as "/name/first".]]>
            </value>
            <example>
            <![CDATA[
            uniqueKey.Paths = new Collection<string> { "/name/first", "/name/last" };
            ]]>
            </example>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UniqueKey.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UniqueKeyPolicy">
            <summary>
            Represents the unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
            </summary>
            <remarks>
            Unique key policies add a layer of data integrity to an Azure Cosmos container. They cannot be modified once the container is created.
            <para>
            Refer to <see>https://docs.microsoft.com/en-us/azure/cosmos-db/unique-keys</see> for additional information on how to specify
            unique key policies.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Azure.Cosmos.ContainerProperties"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UniqueKeyPolicy.UniqueKeys">
            <summary>
            Gets collection of <see cref="T:Microsoft.Azure.Cosmos.UniqueKey"/> that guarantee uniqueness of documents in collection in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UniqueKeyPolicy.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UserProperties">
            <summary> 
            Represents a user in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UserProperties.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> class for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UserProperties.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> class for the Azure Cosmos DB service.
            </summary>
            <param name="id">The Id of the resource in the Azure Cosmos service.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.Id">
            <summary>
            Gets or sets the Id of the resource in the Azure Cosmos DB service.
            </summary>
            <value>The Id associated with the resource.</value>
            <remarks>
            <para>
            Every resource within an Azure Cosmos DB database account needs to have a unique identifier. 
            </para>
            <para>
            When working with document resources, they too have this settable Id property. 
            If an Id is not supplied by the user the SDK will automatically generate a new GUID and assign its value to this property before
            persisting the document in the database. 
            </para>
            <para>
            The following characters are restricted and cannot be used in the Id property:
             '/', '\\', '?', '#'
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.ETag">
            <summary>
            Gets the entity tag associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>
            The entity tag associated with the resource.
            </value>
            <remarks>
            ETags are used for concurrency checking when updating resources. 
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.LastModified">
            <summary>
            Gets the last modified time stamp associated with <see cref="T:Microsoft.Azure.Cosmos.DatabaseProperties" /> from the Azure Cosmos DB service.
            </summary>
            <value>The last modified time stamp associated with the resource.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.SelfLink">
            <summary>
            Gets the self-link associated with the resource from the Azure Cosmos DB service.
            </summary>
            <value>The self-link associated with the resource.</value> 
            <remarks>
            A self-link is a static addressable Uri for each resource within a database account and follows the Azure Cosmos DB resource model.
            E.g. a self-link for a document could be dbs/db_resourceid/colls/coll_resourceid/documents/doc_resourceid
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.ResourceId">
            <summary>
            Gets the Resource Id associated with the resource in the Azure Cosmos DB service.
            </summary>
            <value>
            The Resource Id associated with the resource.
            </value>
            <remarks>
            A Resource Id is the unique, immutable, identifier assigned to each Azure Cosmos DB 
            resource whether that is a database, a collection or a document.
            These resource ids are used when building up SelfLinks, a static addressable Uri for each resource within a database account.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.Permissions">
            <summary>
            Gets the permissions associated with the user for the Azure Cosmos DB service.
            </summary>
            <value>The permissions associated with the user.</value> 
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.PermissionsLink">
            <summary>
            Gets the self-link of the permissions associated with the user for the Azure Cosmos DB service.
            </summary>
            <value>The self-link of the permissions associated with the user.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserProperties.AdditionalProperties">
            <summary>
            This contains additional values for scenarios where the SDK is not aware of new fields. 
            This ensures that if resource is read and updated none of the fields will be lost in the process.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ThroughputResponse">
            <summary>
            The cosmos throughput response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.ThroughputResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.ThroughputProperties,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.MinThroughput">
            <summary>
            Gets minimum throughput in measurement of request units per second in the Azure Cosmos service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.ThroughputResponse.IsReplacePending">
            <summary>
            Gets the status whether offer replace is successful or pending.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ThroughputResponse.op_Implicit(Microsoft.Azure.Cosmos.ThroughputResponse)~Microsoft.Azure.Cosmos.ThroughputProperties">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.ThroughputProperties"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.ThroughputResponse"/>
            </summary>
            <param name="response">Throughput response</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.User">
            <summary>
            Operations for reading, replacing, or deleting a specific existing user by id and query a user's permissions.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.User.Id">
            <summary>
            The Id of the Cosmos user
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.ReadAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Reads a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the user request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> containing the read resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            User user = this.database.GetUser("userId");
            UserProperties userProperties = await user.ReadUserAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.ReplaceAsync(Microsoft.Azure.Cosmos.UserProperties,Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Replace a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> from the Azure Cosmos service as an asynchronous operation.
            </summary>
            <param name="userProperties">The <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> object.</param>
            <param name="requestOptions">(Optional) The options for the user request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> containing the replace resource record.
            </returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            UserProperties userProperties = userReadResponse;
            userProperties.Id = "newuser";
            UserResponse response = await user.ReplaceUserAsync(userProperties);
            UserProperties replacedProperties = response;
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.DeleteAsync(Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
            <summary>
            Delete a <see cref="T:Microsoft.Azure.Cosmos.UserProperties"/> from the Azure Cosmos DB service as an asynchronous operation.
            </summary>
            <param name="requestOptions">(Optional) The options for the user request.</param>
            <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/> which will contain information about the request issued.</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            <code language="c#">
            <![CDATA[
            User user = this.database.GetUser("userId");
            UserResponse response = await user.DeleteUserAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.GetPermission(System.String)">
            <summary>
            Returns a reference to a permission object. 
            </summary>
            <param name="id">The cosmos permission id.</param>
            <returns>Cosmos permission reference</returns>
            <remarks>
            Returns a Permission reference. Reference doesn't guarantee existence.
            Please ensure permssion already exists or is created through a create operation.
            </remarks>
            <example>
            <code language="c#">
            <![CDATA[
            User user = this.cosmosClient.GetDatabase("myDatabaseId").GetUser("userId");
            PermissionResponse response = await user.GetPermssion("permissionId");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.CreatePermissionAsync(Microsoft.Azure.Cosmos.PermissionProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Creates a permission as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="permissionProperties">The <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> object.</param>
             <param name="tokenExpiryInSeconds">(Optional) The expiry time for resource token in seconds. This value can range from 10 seconds, to 24 hours (or 86,400 seconds). The default value for this is 1 hour (or 3,600 seconds). This does not change the default value for future tokens.</param>
             <param name="requestOptions">(Optional) The options for the permission request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             PermissionProperties permissionProperties = new PermissionProperties("permissionId", PermissionMode.All, database.GetContainer("containerId"), new PartitionKey("tenantId"))";
             
             PermissionResponse response = await this.cosmosDatabase.GetUser("userId").CreatePermissionAsync(permissionProperties, tokenExpiryInSeconds: 9000);
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.UpsertPermissionAsync(Microsoft.Azure.Cosmos.PermissionProperties,System.Nullable{System.Int32},Microsoft.Azure.Cosmos.RequestOptions,System.Threading.CancellationToken)">
             <summary>
             Upsert a permission as an asynchronous operation in the Azure Cosmos service.
             </summary>
             <param name="permissionProperties">The <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> object.</param>
             <param name="tokenExpiryInSeconds">(Optional) The expiry time for resource token in seconds. This value can range from 10 seconds, to 24 hours (or 86,400 seconds). The default value for this is 1 hour (or 3,600 seconds). This does not change the default value for future tokens.</param>
             <param name="requestOptions">(Optional) The options for the permission request.</param>
             <param name="cancellationToken">(Optional) <see cref="T:System.Threading.CancellationToken"/> representing request cancellation.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing a <see cref="T:Microsoft.Azure.Cosmos.PermissionResponse"/> which wraps a <see cref="T:Microsoft.Azure.Cosmos.PermissionProperties"/> containing the read resource record.</returns>
             <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
             <example>
            
             <code language="c#">
             <![CDATA[
             PermissionProperties permissionProperties = new PermissionProperties("permissionId", PermissionMode.All, database.GetContainer("containerId"), new PartitionKey("tenantId"))";
             
             PermissionResponse response = await this.cosmosDatabase.GetUser("userId").UpsertPermissionAsync(permissionProperties, tokenExpiryInSeconds: 9000);
             ]]>
             </code>
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.GetPermissionQueryIterator``1(System.String,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for permission under a user using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <param name="queryText">The cosmos SQL query text.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the user query request <see cref="T:Microsoft.Azure.Cosmos.QueryRequestOptions"/></param>
            <returns>An iterator to go through the permission</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            1. This create the type feed iterator for permission with queryText as input,
            <code language="c#">
            <![CDATA[
            string queryText = "SELECT * FROM c where c.status like 'start%'";
            using (FeedIterator<PermissionProperties> feedIterator = this.users.GetPermissionQueryIterator<PermissionProperties>(queryText))
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<PermissionProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var permission in response)
                    {
                        Console.WriteLine(permission);
                    }
                }
            }
            ]]>
            </code>
            </example>
            <example>
            2. This create the type feed iterator for permissions without queryText, retrieving all permissions.
            <code language="c#">
            <![CDATA[
            using (FeedIterator<PermissionProperties> feedIterator = this.user.GetPermissionQueryIterator<PermissionProperties>())
            {
                while (feedIterator.HasMoreResults)
                {
                    FeedResponse<PermissionProperties> response = await feedIterator.ReadNextAsync();
                    foreach (var permission in response)
                    {
                        Console.WriteLine(permission);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.User.GetPermissionQueryIterator``1(Microsoft.Azure.Cosmos.QueryDefinition,System.String,Microsoft.Azure.Cosmos.QueryRequestOptions)">
            <summary>
            This method creates a query for permissions under a database using a SQL statement. It returns a FeedIterator.
            For more information on preparing SQL statements with parameterized values, please see <see cref="T:Microsoft.Azure.Cosmos.QueryDefinition"/> overload.
            </summary>
            <remarks>
            Reading permissions will generate a new ResourceTokens. Prior ResourceTokens will still be valid.
            </remarks>
            <param name="queryDefinition">The cosmos SQL query definition.</param>
            <param name="continuationToken">(Optional) The continuation token in the Azure Cosmos DB service.</param>
            <param name="requestOptions">(Optional) The options for the user query request <see cref="T:Microsoft.Azure.Cosmos.QueryRequestOptions"/></param>
            <returns>An iterator to go through the permissions</returns>
            <exception>https://aka.ms/cosmosdb-dot-net-exceptions</exception>
            <example>
            This create the type feed iterator for permissions with queryDefinition as input.
            <code language="c#">
            <![CDATA[
            QueryDefinition queryDefinition = new QueryDefinition("SELECT * FROM c where c.status like @status")
                .WithParameter("@status", "start%");
            using (FeedIterator<PermissionProperties> resultSet = this.user.GetPermissionQueryIterator<PermissionProperties>(queryDefinition))
            {
                while (feedIterator.HasMoreResults)
                {
                    foreach (PermissionProperties properties in await feedIterator.ReadNextAsync())
                    {
                        Console.WriteLine(properties.Id);
                    }
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UserCore">
            <summary>
            Operations for reading, replacing, or deleting a specific, existing user by id.
            
            <see cref="T:Microsoft.Azure.Cosmos.User"/> for creating new users, and reading/querying all user;
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserCore.Id">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserCore.Database">
            <summary>
            Returns a reference to a database object. 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UserResponse">
            <summary>
            The cosmos user response
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UserResponse.#ctor">
            <summary>
            Create a <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/> as a no-op for mock testing
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UserResponse.#ctor(System.Net.HttpStatusCode,Microsoft.Azure.Cosmos.Headers,Microsoft.Azure.Cosmos.UserProperties,Microsoft.Azure.Cosmos.User,Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            A private constructor to ensure the factory is used to create the object.
            This will prevent memory leaks when handling the HttpResponseMessage
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.User">
            <summary>
            The reference to the cosmos user. This allows additional operations on the user
            or for easy access permissions
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.Headers">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.Resource">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.StatusCode">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.Diagnostics">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.RequestCharge">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.ActivityId">
            <inheritdoc/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.UserResponse.ETag">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UserResponse.op_Implicit(Microsoft.Azure.Cosmos.UserResponse)~Microsoft.Azure.Cosmos.User">
            <summary>
            Get <see cref="T:Microsoft.Azure.Cosmos.User"/> implicitly from <see cref="T:Microsoft.Azure.Cosmos.UserResponse"/>
            </summary>
            <param name="response">UserResponse</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RestoreState">
            <summary> 
            Specifies the different states of restore,
            should match RestoreConstants.h
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.RestoreState.Invalid">
            <summary>
             Not Specified.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.RestoreState.RestorePending">
            <summary>
             Collection Restore is currently ongoing.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.RestoreState.RestoreCompleted">
            <summary>
             Collection Restore completed with success.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.RestoreState.RestoreFailed">
            <summary>
            Collection Restore completed with failure.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RetryOptions">
            <summary>
            RetryOptions class defines the parameters an application can set to customize the
            built-in retry policies in the Azure Cosmos DB service.
            </summary>
            <remarks>
            The <see cref="T:Microsoft.Azure.Cosmos.DocumentClient"/> class supports retry
            on certain types of exceptions. This class provides options for applications to control the
            retry behavior.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RetryOptions.#ctor">
            <summary>
            Creates a new instance of the RetryOptions class and intialize all properties
            to default values for the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RetryOptions.MaxRetryAttemptsOnThrottledRequests">
            <summary>
            Gets or sets the maximum number of retries in the case where the request fails
            because the Azure Cosmos DB service has applied rate limiting on the client.
            </summary>
            <value>
            The default value is 9. This means in the case where the request is rate limited,
            the same request will be issued for a maximum of 10 times to the server before
            an error is returned to the application. If the value of this property is set to 0,
            there will be no automatic retry on rate limiting requests from the client and the exception
            needs to handled at the application level.
            For an example on how to set this value, please refer to <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>.
            </value>
            <remarks>
            <para>
            When a client is sending requests faster than the allowed rate,
            the service will return HttpStatusCode 429 (Too Many Request) to rate limit the client. The current
            implementation in the SDK will then wait for the amount of time the service tells it to wait and
            retry after the time has elapsed.
            </para>
            <para>
            For more information, see <see href="https://docs.microsoft.com/en-us/azure/documentdb/documentdb-performance-tips#429">Handle rate limiting/request rate too large</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RetryOptions.MaxRetryWaitTimeInSeconds">
            <summary>
            Gets or sets the maximum retry time in seconds for the Azure Cosmos DB service.
            </summary>
            <value>
            The default value is 30 seconds. For an example on how to set this value, please refer to <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>.
            </value>
            <remarks>
            <para>
            When a request fails due to a rate limiting error, the service sends back a response that
            contains a value indicating the client should not retry before the <see cref="P:Microsoft.Azure.Documents.DocumentClientException.RetryAfter"/> time period has
            elapsed. This property allows the application to set a maximum wait time for all retry attempts.
            If the cumulative wait time exceeds the this value, the client will stop retrying and return the error to the application.
            </para>
            <para>
            For more information, see <see href="https://docs.microsoft.com/en-us/azure/documentdb/documentdb-performance-tips#429">Handle rate limiting/request rate too large</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RetryOptions.InitialRetryForRetryWithMilliseconds">
            <summary>
            Gets or sets the initial delay retry time in milliseconds for the Azure Cosmos DB service
            for requests that hit RetryWithExceptions. This covers errors that occur due to concurrency errors in the store.
            </summary>
            <value>
            The default value is 1 second. For an example on how to set this value, please refer to <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures the client
            to delay the time specified before retrying the request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RetryOptions.MaximumRetryForRetryWithMilliseconds">
            <summary>
            Gets or sets the maximum delay retry time in milliseconds for the Azure Cosmos DB service
            for requests that hit RetryWithExceptions. This covers errors that occur due to concurrency errors in the store.
            </summary>
            <value>
            The default value is 30 seconds. For an example on how to set this value, please refer to <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.RetryOptions"/>.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures the maximum time
            the client should delay before failing the request.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RetryOptions.RandomSaltForRetryWithMilliseconds">
            <summary>
            Gets or sets the interval to salt retrywith retries with. This will spread the retry values from 1..n from the exponential backoff
            subscribed.
            </summary>
            <value>
            The default value is to not salt.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures the jitter on the retry attempted.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.RetryOptions.TotalWaitTimeForRetryWithMilliseconds">
            <summary>
            Gets or sets the total time to wait before failing the request for retrywith failures.
            subscribed.
            </summary>
            <value>
            The default value 30 seconds.
            </value>
            <remarks>
            <para>
            When a request fails due to a RetryWith error, the client delays and retries the request. This configures total time spent waiting on the request.
            </para>
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.RetryPolicy">
            <summary>
            Represents the retry policy configuration assocated with a DocumentClient instance.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RetryPolicy.#ctor(Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager,Microsoft.Azure.Cosmos.ConnectionPolicy,Microsoft.Azure.Cosmos.Routing.GlobalPartitionEndpointManager)">
            <summary>
            Initialize the instance of the RetryPolicy class
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.RetryPolicy.GetRequestPolicy">
            <summary>
            Creates a new instance of the ClientRetryPolicy class retrying request failures.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.AddressResolver">
            <summary>
            Abstracts out the logic to resolve physical replica addresses for the given <see cref="T:Microsoft.Azure.Documents.DocumentServiceRequest"/>.
            
            AddressCache internally maintains CollectionCache, CollectionRoutingMapCache and BackendAddressCache.
            Logic in this class mainly joins these 3 caches and deals with potential staleness of the caches.
            
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.AddressResolver.ThrowIfTargetChanged(Microsoft.Azure.Documents.DocumentServiceRequest,Microsoft.Azure.Documents.PartitionKeyRange)">
            <summary>
            Validates if the target partition to which the request is being sent has changed during retry.
            If that happens, the request is no more valid and need to be retried.
            Also has the side-effect that if the target identity is not set, we set it on the request
            </summary>
            <param name="request">Request in progress</param>
            <param name="targetRange">Target partition key range determined by address resolver</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.AddressResolver.ResolveAddressesAndIdentityAsync(Microsoft.Azure.Documents.DocumentServiceRequest,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Resolves the endpoint of the partition for the given request
            </summary>
            <param name="request">Request for which the partition endpoint resolution is to be performed</param>
            <param name="forceRefreshPartitionAddresses">Force refresh the partition's endpoint</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>An instance of <see cref="T:Microsoft.Azure.Cosmos.AddressResolver.ResolutionResult"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.AsyncCacheNonBlocking`2">
            <summary>
            This is a thread safe AsyncCache that allows refreshing values in the background.
            The benefits of AsyncCacheNonBlocking over AsyncCache is it keeps stale values until the refresh is completed. 
            AsyncCache removes values causing it to block all requests until the refresh is complete.
            1. For example 1 replica moved out of the 4 replicas available. 3 replicas could still be processing requests.
               The request going to the 1 stale replica would be retried.
            2. AsyncCacheNonBlocking updates the value in the cache rather than recreating it on each refresh. This will help reduce object creation.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.AsyncCacheNonBlocking`2.GetAsync(`0,System.Func{System.Threading.Tasks.Task{`1}},System.Boolean,System.Action{`1,`1})">
            <summary>
            <para>
            Gets value corresponding to <paramref name="key"/>.
            </para>
            <para>
            If another initialization function is already running, new initialization function will not be started.
            The result will be result of currently running initialization function.
            </para>
            <para>
            If previous initialization function is successfully completed it will return the value. It is possible this
            value is stale and will only be updated after the force refresh task is complete.
            </para>
            <para>
            Force refresh is true:
            If the key does not exist: It will create and await the new task
            If the key exists and the current task is still running: It will return the existing task
            If the key exists and the current task is already done: It will start a new task to get the updated values. 
                Once the refresh task is complete it will be returned to caller. 
                If it is a success the value in the cache will be updated. If the refresh task throws an exception the key will be removed from the cache. 
            </para>
            <para>
            If previous initialization function failed - new one will be launched.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.AsyncCacheNonBlocking`2.AsyncLazyWithRefreshTask`1">
            <summary>
            This is AsyncLazy that has an additional Task that can
            be used to update the value. This allows concurrent requests
            to use the stale value while the refresh is occurring. 
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.ClientCollectionCache">
            <summary>
            Caches collection information.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.CollectionRoutingMap">
            <summary>
            Stored partition key ranges in an efficient way with some additional information and provides
            convenience methods for working with set of ranges.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Routing.CollectionRoutingMap.rangeById">
            <summary>
            Partition key range id to partition address and range.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Routing.CollectionRoutingMap.OrderedPartitionKeyRanges">
            <summary>
            Ranges in increasing order.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.CompositeContinuationToken">
            <summary>
            A composite continuation token that has both backend continuation token and partition range information. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.DocumentAnalyzer.ExtractPartitionKeyValue(Microsoft.Azure.Documents.Document,Microsoft.Azure.Documents.PartitionKeyDefinition)">
            <summary>
            Extracts effective <see cref="T:Microsoft.Azure.Documents.Routing.PartitionKeyInternal"/> from deserialized document.
            </summary>
            <remarks>
            This code doesn't do any validation, as it assumes that IndexingPolicy is valid, as it is coming from the backend.
            Expected format is "/prop1/prop2/?". No array expressions are expected.
            </remarks>
            <param name="document">Deserialized document to extract partition key value from.</param>
            <param name="partitionKeyDefinition">Information about partition key.</param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Documents.Routing.PartitionKeyInternal"/>.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.DocumentAnalyzer.ExtractPartitionKeyValue(System.String,Microsoft.Azure.Documents.PartitionKeyDefinition)">
            <summary>
            Extracts effective <see cref="T:Microsoft.Azure.Documents.Routing.PartitionKeyInternal"/> from serialized document.
            </summary>
            <remarks>
            This code doesn't do any validation, as it assumes that IndexingPolicy is valid, as it is coming from the backend.
            Expected format is "/prop1/prop2/?". No array expressions are expected.
            </remarks>
            <param name="documentString">Serialized document to extract partition key value from.</param>
            <param name="partitionKeyDefinition">Information about partition key.</param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Documents.Routing.PartitionKeyInternal"/>.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.GlobalAddressResolver">
            <summary>
            AddressCache implementation for client SDK. Supports cross region address routing based on
            avaialbility and preference list.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalAddressResolver.GetAddressResolver(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            ReplicatedResourceClient will use this API to get the direct connectivity AddressCache for given request.
            </summary>
            <param name="request"></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager">
            <summary>
            AddressCache implementation for client SDK. Supports cross region address routing based on 
            availability and preference list.
            </summary>
            Marking it as non-sealed in order to unit test it using Moq framework
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager.GetDatabaseAccountFromAnyLocationsAsync(System.Uri,System.Collections.Generic.IList{System.String},System.Func{System.Uri,System.Threading.Tasks.Task{Microsoft.Azure.Cosmos.AccountProperties}},System.Threading.CancellationToken)">
            <summary>
            This will get the account information.
            It will try the global endpoint first. 
            If no response in 5 seconds it will create 2 additional tasks
            The 2 additional tasks will go through all the preferred regions in parallel
            It will return the first success and stop the parallel tasks.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager.GetAccountPropertiesHelper">
            <summary>
            This is a helper class to 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager.GetAccountPropertiesHelper.TryGetAccountPropertiesFromAllLocationsAsync">
            <summary>
            This is done in a thread safe way to allow multiple tasks to iterate over the 
            list of locations.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager.GetLocation(System.Uri)">
            <summary>
            Returns location corresponding to the endpoint
            </summary>
            <param name="endpoint"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager.RefreshDatabaseAccountInternalAsync(System.Boolean)">
            <summary>
            Thread safe refresh account and location info.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalEndpointManager.SkipRefresh(System.Boolean)">
            <summary>
            If the account is currently refreshing or the last refresh occurred less than the minimum time
            just return. This is used to avoid refreshing to often and preventing to much pressure on the gateway.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalPartitionEndpointManager.TryAddPartitionLevelLocationOverride(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Updates the DocumentServiceRequest routing location to point
            new a location based if a partition level failover occurred
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalPartitionEndpointManager.TryMarkEndpointUnavailableForPartitionKeyRange(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Marks the current location unavailable for write. Future 
            requests will be routed to the next location if available
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.GlobalPartitionEndpointManagerCore">
            <summary>
            This class is used to failover single partitions to different regions.
            The client retry policy will mark a partition as down. The PartitionKeyRangeToLocation
            will add an override to the next read region. When the request is retried it will 
            override the default location with the new region from the PartitionKeyRangeToLocation.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.GlobalPartitionEndpointManagerCore.TryMarkEndpointUnavailableForPartitionKeyRange(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Marks the current location unavailable for write
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.IRoutingMapProvider">
            <summary>
            Routing map provider provides list of effective partition key ranges for a collection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.IRoutingMapProvider.TryGetOverlappingRangesAsync(System.String,Microsoft.Azure.Documents.Routing.Range{System.String},Microsoft.Azure.Cosmos.Tracing.ITrace,System.Boolean)">
            <summary>
            Returns list of effective partition key ranges for a collection.
            </summary>
            <param name="collectionResourceId">Collection for which to retrieve routing map.</param>
            <param name="range">This method will return all ranges which overlap this range.</param>
            <param name="trace">The trace.</param>
            <param name="forceRefresh">Whether forcefully refreshing the routing map is necessary</param>
            <returns>List of effective partition key ranges for a collection or null if collection doesn't exist.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.LocationCache">
            <summary>
            Implements the abstraction to resolve target location for geo-replicated DatabaseAccount
            with multiple writable and readable locations.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Routing.LocationCache.ReadEndpoints">
            <summary>
            Gets list of read endpoints ordered by
            1. Preferred location
            2. Endpoint availablity
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Routing.LocationCache.WriteEndpoints">
            <summary>
            Gets list of write endpoints ordered by
            1. Preferred location
            2. Endpoint availablity
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.GetLocation(System.Uri)">
            <summary>
            Returns the location corresponding to the endpoint if location specific endpoint is provided.
            For the defaultEndPoint, we will return the first available write location.
            Returns null, in other cases.
            </summary>
            <remarks>
            Today we return null for defaultEndPoint if multiple write locations can be used.
            This needs to be modifed to figure out proper location in such case.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.TryGetLocationForGatewayDiagnostics(System.Uri,System.String@)">
            <summary>
            Set region name for a location if present in the locationcache otherwise set region name as null.
            If endpoint's hostname is same as default endpoint hostname, set regionName as null.
            </summary>
            <param name="endpoint"></param>
            <param name="regionName"></param>
            <returns>true if region found else false</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.MarkEndpointUnavailableForRead(System.Uri)">
            <summary>
            Marks the current location unavailable for read
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.MarkEndpointUnavailableForWrite(System.Uri)">
            <summary>
            Marks the current location unavailable for write
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.OnDatabaseAccountRead(Microsoft.Azure.Cosmos.AccountProperties)">
            <summary>
            Invoked when <see cref="T:Microsoft.Azure.Cosmos.AccountProperties"/> is read
            </summary>
            <param name="databaseAccount">Read DatabaseAccoaunt </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.OnLocationPreferenceChanged(System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <summary>
            Invoked when <see cref="P:Microsoft.Azure.Cosmos.ConnectionPolicy.PreferredLocations"/> changes
            </summary>
            <param name="preferredLocations"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationCache.ResolveServiceEndpoint(Microsoft.Azure.Documents.DocumentServiceRequest)">
            <summary>
            Resolves request to service endpoint. 
            1. If this is a write request
               (a) If UseMultipleWriteLocations = true
                   (i) For document writes, resolve to most preferred and available write endpoint.
                       Once the endpoint is marked unavailable, it is moved to the end of available write endpoint. Current request will
                       be retried on next preferred available write endpoint.
                   (ii) For all other resources, always resolve to first/second (regardless of preferred locations)
                        write endpoint in <see cref="P:Microsoft.Azure.Cosmos.AccountProperties.WritableRegions"/>.
                        Endpoint of first write location in <see cref="P:Microsoft.Azure.Cosmos.AccountProperties.WritableRegions"/> is the only endpoint that supports
                        write operation on all resource types (except during that region's failover). 
                        Only during manual failover, client would retry write on second write location in <see cref="P:Microsoft.Azure.Cosmos.AccountProperties.WritableRegions"/>.
               (b) Else resolve the request to first write endpoint in <see cref="F:Microsoft.Azure.Cosmos.AccountProperties.writeRegions"/> OR 
                   second write endpoint in <see cref="P:Microsoft.Azure.Cosmos.AccountProperties.WritableRegions"/> in case of manual failover of that location.
            2. Else resolve the request to most preferred available read endpoint (automatic failover for read requests)
            </summary>
            <param name="request">Request for which endpoint is to be resolved</param>
            <returns>Resolved endpoint</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.LocationHelper">
            <summary>
            https://azure.microsoft.com/en-us/regions/
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.LocationHelper.GetLocationEndpoint(System.Uri,System.String)">
            <summary>
            For example, for https://contoso.documents.azure.com:443/ and "West US", this will return https://contoso-westus.documents.azure.com:443/
            NOTE: This ONLY called by client first boot when the input endpoint is not available.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.PartitionKeyHash">
             <summary>
             There are many kinds of documents partitioning schemes (Range, Hash, Range+Hash, Hash+Hash etc.)
             All these partitioning schemes are abstracted by effective partition key.
             Effective partition key is just BYTE*.
             There is function which maps partition key to effective partition key based on partitioning scheme used.
             In case of range partitioning
             effective partition key corresponds one-to-one to partition key extracted from the document and
             relationship between effective partition keys is the same as relationship between partitionkeys from which they were calculated.
             In case of Hash partitioning, values of all paths are hashed together and resulting hash is prepended to the partition key.
             We have single global index on [effective partition key + id]
             </summary>
             <example>
             With the following definition:
                 "partitionKey" : {"paths":["/address/country", "address/zipcode"], "kind" : "Hash"}
             partition key ["USA", 98052] corresponds to effective partition key binaryencode([243451234, "USA", 98052]), where
             243451234 is hash of "USA" and 98052 combined together.
             
             With the following definition:
                 "partitionKey" : {"paths":["/address/country", "address/zipcode"], "kind" : "Range"}
             partition key ["USA", 98052] corresponds to effective partition key binaryencode(["USA", 98052]).
            
             In general this struct represents that hashing logic, which used to generate EPK Ranges on the client side.
             </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.PartitionKeyHashRange.#ctor(System.Nullable{Microsoft.Azure.Cosmos.Routing.PartitionKeyHash},System.Nullable{Microsoft.Azure.Cosmos.Routing.PartitionKeyHash})">
            <summary>
            Range of PartitionKeyHash where both start and end can be nullable, which signals an open range.
            </summary>
            <param name="startInclusive">The inclusive start hash. If null this means that the range starts from negative infinity.</param>
            <param name="endExclusive">The exclusive end hash. If null this means that the range goes until positive infinity.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.PartitionKeyHashRanges">
            <summary>
            Represent a list of ranges with the following properties
            * no duplicates
            * non empty members
            * non empty itself
            * contiguous
            * non overlapping
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Routing.PartitionKeyHashRangeSplitterAndMerger">
            <summary>
            Splits or merges <see cref="T:Microsoft.Azure.Cosmos.Routing.PartitionKeyHashRange"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.PartitionRoutingHelper.TryGetTargetRangeFromContinuationTokenRangeAsync(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Documents.Routing.Range{System.String}},Microsoft.Azure.Cosmos.Routing.IRoutingMapProvider,System.String,Microsoft.Azure.Documents.Routing.Range{System.String},System.Collections.Generic.List{Microsoft.Azure.Cosmos.Routing.CompositeContinuationToken},Microsoft.Azure.Cosmos.Tracing.ITrace,Microsoft.Azure.Documents.RntbdConstants.RntdbEnumerationDirection)">
            <summary>
            Gets <see cref="T:Microsoft.Azure.Documents.PartitionKeyRange"/> instance which corresponds to <paramref name="rangeFromContinuationToken"/>
            </summary>
            <param name="providedPartitionKeyRanges"></param>
            <param name="routingMapProvider"></param>
            <param name="collectionRid"></param>
            <param name="rangeFromContinuationToken"></param>
            <param name="suppliedTokens"></param>
            <param name="trace"></param>
            <param name="direction"></param>
            <returns>null if collection with specified <paramref name="collectionRid"/> doesn't exist, which potentially means
            that collection was resolved to outdated Rid by name. Also null can be returned if <paramref name="rangeFromContinuationToken"/>
            is not found - this means it was split.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.PartitionRoutingHelper.TryAddPartitionKeyRangeToContinuationTokenAsync(Microsoft.Azure.Documents.Collections.INameValueCollection,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Documents.Routing.Range{System.String}},Microsoft.Azure.Cosmos.Routing.IRoutingMapProvider,System.String,Microsoft.Azure.Cosmos.Routing.PartitionRoutingHelper.ResolvedRangeInfo,Microsoft.Azure.Cosmos.Tracing.ITrace,Microsoft.Azure.Documents.RntbdConstants.RntdbEnumerationDirection)">
            <summary>
            TryAddPartitionKeyRangeToContinuationTokenAsync
            </summary>
            <returns><c>false</c> if collectionRid is likely wrong because range was not found. Cache needs to be refreshed probably.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Routing.PathParser.GetPathParts(System.String)">
            <summary>
            Extract parts from path
            </summary>
            <remarks>
            This code doesn't do as much validation as the backend, as it assumes that IndexingPolicy path coming from the backend is valid.
            </remarks>
            <param name="path">A path string</param>
            <returns>An array of parts of path</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.SecureStringUtility">
            <summary>
            Utility for converting string to SecureString.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.SecureStringUtility.ConvertToSecureString(System.String)">
            <summary>
            Converts a unsecure string into a SecureString.
            </summary>
            <param name="unsecureStr">the string to convert.</param>
            <returns>the resulting SecureString</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Serializer.CosmosElementSerializer.ToStream(System.String,System.Collections.Generic.IEnumerable{Microsoft.Azure.Cosmos.CosmosElements.CosmosElement},Microsoft.Azure.Documents.ResourceType,Microsoft.Azure.Cosmos.CosmosSerializationFormatOptions)">
            <summary>
            Converts a list of CosmosElements into a memory stream.
            </summary>
            <param name="containerRid">Container Rid</param>
            <param name="cosmosElements">The cosmos elements</param>
            <param name="resourceType">The resource type</param>
            <param name="cosmosSerializationOptions">The custom serialization options. This allows custom serialization types like BSON, JSON, or other formats</param>
            <returns>Returns a memory stream of cosmos elements. By default the memory stream will contain JSON.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Serializer.CosmosElementSerializer.ElementsToMemoryStream(System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Cosmos.CosmosElements.CosmosElement},Microsoft.Azure.Cosmos.CosmosSerializationFormatOptions)">
            <summary>
            Converts a list of CosmosElements into a memory stream.
            </summary>
            <param name="cosmosElements">The cosmos elements</param>
            <param name="cosmosSerializationOptions">The custom serialization options. This allows custom serialization types like BSON, JSON, or other formats</param>
            <returns>Returns a memory stream of cosmos elements. By default the memory stream will contain JSON.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosFeedResponseSerializer.FromFeedResponseStream``1(Microsoft.Azure.Cosmos.CosmosSerializerCore,System.IO.Stream)">
            <summary>
            The service returns feed responses in an envelope. This removes the envelope
            and serializes all the items into a list
            </summary>
            <param name="serializerCore">The cosmos serializer</param>
            <param name="streamWithServiceEnvelope">A stream with the service envelope like: { "ContainerRid":"Test", "Documents":[{ "id":"MyItem"}], "count":1}</param>
            <returns>A read only list of the serialized items</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosFeedResponseSerializer.GetStreamWithoutServiceEnvelope(System.IO.Stream)">
            <summary>
            The service returns feed responses in an envelope. This removes the envelope
            so it only returns the array of items.
            </summary>
            <param name="streamWithServiceEnvelope">A stream with the service envelope like: { "ContainerRid":"Test", "Documents":[{ "id":"MyItem"}], "count":1}</param>
            <returns>A stream containing only the array of items</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer">
            <summary>
            The default Cosmos JSON.NET serializer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer.#ctor">
            <summary>
            Create a serializer that uses the JSON.net serializer
            </summary>
            <remarks>
            This is internal to reduce exposure of JSON.net types so
            it is easier to convert to System.Text.Json
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer.#ctor(Microsoft.Azure.Cosmos.CosmosSerializationOptions)">
            <summary>
            Create a serializer that uses the JSON.net serializer
            </summary>
            <remarks>
            This is internal to reduce exposure of JSON.net types so
            it is easier to convert to System.Text.Json
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer.#ctor(Newtonsoft.Json.JsonSerializerSettings)">
            <summary>
            Create a serializer that uses the JSON.net serializer
            </summary>
            <remarks>
            This is internal to reduce exposure of JSON.net types so
            it is easier to convert to System.Text.Json
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer.FromStream``1(System.IO.Stream)">
            <summary>
            Convert a Stream to the passed in type.
            </summary>
            <typeparam name="T">The type of object that should be deserialized</typeparam>
            <param name="stream">An open stream that is readable that contains JSON</param>
            <returns>The object representing the deserialized stream</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer.ToStream``1(``0)">
            <summary>
            Converts an object to a open readable stream
            </summary>
            <typeparam name="T">The type of object being serialized</typeparam>
            <param name="input">The object to be serialized</param>
            <returns>An open readable stream containing the JSON of the serialized object</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosJsonDotNetSerializer.GetSerializer">
            <summary>
            JsonSerializer has hit a race conditions with custom settings that cause null reference exception.
            To avoid the race condition a new JsonSerializer is created for each call
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosLinqSerializerOptions">
            <summary>
            This class provides a way to configure Linq Serialization Properties
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosLinqSerializerOptions.#ctor">
            <summary>
            Create an instance of CosmosSerializationOptions
            with the default values for the Cosmos SDK
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosLinqSerializerOptions.PropertyNamingPolicy">
            <summary>
            Gets or sets whether the naming policy used to convert a string-based name to another format,
            such as a camel-casing format.
            </summary>
            <remarks>
            The default value is CosmosPropertyNamingPolicy.Default
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosPropertyNamingPolicy">
            <summary>
            Determines the naming policy used to convert a string-based name to another format, such as a camel-casing where the first letter is lower case.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CosmosPropertyNamingPolicy.Default">
            <summary>
            No custom naming policy.
            The property name will be the same as the source.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.CosmosPropertyNamingPolicy.CamelCase">
            <summary>
            First letter in the property name is lower case. 
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosSerializationFormatOptions.ContentSerializationFormat">
            <summary>
            What serialization format to request the response in from the backend
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosSerializationFormatOptions.CreateCustomNavigatorCallback">
            <summary>
            Creates a navigator that can navigate a JSON in the specified ContentSerializationFormat
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosSerializationFormatOptions.CreateCustomWriterCallback">
            <summary>
            Creates a writer to use to write out the stream.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosSerializationOptions">
            <summary>
            This class provides a way to configure basic
            serializer settings.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosSerializationOptions.#ctor">
            <summary>
            Create an instance of CosmosSerializationOptions
            with the default values for the Cosmos SDK
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosSerializationOptions.IgnoreNullValues">
            <summary>
            Gets or sets if the serializer should ignore null properties
            </summary>
            <remarks>
            The default value is false
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosSerializationOptions.Indented">
            <summary>
            Gets or sets if the serializer should use indentation
            </summary>
            <remarks>
            The default value is false
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.CosmosSerializationOptions.PropertyNamingPolicy">
            <summary>
            Gets or sets whether the naming policy used to convert a string-based name to another format,
            such as a camel-casing format.
            </summary>
            <remarks>
            The default value is CosmosPropertyNamingPolicy.Default
            </remarks>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosSerializer">
            <summary>
            This is an interface to allow a custom serializer to be used by the CosmosClient
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosSerializer.FromStream``1(System.IO.Stream)">
            <summary>
            Convert a Stream of JSON to an object. 
            The implementation is responsible for Disposing of the stream,
            including when an exception is thrown, to avoid memory leaks.
            </summary>
            <typeparam name="T">Any type passed to <see cref="T:Microsoft.Azure.Cosmos.Container"/>.</typeparam>
            <param name="stream">The Stream response containing JSON from Cosmos DB.</param>
            <returns>The object deserialized from the stream.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.CosmosSerializer.ToStream``1(``0)">
            <summary>
            Convert the object to a Stream. 
            The caller will take ownership of the stream and ensure it is correctly disposed of.
            <see href="https://docs.microsoft.com/dotnet/api/system.io.stream.canread">Stream.CanRead</see> must be true.
            </summary>
            <param name="input">Any type passed to <see cref="T:Microsoft.Azure.Cosmos.Container"/>.</param>
            <returns>A readable Stream containing JSON of the serialized object.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.CosmosSerializerCore">
            <summary>
            This is an interface to allow a custom serializer to be used by the CosmosClient
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox">
            <summary>
            Represents a coordinate range for geometries in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.BoundingBox.#ctor(Microsoft.Azure.Cosmos.Spatial.Position,Microsoft.Azure.Cosmos.Spatial.Position)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="min">
            Lowest values for all axes of the bounding box.
            </param>
            <param name="max">
            Highest values for all axes of the bounding box.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.BoundingBox.Min">
            <summary>
            Gets lowest values for all axes of the bounding box in the Azure Cosmos DB service.
            </summary>
            <value>
            Lowest values for all axes of the bounding box.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.BoundingBox.Max">
            <summary>
            Gets highest values for all axes of the bounding box in the Azure Cosmos DB service.
            </summary>
            <value>
            Highest values for all axes of the bounding box.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.BoundingBox.Equals(Microsoft.Azure.Cosmos.Spatial.BoundingBox)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox"/> is equal to the <paramref name="other" /> in the Azure Cosmos DB service.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox"/> to compare to this bounding box.</param>
            <returns><c>true</c> if bounding boxes are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.BoundingBox.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox"/> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.BoundingBox.GetHashCode">
            <summary>
            Serves as a hash function for <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox"/> type in the Azure Cosmos DB service.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox"/>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.BoundingBoxJsonConverter">
            <summary>
            <see cref="T:Newtonsoft.Json.JsonConverter" /> for <see cref="T:Microsoft.Azure.Cosmos.Spatial.BoundingBox" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.BoundingBoxJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The existingValue.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.BoundingBoxJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing existingValue of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            Deserialized object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.BoundingBoxJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.CrsJsonConverter">
            <summary>
            <see cref="T:Newtonsoft.Json.JsonConverter"/> for <see cref="T:Microsoft.Azure.Cosmos.Spatial.Crs" /> class and all its implementations.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.CrsJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.CrsJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            The object value.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.CrsJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.GeometryJsonConverter">
            <summary>
            Converter for <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> class.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Converters.GeometryJsonConverter.CanWrite">
            <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON.
            </summary>
            <value><c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter"/> can write JSON; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.GeometryJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">
            The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.
            </param>
            <param name="value">The existingValue.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.GeometryJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing existingValue of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            Deserialized object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.GeometryJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.LinearRingJsonConverter">
            <summary>
            <see cref="T:Newtonsoft.Json.JsonConverter"/> for <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing" />.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.LinearRingJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The existingValue.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.LinearRingJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing existingValue of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            Deserialized object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.LinearRingJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.LineStringCoordinatesJsonConverter">
            <summary>
            <see cref="T:Newtonsoft.Json.JsonConverter"/> for <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates" />.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.LineStringCoordinatesJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The existingValue.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.LineStringCoordinatesJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing existingValue of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            Deserialized object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.LineStringCoordinatesJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.PolygonCoordinatesJsonConverter">
            <summary>
            <see cref="T:Newtonsoft.Json.JsonConverter"/> for <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates" />.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.PolygonCoordinatesJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The existingValue.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.PolygonCoordinatesJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing existingValue of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            Deserialized object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.PolygonCoordinatesJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Converters.PositionJsonConverter">
            <summary>
            Converter for <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position" /> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.PositionJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">
            The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.
            </param>
            <param name="value">The existingValue.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.PositionJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing existingValue of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>
            Deserialized object.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Converters.PositionJsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns>
            <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Crs">
            <summary>
            Represents Coordinate Reference System in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Crs.#ctor(Microsoft.Azure.Cosmos.Spatial.CrsType)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Crs" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="type">
            CRS type.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Crs.Default">
            <summary>
            Gets default CRS in the Azure Cosmos DB service. Default CRS is named CRS with the name "urn:ogc:def:crs:OGC:1.3:CRS84".
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Crs.Unspecified">
            <summary>
            Gets "Unspecified" CRS in the Azure Cosmos DB service. No CRS can be assumed for Geometries having "Unspecified" CRS.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Crs.Type">
            <summary>
            Gets CRS type in the Azure Cosmos DB service.
            </summary>
            <value>
            Type of CRS.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Crs.Named(System.String)">
            <summary>
            Creates named CRS with the name specified in the Azure Cosmos DB service.
            </summary>
            <param name="name">CRS name.</param>
            <returns>Instance of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Crs" /> class.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Crs.Linked(System.String)">
            <summary>
            Creates linked CRS in the Azure Cosmos DB service.
            </summary>
            <param name="href">
            CRS link.
            </param>
            <returns>
            Instance of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Crs" /> class.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Crs.Linked(System.String,System.String)">
            <summary>
            Creates linked CRS with the optional type specified in the Azure Cosmos DB service.
            </summary>
            <param name="href">
            CRS link.
            </param>
            <param name="type">
            CRS link type.
            </param>
            <returns>
            Instance of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Crs" /> class.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.CrsType">
            <summary>
            Type of Coordinate Reference System in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.CrsType.Named">
            <summary>
            Coordinate Reference System is specified by name.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.CrsType.Linked">
            <summary>
            Coordinate Reference System is specified by link.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.CrsType.Unspecified">
            <summary>
            No Coordinate Reference System can be assumed for a geometry.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Geometry">
            <summary>
            Base class for spatial geometry objects in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.#ctor(Microsoft.Azure.Cosmos.Spatial.GeometryType,Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="type">
            Geometry type.
            </param>
            <param name="geometryParams">
            Coordinate reference system, additional properties etc.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Geometry.Crs">
            <summary>
            Gets the Coordinate Reference System for this geometry in the Azure Cosmos DB service.
            </summary>
            <value>
            The Coordinate Reference System for this geometry.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Geometry.Type">
            <summary>
            Gets geometry type in the Azure Cosmos DB service.
            </summary>
            <value>
            Type of geometry.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Geometry.BoundingBox">
            <summary>
            Gets bounding box for this geometry in the Azure Cosmos DB service.
            </summary>
            <value>
            Bounding box of the geometry.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Geometry.AdditionalProperties">
            <summary>
            Gets additional properties in the Azure Cosmos DB service.
            </summary>
            <value>
            Additional geometry properties.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Geometry.CrsForSerialization">
            <summary>
            Gets or sets CRS value used for serialization in the Azure Cosmos DB service.
            </summary>
            <remarks>
            This is artificial property needed for serialization. If CRS is default one, we don't want
            to serialize anything.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> type in the Azure Cosmos DB service.
            </summary>
            <returns>
            A hash code for the current geometry.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.Distance(Microsoft.Azure.Cosmos.Spatial.Geometry)">
            <summary>
            Distance in meters between two geometries in the Azure Cosmos DB service.
            </summary>
            <param name="to">Second <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/>.</param>
            <returns>Returns distance in meters between two geometries.</returns>
            <remarks>
            Today this function support only geometries of <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Point"/> type.
            </remarks>
            <example>
            <code>
            <![CDATA[
            var distanceQuery = documents.Where(document => document.Location.Distance(new Point(20.1, 20)) < 20000);
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.Within(Microsoft.Azure.Cosmos.Spatial.Geometry)">
            <summary>
            Determines if current inner <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/> is fully contained inside <paramref name="outer" /> <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/> in the Azure Cosmos DB service.
            </summary>
            <param name="outer">Outer <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/>.</param>
            <returns>
            <c>true</c> if current inner <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/> is fully contained inside <paramref name="outer" /> <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/>.
            <c>false</c> otherwise.
            </returns>
            <remarks>
            Currently this function supports current geometry of type <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Point"/> and outer geometry of type <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Polygon"/>.
            </remarks>
            <example>
            <code>
            <![CDATA[
            Polygon polygon = new Polygon(
                   new[]
                   {
                        new Position(10, 10),
                        new Position(30, 10),
                        new Position(30, 30),
                        new Position(10, 30),
                        new Position(10, 10)
                   });
            var withinQuery = documents.Where(document => document.Location.Within(polygon));
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.IsValid">
            <summary>
            <para>
            Determines if the geometry specified is valid and can be indexed
            or used in queries by Azure Cosmos DB service.
            </para>
            <para>
            If a geometry is not valid, it will not be indexed. Also during query time invalid geometries are equivalent to <c>undefined</c>.
            </para>
            </summary>
            <returns><c>true</c> if geometry is valid. <c>false</c> otherwise.</returns>
            <remarks>
            Currently this function supports geometry of type <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Point"/> and <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Polygon"/>.
            </remarks>
            <example>
            <para>
            This example select all the documents which contain invalid geometries which were not indexed.
            </para>
            <code>
            <![CDATA[
            var invalidDocuments = documents.Where(document => !document.Location.IsValid());
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.IsValidDetailed">
            <summary>
            <para>
            Determines if the geometry specified is valid and can be indexed
            or used in queries by Azure Cosmos DB service
            and if invalid, gives the additional reason as a string value.
            </para>
            <para>
            If a geometry is not valid, it will not be indexed. Also during query time invalid geometries are equivalent to <c>undefined</c>.
            </para>
            </summary>
            <returns>Instance of <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryValidationResult"/>.</returns>
            <remarks>
            Currently this function supports geometry of type <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Point"/> and <see cref="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Polygon"/>.
            </remarks>
            <example>
            <para>
            This example select all the documents which contain invalid geometries which were not indexed.
            </para>
            <code>
            <![CDATA[
            var invalidReason = documents.Where(document => !document.Location.IsValid()).Select(document => document.Location.IsValidDetailed());
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.Intersects(Microsoft.Azure.Cosmos.Spatial.Geometry)">
            <summary>
            Checks if current geometry1 intersects with geometry2.
            </summary>
            <param name="geometry2">Second <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry"/>.</param>
            <returns>Returns true if geometry1 intersects with geometry2, otherwise returns false.</returns>
            <example>
            <code>
            <![CDATA[
            var distanceQuery = documents.Where(document => document.Location.Intersects(new Point(20.1, 20)));
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Geometry.Equals(Microsoft.Azure.Cosmos.Spatial.Geometry)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> is equal to the <paramref name="other" /> in the Azure Cosmos DB service.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" /> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Geometry" />.</param>
            <returns><c>true</c> if geometries are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection">
            <summary>
            Represents a geometry consisting of other geometries.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Geometry})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection"/> class. 
            </summary>
            <param name="geometries">
            List of geometries.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Geometry},Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection"/> class.
            </summary>
            <param name="geometries">
            Child geometries.
            </param>
            <param name="geometryParams">
            Additional geometry parameters.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection"/> class.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.Geometries">
            <summary>
            Gets child geometries.
            </summary>
            <value>
            Child geometries.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" />.
            </summary>
            <returns>
            true if the specified object is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" /> type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" />.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.GeometryCollection.Equals(Microsoft.Azure.Cosmos.Spatial.GeometryCollection)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" /> is equal to the <paramref name="other" />.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" /> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.GeometryCollection" />.</param>
            <returns><c>true</c> if geometry collections are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.GeometryParams">
            <summary>
            Not frequently used geometry parameters in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.GeometryParams.AdditionalProperties">
            <summary>
            Gets or sets any additional properties to be stored as part of a geometry in the Azure Cosmos DB service.
            </summary>
            <value>
            Additional geometry properties.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.GeometryParams.Crs">
            <summary>
            Gets or sets Coordinate Reference System for the geometry in the Azure Cosmos DB service.
            </summary>
            <value>
            Coordinate Reference System for the geometry.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.GeometryParams.BoundingBox">
            <summary>
            Gets or sets a bounding box for the geometry in the Azure Cosmos DB service.
            </summary>
            <value>
            Bounding box for the geometry.
            </value>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.GeometryShape">
            <summary>
            Geometry type in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.Point">
            <summary>
            Represents single point.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.MultiPoint">
            <summary>
            Represents geometry consisting of several points.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.LineString">
            <summary>
            Sequence of connected line segments.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.MultiLineString">
            <summary>
            Geometry consisting of several LineStrings.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.Polygon">
            <summary>
            Represents a polygon with optional holes.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.MultiPolygon">
            <summary>
            Represents a geometry comprised of several polygons.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryShape.GeometryCollection">
            <summary>
            Represents a geometry comprised of other geometries.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.GeometryType">
            <summary>
            Geometry type in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Point">
            <summary>
            Represents single point.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.MultiPoint">
            <summary>
            Represents geometry consisting of several points.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.LineString">
            <summary>
            Sequence of connected line segments.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.MultiLineString">
            <summary>
            Geometry consisting of several LineStrings.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.Polygon">
            <summary>
            Represents a polygon with optional holes.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.MultiPolygon">
            <summary>
            Represents a geometry comprised of several polygons.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Spatial.GeometryType.GeometryCollection">
            <summary>
            Represents a geometry comprised of other geometries.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.GeometryValidationResult">
            <summary>
            <para>
            Return value of <see cref="M:Microsoft.Azure.Cosmos.Spatial.Geometry.IsValidDetailed"/> in the Azure Cosmos DB service.
            </para>
            <para>
            Contains detailed description why a geometyr is invalid.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.GeometryValidationResult.IsValid">
            <summary>
            Returns a value indicating whether geometry for which <see cref="M:Microsoft.Azure.Cosmos.Spatial.Geometry.IsValidDetailed"/>
            was called is valid or not in the Azure Cosmos DB service.
            </summary>
            <value>
            <c>true</c> if geometry for which <see cref="M:Microsoft.Azure.Cosmos.Spatial.Geometry.IsValidDetailed"/> was called is valid. <c>false</c> otherwise.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.GeometryValidationResult.Reason">
            <summary>
            If geometry is invalid, returns detailed reason in the Azure Cosmos DB service.
            </summary>
            <value>
            Description why a geometry is invalid.
            </value>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.LinearRing">
            <summary>
            A <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing" /> is closed LineString with 4 or more positions. The first and last positions are
            equivalent (they represent equivalent points).
            Though a <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing" /> is not explicitly represented as a GeoJSON geometry type, it is referred to in
            the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> geometry type definition in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinearRing.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="coordinates">
            The coordinates. 4 or more positions. The first and last positions are equivalent (they represent equivalent
            points).
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.LinearRing.Positions">
            <summary>
            Gets the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/> positions in the Azure Cosmos DB service.
            </summary>
            <value>
            Positions of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/>.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinearRing.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinearRing.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/> positions in the Azure Cosmos DB service. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinearRing.Equals(Microsoft.Azure.Cosmos.Spatial.LinearRing)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/> is equal to the <paramref name="other" /> in the Azure Cosmos DB service.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.LinearRing"/> to compare to this one.</param>
            <returns><c>true</c> if linear rings are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.LineString">
            <summary>
            Represents a geometry consisting of connected line segments.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineString.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/> class. 
            </summary>
            <param name="coordinates">
            List of positions through which the line string goes.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineString.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position},Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/> class.
            </summary>
            <param name="coordinates">
            The coordinates.
            </param>
            <param name="geometryParams">
            Additional geometry parameters.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineString.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/> class.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.LineString.Positions">
            <summary>
            Gets line string positions.
            </summary>
            <value>
            Positions of the line string.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineString.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString" />.
            </summary>
            <returns>
            true if the specified object is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineString.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString" /> type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineString.Equals(Microsoft.Azure.Cosmos.Spatial.LineString)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/> is equal to the <paramref name="other" />.
            </summary>
            <param name="other">LineString to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/>.</param>
            <returns><c>true</c> if line strings are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates">
            <summary>
            Line string coordinates.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> class.
            </summary>
            <param name="positions">
            Line string positions..
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates.Positions">
            <summary>
            Gets line string positions.
            </summary>
            <value>
            Positions of the line string.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/>.
            </summary>
            <returns>
            true if the specified object is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates.GetHashCode">
            <summary>
            Serves as a hash function for <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/>.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates.Equals(Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> is equal to the <paramref name="other" />.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs">
            <summary>
            Coordinate Reference System which is identified by link in the Azure Cosmos DB service. 
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> class in the Azure Cosmos DB service. 
            </summary>
            <param name="href">
            Link which identifies the Coordinate Reference System.
            </param>
            <param name="hrefType">
            Optional string which hints at the format used to represent CRS parameters at the provided <paramref name="href"/>.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.Href">
            <summary>
            Gets the link which identifies the Coordinate Reference System in the Azure Cosmos DB service. 
            </summary>
            <value>
            Link which identifies the Coordinate Reference System.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.HrefType">
            <summary>
            Gets optional string which hints at the format used to represent CRS parameters at the provided <see cref="P:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.Href"/> in the Azure Cosmos DB service. 
            </summary>
            <value>
            Optional string which hints at the format used to represent CRS parameters at the provided <see cref="P:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.Href"/>.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> in the Azure Cosmos DB service. 
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.GetHashCode">
            <summary>
            Serves as a hash function for <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> in the Azure Cosmos DB service. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.LinkedCrs.Equals(Microsoft.Azure.Cosmos.Spatial.LinkedCrs)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> is equal to <paramref name="other" /> in the Azure Cosmos DB service. 
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/>.</param>
            <returns><c>true</c> if CRSs are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString">
            <summary>
            Represents a geometry consisting of multiple <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/>.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Spatial.LineString"/>.
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiLineString.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/> class. 
            </summary>
            <param name="lineStrings">
            List of <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> instances representing individual line strings.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiLineString.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates},Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/> class.
            </summary>
            <param name="lineStrings">
            List of <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> instances representing individual line strings.
            </param>
            <param name="geometryParams">
            Additional geometry parameters.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiLineString.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/> class.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.MultiLineString.LineStrings">
            <summary>
            Gets collection of <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> representing individual line strings.
            </summary>
            <value>
            Collection of <see cref="T:Microsoft.Azure.Cosmos.Spatial.LineStringCoordinates"/> representing individual line strings.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiLineString.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString" />.
            </summary>
            <returns>
            true if the specified object is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiLineString.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString" /> type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiLineString.Equals(Microsoft.Azure.Cosmos.Spatial.MultiLineString)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/> is equal to <paramref name="other" />.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiLineString"/>.</param>
            <returns><c>true</c> if line strings are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint">
            <summary>
            Geometry consisting of several points.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Spatial.Point"/>.
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPoint.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint" /> class.
            </summary>
            <param name="points">List of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> representing individual points.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPoint.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position},Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint" /> class.
            </summary>
            <param name="points">
            List of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> representing individual points.
            </param>
            <param name="geometryParams">
            Additional geometry parameters.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPoint.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint"/> class.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.MultiPoint.Points">
            <summary>
            Gets collections of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> representing individual points.
            </summary>
            <value>
            Collections of <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> representing individual points.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPoint.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint" />.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPoint.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint" /> type.
            </summary>
            <returns>
            A hash code for the current geometry.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPoint.Equals(Microsoft.Azure.Cosmos.Spatial.MultiPoint)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint"/> is equal to <paramref name="other" />.
            </summary>
            <param name="other"> <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPoint"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon">
            <summary>
            Geometry which is comprised of multiple polygons.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/> class.
            </summary>
            <param name="polygons">
            List of <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> instances. Each <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> represents separate polygon.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates},Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/> class.
            </summary>
            <param name="polygons">
            List of <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> instances. Each <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> represents separate polygon.
            </param>
            <param name="geometryParams">Additional geometry parameters.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/> class.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.Polygons">
            <summary>
            Gets collection of <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> instances. Each <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> represents separate polygon.
            </summary>
            <value>
            Collection of <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> instances. Each <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> represents separate polygon.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon" />.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon" /> type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon" />.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.MultiPolygon.Equals(Microsoft.Azure.Cosmos.Spatial.MultiPolygon)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/> is equal to <paramref name="other" />.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.NamedCrs">
            <summary>
            Coordinate Reference System which is identified by name in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.NamedCrs.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.NamedCrs" /> class in the Azure Cosmos DB service. 
            </summary>
            <param name="name">
            Name identifying a coordinate reference system.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.NamedCrs.Name">
            <summary>
            Gets a name identifying a coordinate reference system in the Azure Cosmos DB service. For example "urn:ogc:def:crs:OGC:1.3:CRS84".
            </summary>
            <value>
            Name identifying a coordinate reference system. For example "urn:ogc:def:crs:OGC:1.3:CRS84".
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.NamedCrs.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.NamedCrs" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.NamedCrs" /> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.NamedCrs.GetHashCode">
            <summary>
            Serves as a hash function for the name identifying a coordinate reference system in the Azure Cosmos DB service.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.NamedCrs" />.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.NamedCrs.Equals(Microsoft.Azure.Cosmos.Spatial.NamedCrs)">
            <summary>
            Determines if this CRS is equal to <paramref name="other" /> CRS in the Azure Cosmos DB service.
            </summary>
            <param name="other">CRS to compare to this CRS.</param>
            <returns><c>true</c> if CRSs are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Point">
            <summary>
            Point geometry class in the Azure Cosmos DB service.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="longitude">
            Longitude of the point.
            </param>
            <param name="latitude">
            Latitude of the point.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.#ctor(Microsoft.Azure.Cosmos.Spatial.Position)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="position">
            Position of the point.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.#ctor(Microsoft.Azure.Cosmos.Spatial.Position,Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point" /> class in the Azure Cosmos DB service.
            </summary>
            <param name="position">
            Point coordinates.
            </param>
            <param name="geometryParams">
            Additional geometry parameters.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point"/> class in the Azure Cosmos DB service.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Point.Position">
            <summary>
            Gets point coordinates in the Azure Cosmos DB service.
            </summary>
            <value>
            Coordinates of the point.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.Equals(Microsoft.Azure.Cosmos.Spatial.Point)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point"/> is equal to <paramref name="other" /> in the Azure Cosmos DB service.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.Point"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point" /> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Point.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Point" /> type in the Azure Cosmos DB service.
            </summary>
            <returns>
            A hash code for the current geometry.
            </returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Polygon">
            <summary>
            <para>
            Polygon geometry class in the Azure Cosmos DB service.
            </para>
            <para>
            A polygon is represented by the set of "polygon rings". Each ring is closed line string.
            First ring defines external ring. All subsequent rings define "holes" in the external ring.
            </para>
            <para>
            Rings must be specified using Left Hand Rule: traversing the ring in the order of its points, should result
            in internal area of the polygon being to the left side.
            </para>
            </summary>
            <example>
            This example shows how to define a polygon which covers small portion of the Earth:
            <code language="c#">
            <![CDATA[
            var polygon = new Polygon(
                    new[]
                    {
                        new Position(20.0, 20.0),
                        new Position(30.0, 20.0),
                        new Position(30.0, 30.0),
                        new Position(20.0, 30.0)
                        new Position(20.0, 20.0)
                    });
            ]]>        
            </code>
            </example>
            <example>
            This example shows how to define a polygon which covers area more than one hemisphere:
            (Notice that only order of coordinates was reversed).
            <code language="c#">
            <![CDATA[
            var polygon = new Polygon(
                    new[]
                    {
                        new Position(20.0, 20.0),
                        new Position(20.0, 30.0),
                        new Position(30.0, 30.0),
                        new Position(30.0, 20.0)
                        new Position(20.0, 20.0)
                    });
            ]]>        
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.Position})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> class,
            from external ring (the polygon contains no holes) in the Azure Cosmos DB service.
            </summary>
            <param name="externalRingPositions">
            External polygon ring coordinates.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.LinearRing})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> class in the Azure Cosmos DB service.
            </summary>
            <param name="rings">
            <para>
            Polygon rings.
            </para>
            <para>
            First ring is external ring. Following rings define 'holes' in the polygon.
            </para>
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.LinearRing},Microsoft.Azure.Cosmos.Spatial.GeometryParams)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> class in the Azure Cosmos DB service.
            </summary>
            <param name="rings">
            Polygon rings.
            </param>
            <param name="geometryParams">
            Additional geometry parameters.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> class in the Azure Cosmos DB service.
            </summary>
            <remarks>
            This constructor is used only during deserialization.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Polygon.Rings">
            <summary>
            Gets the polygon rings in the Azure Cosmos DB service.
            </summary>
            <value>
            Polygon rings.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon" /> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon" /> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified object is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon" /> type in the Azure Cosmos DB service.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Polygon.Equals(Microsoft.Azure.Cosmos.Spatial.Polygon)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> is equal to the <paramref name="other" /> in the Azure Cosmos DB service.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Polygon"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates">
            <summary>
            Polygon coordinates.
            </summary>
            <seealso cref="T:Microsoft.Azure.Cosmos.Spatial.MultiPolygon"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates.#ctor(System.Collections.Generic.IList{Microsoft.Azure.Cosmos.Spatial.LinearRing})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> class.
            </summary>
            <param name="rings">
            The rings of the polygon.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates.Rings">
            <summary>
            Gets polygon rings.
            </summary>
            <value>
            Rings of the polygon.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/>. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates.Equals(Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> is equal to the <paramref name="other" />.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.PolygonCoordinates"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.Position">
            <summary>
            <para>
            A position is represented by an array of numbers in the Azure Cosmos DB service. There must be at least two elements, and may be more.
            </para>
            <para>
            The order of elements must follow longitude, latitude, altitude.
            Any number of additional elements are allowed - interpretation and meaning of additional elements is up to the application.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Position.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> class in the Azure Cosmos DB service.
            </summary>
            <param name="longitude">
            Longitude value.
            </param>
            <param name="latitude">
            Latitude value.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Position.#ctor(System.Double,System.Double,System.Nullable{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> class in the Azure Cosmos DB service.
            </summary>
            <param name="longitude">
            Longitude value.
            </param>
            <param name="latitude">
            Latitude value.
            </param>
            <param name="altitude">
            Optional altitude value.
            </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Position.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> class in the Azure Cosmos DB service.
            </summary>
            <param name="coordinates">
            Position values.
            </param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Position.Coordinates">
            <summary>
            Gets position coordinates in the Azure Cosmos DB service.
            </summary>
            <value>
            Coordinate values.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Position.Longitude">
            <summary>
            Gets longitude in the Azure Cosmos DB service.
            </summary>
            <value>
            Longitude value.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Position.Latitude">
            <summary>
            Gets latitude in the Azure Cosmos DB service.
            </summary>
            <value>
            Latitude value.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Spatial.Position.Altitude">
            <summary>
            Gets optional altitude in the Azure Cosmos DB service.
            </summary>
            <value>
            Altitude value.
            </value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Position.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> in the Azure Cosmos DB service.
            </summary>
            <returns>
            true if the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> to compare to the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Position.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position" /> type in the Azure Cosmos DB service.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.Position.Equals(Microsoft.Azure.Cosmos.Spatial.Position)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> is equal to the <paramref name="other" /> in the Azure Cosmos DB service.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.Position"/>.</param>
            <returns><c>true</c> if objects are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs">
            <summary>
            Unspecified CRS. If a geometry has this CRS, no CRS can be assumed for it according to GeoJSON spec.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> is equal to the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs.GetHashCode">
            <summary>
            Serves as a hash function for <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/>. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/>.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs.Equals(Microsoft.Azure.Cosmos.Spatial.UnspecifiedCrs)">
            <summary>
            Determines if this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> is equal to <paramref name="other" />.
            </summary>
            <param name="other"><see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/> to compare to this <see cref="T:Microsoft.Azure.Cosmos.Spatial.LinkedCrs"/>.</param>
            <returns><c>true</c> if CRSs are equal. <c>false</c> otherwise.</returns>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Add">
            <summary>
            Arithmetic addition.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.And">
            <summary>
            Logical AND.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.BitwiseAnd">
            <summary>
            Bitwise AND.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.BitwiseOr">
            <summary>
            Bitwise OR.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.BitwiseXor">
            <summary>
            Bitwise XOR.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Coalesce">
            <summary>
            Coalesce.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Divide">
            <summary>
            Division.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Equal">
            <summary>
            Equality.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.GreaterThan">
            <summary>
            Greater Than.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.GreaterThanOrEqual">
            <summary>
            Greater Than or Equal To.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.LessThan">
            <summary>
            Less Than.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.LessThanOrEqual">
            <summary>
            Less Than or Equal To.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Modulo">
            <summary>
            Modulo.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Multiply">
            <summary>
            Multiply.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.NotEqual">
            <summary>
            Not Equals.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Or">
            <summary>
            Logical Or.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.StringConcat">
            <summary>
            String Concat.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlBinaryScalarOperatorKind.Subtract">
            <summary>
            Subtract.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlUnaryScalarOperatorKind.BitwiseNot">
            <summary>
            Bitwise Not.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlUnaryScalarOperatorKind.Not">
            <summary>
            Not.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlUnaryScalarOperatorKind.Minus">
            <summary>
            Minus.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.SqlObjects.SqlUnaryScalarOperatorKind.Plus">
            <summary>
            Plus.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.SqlObjects.Visitors.SqlObjectHasher.CombineHashes(System.Int64,System.Int64)">
            <summary>
            Combines Two Hashes in an antisymmetric way (stolen from boost).
            </summary>
            <param name="lhs">The first hash</param>
            <param name="rhs">The second hash</param>
            <returns>The combined hash.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.StoredProcedureResponse`1">
            <summary>
            Represents the response returned from a database stored procedure in the Azure Cosmos DB service. Wraps the response body and headers.
            </summary> 
            <typeparam name="TValue">The returned value type of the stored procedure.</typeparam>
            <remarks>
            Stored procedures can return any string output via the getContext().getResponse().setBody() method.
            This response body could be a serialized JSON object, or any other type.
            Within the .NET SDK, you can deserialize the response into a corresponding TValue type.
            </remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.#ctor">
            <summary>
            Constructor exposed for mocking purposes in Azure Cosmos DB service.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.ActivityId">
            <summary>
            Gets the Activity ID of the request from the Azure Cosmos DB service.
            </summary>
            <value>
            The Activity ID of the request.
            </value>
            <remarks>Every request is traced with a globally unique ID. Include activity ID in tracing application failures and when contacting Azure Cosmos DB support</remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.SessionToken">
            <summary>
            Gets the token for use with session consistency requests from the Azure Cosmos DB service.
            </summary>
            <value>
            The token for use with session consistency requests.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.ScriptLog">
            <summary>
            Gets the output from stored procedure console.log() statements.
            </summary>
            <value>
            Output from console.log() statements in a stored procedure.
            </value>
            <seealso cref="P:Microsoft.Azure.Cosmos.Scripts.StoredProcedureRequestOptions.EnableScriptLogging"/>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.StatusCode">
            <summary>
            Gets the request completion status code from the Azure Cosmos DB service.
            </summary>
            <value>The request completion status code</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.MaxResourceQuota">
            <summary>
            Gets the delimited string containing the quota of each resource type within the collection from the Azure Cosmos DB service.
            </summary>
            <value>The delimited string containing the number of used units per resource type within the collection.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.CurrentResourceQuotaUsage">
            <summary>
            Gets the delimited string containing the usage of each resource type within the collection from the Azure Cosmos DB service.
            </summary>
            <value>The delimited string containing the number of used units per resource type within the collection.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.RequestCharge">
            <summary>
            Gets the number of normalized Azure Cosmos DB request units (RUs) charged from Azure Cosmos DB service.
            </summary>
            <value>
            The number of normalized Azure Cosmos DB request units (RUs) charged.
            </value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.ResponseHeaders">
            <summary>
            Gets the headers associated with the response from the Azure Cosmos DB service.
            </summary>
            <value>
            Headers associated with the response.
            </value>
            <remarks>
            Provides access to all HTTP response headers returned from the 
            Azure Cosmos DB API.
            </remarks>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.Response">
            <summary>
            Gets the response of a stored procedure, serialized into the given type from the Azure Cosmos DB service.
            </summary>
            <value>The response of a stored procedure, serialized into the given type.</value>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.RequestStatistics">
            <summary>
            Gets the clientside request statics for execution of stored procedure.
            </summary>
            <value>The clientside request statics for execution of stored procedure.</value>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.StoredProcedureResponse`1.op_Implicit(Microsoft.Azure.Cosmos.StoredProcedureResponse{`0})~`0">
            <summary>
            Gets the resource implicitly from Azure Cosmos DB service.
            </summary>
            <param name="source">Stored procedure response.</param>
            <returns>The returned resource.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TaskHelper">
            <summary>
            The helper function relates to the async Task.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry">
            <summary>
            This class collects and send all the telemetry information.
            Multiplying Request Charge and CPU Usages with 1000 at the time of collection to preserve precision of upto 3 decimals. 
            Dividing these same values with 1000 during Serialization.
            This Class get initiated with the client and get disposed with client.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.CreateAndStartBackgroundTelemetry(Microsoft.Azure.Cosmos.DocumentClient,System.String,Microsoft.Azure.Cosmos.ConnectionMode,Microsoft.Azure.Cosmos.AuthorizationTokenProvider,Microsoft.Azure.Cosmos.Handler.DiagnosticsHandlerHelper,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Factory method to intiakize telemetry object and start observer task
            </summary>
            <param name="documentClient"></param>
            <param name="userAgent"></param>
            <param name="connectionMode"></param>
            <param name="authorizationTokenProvider"></param>
            <param name="diagnosticsHelper"></param>
            <param name="preferredRegions"></param>
            <returns>ClientTelemetry</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.StartObserverTask">
            <summary>
             Start telemetry Process which Calculate and Send telemetry Information (never ending task)
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.EnrichAndSendAsync">
            <summary>
            Task which does below operations , periodically
             1. Set Account information (one time at the time of initialization)
             2. Load VM metedata information (one time at the time of initialization)
             3. Calculate and Send telemetry Information to juno service (never ending task)/// </summary>
            <returns>Async Task</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.Collect(Microsoft.Azure.Cosmos.CosmosDiagnostics,System.Net.HttpStatusCode,System.Int64,System.String,System.String,Microsoft.Azure.Documents.OperationType,Microsoft.Azure.Documents.ResourceType,System.String,System.Double,System.String)">
            <summary>
            Collects Telemetry Information.
            </summary>
            <param name="cosmosDiagnostics"></param>
            <param name="statusCode"></param>
            <param name="responseSizeInBytes"></param>
            <param name="containerId"></param>
            <param name="databaseId"></param>
            <param name="operationType"></param>
            <param name="resourceType"></param>
            <param name="consistencyLevel"></param>
            <param name="requestCharge"></param>
            <param name="subStatusCode"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.RecordSystemUtilization">
            <summary>
            Record CPU and memory usage which will be sent as part of telemetry information
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.SendAsync">
            <summary>
            Task to send telemetry information to configured Juno endpoint. 
            If endpoint is not configured then it won't even try to send information. It will just trace an error message.
            In any case it resets the telemetry information to collect the latest one.
            </summary>
            <returns>Async Task</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.Reset">
            <summary>
            Reset all the operation, System Utilization and Cache refresh related collections
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetry.Dispose">
            <summary>
            Dispose of cosmos client.It will get disposed with client so not making it thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryHelper.SetAccountNameAsync(Microsoft.Azure.Cosmos.DocumentClient)">
            <summary>
            Task to get Account Properties from cache if available otherwise make a network call.
            </summary>
            <returns>Async Task</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryHelper.LoadAzureVmMetaDataAsync(Microsoft.Azure.Cosmos.CosmosHttpClient)">
            <summary>
            Task to collect virtual machine metadata information. using instance metedata service API.
            ref: https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=windows
            Collects only application region and environment information
            </summary>
            <returns>Async Task</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryHelper.RecordSystemUsage(Microsoft.Azure.Documents.Rntbd.SystemUsageHistory,System.Collections.Generic.List{Microsoft.Azure.Cosmos.Telemetry.SystemInfo})">
            <summary>
            Record System Usage and update passed system Info collection. Right now, it collects following metrics
            1) CPU Usage
            2) Memory Remaining
            3) Available Threads
            
            </summary>
            <param name="systemUsageHistory"></param>
            <param name="systemInfoCollection"></param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryHelper.ToListWithMetricsInfo(System.Collections.Generic.IDictionary{Microsoft.Azure.Cosmos.Telemetry.OperationInfo,System.ValueTuple{HdrHistogram.LongConcurrentHistogram,HdrHistogram.LongConcurrentHistogram}})">
            <summary>
            Convert map with operation information to list of operations along with request latency and request charge metrics
            </summary>
            <param name="metrics"></param>
            <returns>Collection of ReportPayload</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryHelper.GetContactedRegions(Microsoft.Azure.Cosmos.CosmosDiagnostics)">
            <summary>
            Get comma separated list of regions contacted from the diagnostic
            </summary>
            <param name="cosmosDiagnostics"></param>
            <returns>Comma separated region list</returns>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryProperties.PreferredRegions">
            <summary>
            Preferred Region set by the client
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.ClientTelemetryProperties.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Nullable{System.Boolean},System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.List{Microsoft.Azure.Cosmos.Telemetry.SystemInfo},System.Collections.Generic.List{Microsoft.Azure.Cosmos.Telemetry.OperationInfo},System.Collections.Generic.List{Microsoft.Azure.Cosmos.Telemetry.OperationInfo})">
            <summary>
            Needed by Serializer to deserialize the json
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.MetricInfo.SetAggregators(HdrHistogram.LongConcurrentHistogram,System.Double)">
            <summary>
            It will set the current object with the aggregated values from the given histogram
            </summary>
            <param name="histogram"></param>
            <param name="adjustment"></param>
            <returns>MetricInfo</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Telemetry.TelemetrySystemUsage">
            <summary>
            This Class responsibility is to process System Usage information and convert them into a Client Telemetry Property, SystemInfo with more information
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.TelemetrySystemUsage.GetCpuInfo(System.Collections.Generic.IReadOnlyCollection{Microsoft.Azure.Documents.Rntbd.SystemUsageLoad})">
            <summary>
            Collecting CPU usage information and aggregating that data using Histogram
            </summary>
            <param name="systemUsageCollection"></param>
            <returns>SystemInfo</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.TelemetrySystemUsage.GetMemoryRemainingInfo(System.Collections.Generic.IReadOnlyCollection{Microsoft.Azure.Documents.Rntbd.SystemUsageLoad})">
            <summary>
            Collecting Memory Remaining information and aggregating that data using Histogram
            </summary>
            <param name="systemUsageCollection"></param>
            <returns>SystemInfo</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.TelemetrySystemUsage.GetAvailableThreadsInfo(System.Collections.Generic.IReadOnlyCollection{Microsoft.Azure.Documents.Rntbd.SystemUsageLoad})">
            <summary>
            Collecting Available Thread information and aggregating that data using Histogram
            </summary>
            <param name="systemUsageCollection"></param>
            <returns>SystemInfo</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.TelemetrySystemUsage.GetThreadStarvationSignalCount(System.Collections.Generic.IReadOnlyCollection{Microsoft.Azure.Documents.Rntbd.SystemUsageLoad})">
            <summary>
            Collecting Thread Starvation Flags Count
            </summary>
            <param name="systemUsageCollection"></param>
            <returns>SystemInfo</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Telemetry.TelemetrySystemUsage.GetThreadWaitIntervalInMs(System.Collections.Generic.IReadOnlyCollection{Microsoft.Azure.Documents.Rntbd.SystemUsageLoad})">
            <summary>
            Collecting Thread Wait Interval in Millisecond and aggregating using Histogram
            </summary>
            <param name="systemUsageCollection"></param>
            <returns>SystemInfo</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.TimerWheel">
            <summary>
            TimerWheel is a Simple TimerWheel implementation that uses a single System.Threading.Timer to maintain a wheel.
            Creation of the wheel requires the resolution of each wheel's bucket and the amount of buckets, which define which its MaxInterval.
            Timed-based tasks can use <see cref="M:Microsoft.Azure.Cosmos.TimerWheel.CreateTimer(System.TimeSpan)"/> to obtain a new timer.
            Starting the timer through <see cref="M:Microsoft.Azure.Cosmos.TimerWheelTimer.StartTimerAsync"/> returns a Task that can be awaited and will complete on time expiration.
            </summary>
            <example>
            <code language="c#">
            <![CDATA[
            TimerWheel wheel = TimerWheel.CreateTimerWheel(resolution: TimeSpan.FromMilliseconds(50), buckets: 20);
            TimerWheelTimer timer = wheel.CreateTimer(TimeSpan.FromMilliseconds(100));
            await timer.StartTimerAsync();
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TimerWheel.CreateTimer(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:Microsoft.Azure.Cosmos.TimerWheelTimer"/> that can be used and started.
            </summary>
            <param name="timeout">The timeout</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TimerWheel.CreateTimerWheel(System.TimeSpan,System.Int32)">
            <summary>
            Creates a new <see cref="T:Microsoft.Azure.Cosmos.TimerWheel"/> which is a simple timer wheel implementation
            </summary>
            <remarks>
            The <paramref name="resolution"/> defines the minimum supported timeout and <paramref name="buckets"/> times <paramref name="resolution"/> define the maximum supported timeout.
            </remarks>
            <param name="resolution">Amount of time for each wheel step.</param>
            <param name="buckets">Amount of slices in the wheel</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Timers.TimerWheelCore.#ctor(System.TimeSpan,System.Int32,System.Threading.Timer)">
            <summary>
            Used only for unit tests.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.TimerWheelTimer.Timeout">
            <summary>
            Timeout of the timer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TimerWheelTimer.StartTimerAsync">
            <summary>
            Starts the timer based on the Timeout configuration.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TimerWheelTimer.CancelTimer">
            <summary>
            Cancels the timer.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.TimerWheelTimer.FireTimeout">
            <summary>
            Fire the associated timeout callback.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.CallerInfo">
            <summary>
            The metadata for who created called the method and the source file path.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.CallerInfo.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Initializes a new instance of the CallerInfo class.
            </summary>
            <param name="memberName">The name of the file that called the method.</param>
            <param name="filePath">The path to the file in source that called the method.</param>
            <param name="lineNumber">The line number of the file that called the method.</param>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.CallerInfo.MemberName">
            <summary>
            Gets the name of the file that called the method.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.CallerInfo.FilePath">
            <summary>
            Gets the path to the file in source that called the method.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.CallerInfo.LineNumber">
            <summary>
            Gets the line number of the file that called the method.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.ITrace">
            <summary>
            Interface to represent a single node in a trace tree.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Name">
            <summary>
            Gets the name of the node.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Id">
            <summary>
            Gets the ID of the node.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.StartTime">
            <summary>
            Gets the time when the trace was started.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Duration">
            <summary>
            Gets the duration of the trace.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Level">
            <summary>
            Gets the level (of information) of the trace.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Component">
            <summary>
            Gets the component that governs this trace.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Parent">
            <summary>
            Gets the parent node of this trace.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Children">
            <summary>
            Gets the children of this trace.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Data">
            <summary>
            Gets additional datum associated with this trace.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.ITrace.RegionsContacted">
            <summary>
            Consolidated Region contacted Information of this and children nodes
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.StartChild(System.String)">
            <summary>
            Starts a Trace and adds it as a child to this instance.
            </summary>
            <param name="name">The name of the child.</param>
            <returns>A reference to the initialized child (that needs to be disposed to stop the timing).</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.StartChild(System.String,Microsoft.Azure.Cosmos.Tracing.TraceComponent,Microsoft.Azure.Cosmos.Tracing.TraceLevel)">
            <summary>
            Starts a trace and adds it as a child to this instance.
            </summary>
            <param name="name">The name of the child.</param>
            <param name="component">The component that governs the child.</param>
            <param name="level">The level (of information) of the child.</param>
            <returns>A reference to the initialized child (that needs to be disposed to stop the timing).</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.AddDatum(System.String,Microsoft.Azure.Cosmos.Tracing.TraceDatum)">
            <summary>
            Adds a datum to the this trace instance.
            </summary>
            <param name="key">The key to associate the datum.</param>
            <param name="traceDatum">The datum itself.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.AddDatum(System.String,System.Object)">
            <summary>
            Adds a datum to the this trace instance.
            </summary>
            <param name="key">The key to associate the datum.</param>
            <param name="value">The datum itself.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.AddOrUpdateDatum(System.String,System.Object)">
            <summary>
            Updates the given datum in this trace instance if exists, otherwise Add
            </summary>
            <param name="key">The key to associate the datum.</param>
            <param name="value">The datum itself.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.AddChild(Microsoft.Azure.Cosmos.Tracing.ITrace)">
            <summary>
            Adds a trace children that is already completed.
            </summary>
            <param name="trace">Existing trace.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.ITrace.UpdateRegionContacted(Microsoft.Azure.Cosmos.Tracing.TraceDatum)">
            <summary>
            Update region contacted information to the parent Itrace
            </summary>
            <param name="traceDatum"></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.ITraceDatumVisitor">
            <summary>
            Visitor for <see cref="T:Microsoft.Azure.Cosmos.Tracing.TraceDatum"/>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.Trace.UpdateRegionContacted(Microsoft.Azure.Cosmos.Tracing.TraceDatum)">
            <summary>
            Update region contacted information to this node
            </summary>
            <param name="traceDatum"></param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.TraceComponent">
            <summary>
            The component that governs an <see cref="T:Microsoft.Azure.Cosmos.Tracing.ITrace"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Unknown">
            <summary>
            Component is yet to be categorized.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Authorization">
            <summary>
            Component that handles authorizing requests and managing auth tokens / credentials.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Batch">
            <summary>
            Component that handles batch requests.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.ChangeFeed">
            <summary>
            Component that handles aggregating ChangeFeed results across multiple pages and partitions.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Json">
            <summary>
            Component that handles JSON reading, writing, navigating, serialization, and deserialization.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Pagination">
            <summary>
            Component that handles paging results within and across partitions from the service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Poco">
            <summary>
            Component that handles materializing a POCO.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Query">
            <summary>
            Component that handles client side aggregation of distributed query results.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.ReadFeed">
            <summary>
            Component that handles aggregating ReadFeed results across multiple pages and partitons.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.RequestHandler">
            <summary>
            Request Handler pipeline.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Routing">
            <summary>
            Component that handles routing requests to physical partitons and maintaining physical partition topology.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceComponent.Transport">
            <summary>
            Component that handles sending requests over the wire (along with selecting the correct replica set for consistency).
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.TraceDatum">
            <summary>
            The interface for a single entry in the <see cref="P:Microsoft.Azure.Cosmos.Tracing.ITrace.Data"/> dictionary.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.TraceDatum.Accept(Microsoft.Azure.Cosmos.Tracing.ITraceDatumVisitor)">
            <summary>
            Accept the visitor.
            </summary>
            <param name="traceDatumVisitor">The visitor to accept.</param>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.TraceLevel">
            <summary>
            The level (of information) for an <see cref="T:Microsoft.Azure.Cosmos.Tracing.ITrace"/>.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceLevel.Off">
            <summary>
            Output no tracing and debugging messages.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceLevel.Error">
            <summary>
            Output error-handling messages.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceLevel.Warning">
            <summary>
            Output warnings and error-handling messages.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceLevel.Info">
            <summary>
            Output informational messages, warnings, and error-handling messages.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.Tracing.TraceLevel.Verbose">
            <summary>
            Output all debugging and tracing messages.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceDatumJsonWriter.WriteJsonUriArrayWithDuplicatesCounted(System.String,System.Collections.Generic.IReadOnlyList{Microsoft.Azure.Documents.TransportAddressUri})">
            <summary>
            Writes the list of URIs to JSON.
            Sequential duplicates are counted and written as a single object to prevent
            writing the same URI multiple times.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters">
            <summary>
            Character set to generate an Ascii Tree (https://marketplace.visualstudio.com/items?itemName=aprilandjan.ascii-tree-generator)
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters.Blank">
            <summary>
            For blanks / spaces
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters.Child">
            <summary>
            For intermediate child elements
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters.Dash">
            <summary>
            For horizontal dashes
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters.Last">
            <summary>
            For the last element of a path
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters.Parent">
            <summary>
            For vertical parent elements
            </summary>
        </member>
        <member name="P:Microsoft.Azure.Cosmos.Tracing.TraceWriter.TraceTextWriter.AsciiTreeCharacters.Root">
            <summary>
            For the root element (on top)
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UInt128">
            <summary>
            Struct that represents a 128 bit unsigned integer.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.UInt128.Length">
            <summary>
            The length of this struct in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.UInt128.MaxValue">
            <summary>
            Maximum UInt128.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.UInt128.MinValue">
            <summary>
            Maximum UInt128.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.UInt128.low">
            <summary>
            The lowest 64 bits of the UInt128.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.Cosmos.UInt128.high">
            <summary>
            The highest 64 bits of the UInt128.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.Cosmos.UInt128"/> struct.
            </summary>
            <param name="low">The lowest 64 bits of the UInt128.</param>
            <param name="high">The highest 64 bits of the UInt128.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Implicit(System.Int32)~Microsoft.Azure.Cosmos.UInt128">
            <summary>
            Implicitly converts an int to UInt128.
            </summary>
            <param name="value">The int to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Implicit(System.Int64)~Microsoft.Azure.Cosmos.UInt128">
            <summary>
            Implicitly converts a long to UInt128.
            </summary>
            <param name="value">The int to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Implicit(System.UInt32)~Microsoft.Azure.Cosmos.UInt128">
            <summary>
            Implicitly converts an unsigned int to UInt128.
            </summary>
            <param name="value">The unsigned int to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Implicit(System.UInt64)~Microsoft.Azure.Cosmos.UInt128">
            <summary>
            Implicitly converts an unsigned long to UInt128.
            </summary>
            <param name="value">The unsigned long to convert.</param>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Addition(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Adds two instances of UInt128 together.
            </summary>
            <param name="augend">The augend.</param>
            <param name="addend">The addend.</param>
            <returns>The augend + addend.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Subtraction(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Takes the difference between two UInt128.
            </summary>
            <param name="minuend">The minuend.</param>
            <param name="subtrahend">The subtrahend.</param>
            <returns>minuend - subtrahend.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Multiply(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Multiplies two UInt128s together.
            </summary>
            <param name="multiplicand">The multiplicand.</param>
            <param name="multiplier">The multiplier</param>
            <returns>The multiplication of the two UInt128s.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Division(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Divides one UInt128 by another UInt128
            </summary>
            <param name="dividend">The dividend.</param>
            <param name="divisor">The divisor</param>
            <returns>The multiplication of the two UInt128s.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_LessThan(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns if one UInt128 is less than another UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is less than right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_GreaterThan(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns if one UInt128 is greater than another UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is greater than right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_LessThanOrEqual(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns if one UInt128 is less than or equal to another UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is less than or equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_GreaterThanOrEqual(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns if one UInt128 is greater than or equal to another UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether left is greater than or equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Equality(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns if two UInt128 are equal.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether the left is equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_Inequality(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns if two UInt128 are not equal.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>Whether the left is not equal to the right.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_BitwiseAnd(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Takes the bitwise and of two instance of UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>The bitwise and of two instance of UInt128..</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_BitwiseOr(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Takes the bitwise or of two instance of UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>The bitwise or of two instance of UInt128..</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.op_ExclusiveOr(Microsoft.Azure.Cosmos.UInt128,Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Takes the bitwise x or of two instance of UInt128.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>The bitwise x or of two instance of UInt128..</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.Create(System.UInt64,System.UInt64)">
            <summary>
            Creates a UInt128 from two ulong.
            </summary>
            <param name="low">The lower 64 bits of the UInt128.</param>
            <param name="high">The upper 64 bits of the UInt128.</param>
            <returns>A UInt128 from the two ulong.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.ToByteArray(Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Converts the UInt128 to a byte array.
            </summary>
            <param name="uint128">The UInt128 to convert.</param>
            <returns>The byte array representation of this UInt128.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.CompareTo(System.Object)">
            <summary>
            Compares this value to an object.
            </summary>
            <param name="value">The value to compare to.</param>
            <returns>The comparison.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.CompareTo(Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Compares this UInt128 to another instance of the UInt128 type.
            </summary>
            <param name="other">The other instance to compare to.</param>
            <returns>
            A negative number if this instance is less than the other instance.
            Zero if they are the same.
            A positive number if this instance is greater than the other instance.
            </returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.Equals(System.Object)">
            <summary>
            Returns whether this instance equals another object.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>Whether this instance equals another object.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.Equals(Microsoft.Azure.Cosmos.UInt128)">
            <summary>
            Returns whether this UInt128 equals another UInt128.
            </summary>
            <param name="other">The UInt128 to compare to.</param>
            <returns>Whether this UInt128 equals another UInt128.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.GetHashCode">
            <summary>
            Gets a hash code for this instance.
            </summary>
            <returns>The hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.ToString">
            <summary>
            Gets the string representation of a UInt128 as a hex dump.
            </summary>
            <returns>The string representation of a UInt128 as a hex dump.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.GetHigh">
            <summary>
            Returns the high 64 bits of the UInt128.cs.
            </summary>
            <returns>The high 64 bits of the UInt128.cs.</returns>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UInt128.GetLow">
            <summary>
            Returns the low 64 bits of the UInt128.cs.
            </summary>
            <returns>The low 64 bits of the UInt128.cs.</returns>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UInt128BinaryComparer">
            <summary>
            Compare UInt128's by least significant byte to most significant byte.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UriFactory">
            <summary>
            Helper class to assist in creating the various Uris needed for use with the DocumentClient instance in the Azure Cosmos DB service.
            </summary>
            <example>
            The example below uses UriFactory to create a DocumentCollectionLink and then uses that to create a Document.
            <code language="c#">
            <![CDATA[ 
            Uri collUri = UriFactory.CreateDocumentCollectionUri("MyDb", "MyCollection");
            var doc = await client.CreateDocumentAsync(collUri, new {id = "MyDoc"});
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateDatabaseUri(System.String)">
            <summary>
            Given a database id, this creates a database link.
            </summary>
            <param name="databaseId">The database id</param>
            <returns>
            A database link in the format of /dbs/{0}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>
            </returns>
            <remarks>Would be used when creating or deleting a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/> or a <see cref="T:Microsoft.Azure.Cosmos.User"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateCollectionUri(System.String,System.String)">
            <summary>
            Given a database and collection id, this creates a collection link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <returns>
            A collection link in the format of /dbs/{0}/colls/{1}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/> and {1} being <paramref name="collectionId"/>
            </returns>
            <remarks>Would be used when updating or deleting a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/>, creating a <see cref="T:Microsoft.Azure.Documents.Document"/>, a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/>, a <see cref="T:Microsoft.Azure.Documents.Trigger"/>, a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>, or when executing a query with CreateDocumentQuery in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateDocumentCollectionUri(System.String,System.String)">
            <summary>
            Given a database and collection id, this creates a collection link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <returns>
            A collection link in the format of /dbs/{0}/colls/{1}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/> and {1} being <paramref name="collectionId"/>
            </returns>
            <remarks>Would be used when updating or deleting a <see cref="T:Microsoft.Azure.Documents.DocumentCollection"/>, creating a <see cref="T:Microsoft.Azure.Documents.Document"/>, a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/>, a <see cref="T:Microsoft.Azure.Documents.Trigger"/>, a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/>, or when executing a query with CreateDocumentQuery in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateClientEncryptionKeyUri(System.String,System.String)">
            <summary>
            Given a database and client encryption key id, this creates a client encryption key link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="clientEncryptionKeyId">The client encryption key id</param>
            <returns>
            A client encryption key link in the format of /dbs/{0}/clientEncryptionkeys/{1}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/> and {1} being <paramref name="clientEncryptionKeyId"/>
            </returns>
            <remarks>
            Would be used when updating or deleting a <see cref="T:Microsoft.Azure.Cosmos.ClientEncryptionKey"/>
            </remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateUserUri(System.String,System.String)">
            <summary>
            Given a database and user id, this creates a user link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="userId">The user id</param>
            <returns>
            A user link in the format of /dbs/{0}/users/{1}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/> and {1} being <paramref name="userId"/>
            </returns>
            <remarks>Would be used when creating a <see cref="T:Microsoft.Azure.Cosmos.Permission"/>, or when replacing or deleting a <see cref="T:Microsoft.Azure.Cosmos.User"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateUserDefinedTypeUri(System.String,System.String)">
            <summary>
            Given a database and user defined type id, this creates a user defined type link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="userDefinedTypeId">The user defined type id</param>
            <returns>
            A user defined type link in the format of /dbs/{0}/udts/{1}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/> and {1} being <paramref name="userDefinedTypeId"/>
            </returns>
            <remarks>Would be used when creating a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/>, or when replacing or deleting a <see cref="T:Microsoft.Azure.Documents.UserDefinedType"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateDocumentUri(System.String,System.String,System.String)">
            <summary>
            Given a database, collection and document id, this creates a document link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="documentId">The document id</param>
            <returns>
            A document link in the format of /dbs/{0}/colls/{1}/docs/{2}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/> and {2} being the <paramref name="documentId"/>
            </returns>
            <remarks>Would be used when creating an <see cref="T:Microsoft.Azure.Documents.Attachment"/>, or when replacing or deleting a <see cref="T:Microsoft.Azure.Documents.Document"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreatePermissionUri(System.String,System.String,System.String)">
            <summary>
            Given a database and user id, this creates a permission link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="userId">The user id</param>
            <param name="permissionId">The permission id</param>
            <returns>
            A permission link in the format of /dbs/{0}/users/{1}/permissions/{2} with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="userId"/> and {2} being <paramref name="permissionId"/>
            </returns>
            <remarks>Would be used when replacing or deleting a <see cref="T:Microsoft.Azure.Cosmos.Permission"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateStoredProcedureUri(System.String,System.String,System.String)">
            <summary>
            Given a database, collection and stored proc id, this creates a stored proc link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="storedProcedureId">The stored procedure id</param>
            <returns>
            A stored procedure link in the format of /dbs/{0}/colls/{1}/sprocs/{2}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/> and {2} being the <paramref name="storedProcedureId"/>
            </returns>
            <remarks>Would be used when replacing, executing, or deleting a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateStoredProcedureUri(System.String,System.String)">
            <summary>
            Given a collection link and stored proc id, this creates a stored proc link.
            </summary>
            <param name="documentCollectionLink">The collection link</param>
            <param name="storedProcedureId">The stored procedure id</param>
            <returns>
            A stored procedure link in the format of {0}/sprocs/{1}/ with {0} being <paramref name="documentCollectionLink"/> and {1} being <paramref name="storedProcedureId"/>
            </returns>
            <remarks>Would be used when replacing, executing, or deleting a <see cref="T:Microsoft.Azure.Documents.StoredProcedure"/> in Azure DocumentDB.</remarks>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateTriggerUri(System.String,System.String,System.String)">
            <summary>
            Given a database, collection and trigger id, this creates a trigger link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="triggerId">The trigger id</param>
            <returns>
            A trigger link in the format of /dbs/{0}/colls/{1}/triggers/{2}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/> and {2} being the <paramref name="triggerId"/>
            </returns>
            <remarks>Would be used when replacing, executing, or deleting a <see cref="T:Microsoft.Azure.Documents.Trigger"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateUserDefinedFunctionUri(System.String,System.String,System.String)">
            <summary>
            Given a database, collection and udf id, this creates a udf link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="udfId">The udf id</param>
            <returns>
            A udf link in the format of /dbs/{0}/colls/{1}/udfs/{2}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/> and {2} being the <paramref name="udfId"/>
            </returns>
            <remarks>Would be used when replacing, executing, or deleting a <see cref="T:Microsoft.Azure.Documents.UserDefinedFunction"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateConflictUri(System.String,System.String,System.String)">
            <summary>
            Given a database, collection and conflict id, this creates a conflict link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="conflictId">The conflict id</param>
            <returns>
            A conflict link in the format of /dbs/{0}/colls/{1}/conflicts/{2}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/> and {2} being the <paramref name="conflictId"/>
            </returns>
            <remarks>Would be used when creating a <see cref="T:Microsoft.Azure.Documents.Conflict"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateAttachmentUri(System.String,System.String,System.String,System.String)">
            <summary>
            Given a database, collection, document, and attachment id, this creates an attachment link.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="documentId">The document id</param>
            <param name="attachmentId">The attachment id</param>
            <returns>
            An attachment link in the format of /dbs/{0}/colls/{1}/docs/{2}/attachments/{3} with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/>, {2} being the <paramref name="documentId"/> and {3} being <paramref name="attachmentId"/>
            </returns>
            <remarks>Would be used when replacing, or deleting an <see cref="T:Microsoft.Azure.Documents.Attachment"/> in Azure Cosmos DB.</remarks>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreatePartitionKeyRangesUri(System.String,System.String)">
            <summary>
            Given a database and collection, this creates a partition key ranges link in the Azure Cosmos DB service.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <returns>
            A partition key ranges link in the format of /dbs/{0}/colls/{1}/pkranges with {0} being a Uri escaped version of the <paramref name="databaseId"/> and {1} being <paramref name="collectionId"/>.
            </returns>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.UriFactory.CreateSchemaUri(System.String,System.String,System.String)">
            <summary>
            Given a database, collection and schema id, this creates a schema link in the Azure Cosmos DB service.
            </summary>
            <param name="databaseId">The database id</param>
            <param name="collectionId">The collection id</param>
            <param name="schemaId">The schema id</param>
            <returns>
            A schema link in the format of /dbs/{0}/colls/{1}/schemas/{2}/ with {0} being a Uri escaped version of the <paramref name="databaseId"/>, {1} being <paramref name="collectionId"/> and {2} being the <paramref name="schemaId"/>
            </returns>
            <seealso cref="M:System.Uri.EscapeUriString(System.String)"/>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.UserAgentContainer">
            <summary>
            Contains information about the user environment and helps identify requests.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.DictionaryExtensions.EqualsTo(System.Collections.Generic.IDictionary{System.String,Newtonsoft.Json.Linq.JToken},System.Collections.Generic.IDictionary{System.String,Newtonsoft.Json.Linq.JToken})">
            <summary>
            Compare two dictionaries and return true if they have same pair of key-values
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ExecUtils.ProcessResourceOperationAsync``1(Microsoft.Azure.Cosmos.CosmosClient,System.String,Microsoft.Azure.Documents.ResourceType,Microsoft.Azure.Documents.OperationType,Microsoft.Azure.Cosmos.RequestOptions,Microsoft.Azure.Cosmos.ContainerInternal,Microsoft.Azure.Cosmos.FeedRange,System.IO.Stream,System.Action{Microsoft.Azure.Cosmos.RequestMessage},System.Func{Microsoft.Azure.Cosmos.ResponseMessage,``0},Microsoft.Azure.Cosmos.Tracing.ITrace,System.Threading.CancellationToken)">
            <summary>
            Used internally by friends ensrue robust argument and
            exception-less handling, with container information
            </summary>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.InterlockIncrementCheck">
            <summary>
            This class is used to assert that a region of code can only be called concurrently by a limited amount of threads.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.InterlockIncrementCheck.EnterLockCheck">
             <summary>
             Increments the internal lock and asserts that only the allowed
             </summary>
             <exception cref="T:System.InvalidOperationException">When more operations than those allowed try to access the context.</exception>
             <example>
             InterlockIncrementCheck interlockIncrementCheck = new InterlockIncrementCheck();
             using (interlockIncrementCheck.EnterLockCheck())
             {
                // protected code
             }
            
             </example>
        </member>
        <member name="T:Microsoft.Azure.Cosmos.ServicePointAccessor">
            <summary>
            While ServicePoint is a NETStandard 2.0 API, not all runtimes support the operations and some Framework implementations might not support it.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.Cosmos.ServicePointAccessor.TryDisableUseNagleAlgorithm">
            <summary>
            Disable Nagle for HTTP requests.
            This improves latency/throughput for Gateway operations on.net Framework
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.AntlrFileStream">
            <summary>
            This is an
            <see cref="T:Antlr4.Runtime.AntlrInputStream"/>
            that is loaded from a file all at once
            when you construct the object.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.#ctor(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrFileStream.Load(System.String,System.Text.Encoding)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="F:Antlr4.Runtime.BaseInputCharStream.n">
            <summary>How many characters are actually in the buffer</summary>
        </member>
        <member name="F:Antlr4.Runtime.BaseInputCharStream.p">
            <summary>0..n-1 index into string of next char</summary>
        </member>
        <member name="F:Antlr4.Runtime.BaseInputCharStream.name">
            <summary>What is name or source of this char stream?</summary>
        </member>
        <member name="M:Antlr4.Runtime.BaseInputCharStream.Reset">
            <summary>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </summary>
            <remarks>
            Reset the stream so that it's in the same state it was
            when the object was created *except* the data array is not
            touched.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.BaseInputCharStream.Index">
            <summary>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.
            </summary>
            <remarks>
            Return the current input symbol index 0..n where n indicates the
            last symbol has been read.  The index is the index of char to
            be returned from LA(1).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BaseInputCharStream.Mark">
            <summary>mark/release do nothing; we have entire buffer</summary>
        </member>
        <member name="M:Antlr4.Runtime.BaseInputCharStream.Seek(System.Int32)">
            <summary>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine.
            </summary>
            <remarks>
            consume() ahead until p==index; can't just set p=index as we must
            update line and charPositionInLine. If we seek backwards, just set p
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.AntlrInputStream">
            <summary>
            Vacuum all input from a
            <see cref="T:System.IO.TextReader"/>
            /
            <see cref="T:System.IO.Stream"/>
            and then treat it
            like a
            <c>char[]</c>
            buffer. Can also pass in a
            <see cref="T:System.String"/>
            or
            <c>char[]</c>
            to use.
            <p>If you need encoding, pass in stream/reader with correct encoding.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.AntlrInputStream.data">
            <summary>The data being scanned</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.String)">
            <summary>Copy data in string to a local char array</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.Char[],System.Int32)">
            <summary>This is the preferred constructor for strings as no data is copied</summary>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.AntlrInputStream.Load(System.IO.TextReader,System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="T:Antlr4.Runtime.CodePointCharStream">
             <summary>
             Alternative to
             <see cref="T:Antlr4.Runtime.AntlrInputStream"/>
             which treats the input as a series of Unicode code points,
             instead of a series of UTF-16 code units.
            
             Use this if you need to parse input which potentially contains
             Unicode values > U+FFFF.
             </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AbstractPredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AmbiguityInfo">
            <summary>This class represents profiling event information for an ambiguity.</summary>
            <remarks>
            This class represents profiling event information for an ambiguity.
            Ambiguities are decisions where a particular input resulted in an SLL
            conflict, followed by LL prediction also reaching a conflict state
            (indicating a true ambiguity in the grammar).
            <p>
            This event may be reported during SLL prediction in cases where the
            conflicting SLL configuration set provides sufficient information to
            determine that the SLL conflict is truly an ambiguity. For example, if none
            of the ATN configurations in the conflicting SLL configuration set have
            traversed a global follow transition (i.e.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.reachesIntoOuterContext"/>
            is
            <see langword="false"/>
            for all
            configurations), then the result of SLL prediction for that input is known to
            be equivalent to the result of LL prediction for that input.</p>
            <p>
            In some cases, the minimum represented alternative in the conflicting LL
            configuration set is not equal to the minimum represented alternative in the
            conflicting SLL configuration set. Grammars and inputs which result in this
            scenario are unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.SLL"/>
            , which in turn means
            they cannot use the two-stage parsing strategy to improve parsing performance
            for that input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.AmbiguityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.AmbiguityInfo"/>
            class with the
            specified detailed ambiguity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state identifying the ambiguous
            alternatives for the current input
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the ambiguity was identified during
            prediction
            </param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ArrayPredictionContext.parents">
            Parent can be null only if full ctx mode and we make an array
            from {@link #EMPTY} and non-empty. We merge {@link #EMPTY} by using null parent and
            returnState == {@link #EMPTY_RETURN_STATE}.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ArrayPredictionContext.returnStates">
            Sorted for merge, no duplicates; if present,
            {@link #EMPTY_RETURN_STATE} is always last.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.decisionToState">
            <summary>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.
            </summary>
            <remarks>
            Each subrule/rule is a decision point and we must track them so we
            can go back later and build DFA predictors for them.  This includes
            all the rules, subrules, optional blocks, ()+, ()* etc...
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStartState">
            <summary>Maps from rule index to starting state number.</summary>
            <remarks>Maps from rule index to starting state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToStopState">
            <summary>Maps from rule index to stop state number.</summary>
            <remarks>Maps from rule index to stop state number.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.grammarType">
            <summary>The type of the ATN.</summary>
            <remarks>The type of the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.maxTokenType">
            <summary>The maximum value for any symbol recognized by a transition in the ATN.</summary>
            <remarks>The maximum value for any symbol recognized by a transition in the ATN.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.ruleToTokenType">
            <summary>For lexer ATNs, this maps the rule index to the resulting token type.</summary>
            <remarks>
            For lexer ATNs, this maps the rule index to the resulting token type.
            For parser ATNs, this maps the rule index to the generated bypass token
            type if the
            <see cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
            deserialization option was specified; otherwise, this is
            <see langword="null"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATN.lexerActions">
            <summary>
            For lexer ATNs, this is an array of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            objects which may
            be referenced by action transitions in the ATN.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.#ctor(Antlr4.Runtime.Atn.ATNType,System.Int32)">
            <summary>Used for runtime deserialization of ATNs from strings</summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.RuleContext)">
            <summary>
            Compute the set of valid tokens that can occur starting in state
            <paramref name="s"/>
            .
            If
            <paramref name="ctx"/>
            is
            <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
            , the set of tokens will not include what can follow
            the rule surrounding
            <paramref name="s"/>
            . In other words, the set will be
            restricted to tokens reachable staying within
            <paramref name="s"/>
            's rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.NextTokens(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Compute the set of valid tokens that can occur starting in
            <paramref name="s"/>
            and
            staying in same rule.
            <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
            is in set if we reach end of
            rule.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)">
            <summary>
            Computes the set of input symbols which could follow ATN state number
            <paramref name="stateNumber"/>
            in the specified full
            <paramref name="context"/>
            . This method
            considers the complete parser context, but does not evaluate semantic
            predicates (i.e. all predicates encountered during the calculation are
            assumed true). If a path in the ATN exists from the starting state to the
            <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
            of the outermost context without matching any
            symbols,
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            is added to the returned set.
            <p>If
            <paramref name="context"/>
            is
            <see langword="null"/>
            , it is treated as
            <see cref="P:Antlr4.Runtime.ParserRuleContext.EmptyContext"/>
            .</p>
            </summary>
            <param name="stateNumber">the ATN state number</param>
            <param name="context">the full parse context</param>
            <returns>
            The set of potentially valid input symbols which could follow the
            specified state in the specified context.
            </returns>
            <exception cref="T:System.ArgumentException">
            if the ATN does not contain a state with
            number
            <paramref name="stateNumber"/>
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNConfig">
            A tuple: (ATN state, predicted alt, syntactic, semantic context).
            The syntactic context is a graph-structured stack node whose
            path(s) to the root is the rule invocation(s)
            chain used to arrive at the state.  The semantic context is
            the tree of semantic predicates encountered before reaching
            an ATN state.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.SUPPRESS_PRECEDENCE_FILTER">
            This field stores the bit mask for implementing the
            {@link #isPrecedenceFilterSuppressed} property as a bit within the
            existing {@link #reachesIntoOuterContext} field.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.state">
            The ATN state associated with this configuration 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.alt">
            What alt (or lexer rule) is predicted by this configuration 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.context">
            The stack of invoking states leading to the rule/states associated
            with this config.  We track only those contexts pushed during
            execution of the ATN simulator.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfig.reachesIntoOuterContext">
             We cannot execute predicates dependent upon local context unless
             we know for sure we are in the correct context. Because there is
             no way to do this efficiently, we simply cannot evaluate
             dependent predicates unless we are in the rule that initially
             invokes the ATN simulator.
            
             <p>
             closure() tracks the depth of how far we dip into the outer context:
             depth &gt; 0.  Note that it may not be totally accurate depth since I
             don't ever decrement. TODO: make it a boolean then</p>
            
             <p>
             For memory efficiency, the {@link #isPrecedenceFilterSuppressed} method
             is also backed by this field. Since the field is publicly accessible, the
             highest bit which would not cause the value to become negative is used to
             store this field. This choice minimizes the risk that code which only
             compares this value to 0 would be affected by the new purpose of the
             flag. It also ensures the performance of the existing {@link ATNConfig}
             constructors as well as certain operations like
             {@link ATNConfigSet#add(ATNConfig, DoubleKeyMap)} method are
             <em>completely</em> unaffected by the change.</p>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfig.OuterContextDepth">
            This method gets the value of the {@link #reachesIntoOuterContext} field
            as it existed prior to the introduction of the
            {@link #isPrecedenceFilterSuppressed} method.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfig.Equals(System.Object)">
            An ATN configuration is equal to another if both have
            the same state, they predict the same alternative, and
            syntactic/semantic contexts are the same.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.readOnly">
            Indicates that the set of configurations is read-only. Do not
            allow any code to manipulate the set; DFA states will point at
            the sets and they must not change. This does not protect the other
            fields; in particular, conflictingAlts is set after
            we've made this readonly.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configLookup">
            All configs but hashed by (s, i, _, pi) not including context. Wiped out
            when we go readonly as this set becomes a DFA state.
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.configs">
            Track the elements as they are added to the set; supports get(i) 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.conflictingAlts">
            Currently this is only used when we detect SLL conflict; this does
            not necessarily represent the ambiguous alternatives. In fact,
            I should also point out that this seems to include predicated alternatives
            that have predicates that evaluate to false. Computed in computeTargetState().
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNConfigSet.fullCtx">
            Indicates that this configuration set is part of a full context
            LL prediction. It will be used to determine how to merge $. With SLL
            it's a wildcard whereas it is not for LL context merge.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfigSet.Add(Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.MergeCache)">
             Adding a new config means merging contexts with existing configs for
             {@code (s, i, pi, _)}, where {@code s} is the
             {@link ATNConfig#state}, {@code i} is the {@link ATNConfig#alt}, and
             {@code pi} is the {@link ATNConfig#semanticContext}. We use
             {@code (s,i,pi)} as key.
            
             <p>This method updates {@link #dipsIntoOuterContext} and
             {@link #hasSemanticContext} when necessary.</p>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ATNConfigSet.Elements">
            Return a List holding list of configs 
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNConfigSet.GetAlts">
             Gets the complete set of represented alternatives for the configuration
             set.
            
             @return the set of represented alternatives in this configuration set
            
             @since 4.3
        </member>
        <member name="T:Antlr4.Runtime.Atn.ConfigHashSet">
            The reason that we need this is because we don't want the hash map to use
            the standard hash code and equals. We need all configurations with the same
            {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively doubles
            the number of objects associated with ATNConfigs. The other solution is to
            use a hash table that lets us specify the equals/hashcode operation.
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializationOptions">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNDeserializer">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.BaseSerializedUuid">
            <summary>This is the earliest supported serialized UUID.</summary>
            <remarks>This is the earliest supported serialized UUID.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.AddedUnicodeSmp">
            <summary>
            This UUID indicates the serialized ATN contains two sets of
            IntervalSets, where the second set's values are encoded as
            32-bit integers to support the full Unicode SMP range up to U+10FFFF.
            </summary>
            <remarks>
            This UUID indicates the serialized ATN contains two sets of
            IntervalSets, where the second set's values are encoded as
            32-bit integers to support the full Unicode SMP range up to U+10FFFF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SupportedUuids">
            <summary>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </summary>
            <remarks>
            This list contains all of the currently supported UUIDs, ordered by when
            the feature first appeared in this branch.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNDeserializer.SerializedUuid">
            <summary>This is the current serialized UUID.</summary>
            <remarks>This is the current serialized UUID.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.IsFeatureSupported(System.Guid,System.Guid)">
             <summary>
             Determines if a particular serialized representation of an ATN supports
             a particular feature, identified by the
             <see cref="T:System.Guid"/>
             used for serializing
             the ATN at the time the feature was first introduced.
             </summary>
             <param name="feature">
             The
             <see cref="T:System.Guid"/>
             marking the first time the feature was
             supported in the serialized ATN.
             </param>
             <param name="actualUuid">
             The
             <see cref="T:System.Guid"/>
             of the actual serialized ATN which is
             currently being deserialized.
             </param>
             <returns>
            
             <see langword="true"/>
             if the
             <paramref name="actualUuid"/>
             value represents a
             serialized ATN at or after the feature identified by
             <paramref name="feature"/>
             was
             introduced; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNDeserializer.MarkPrecedenceDecisions(Antlr4.Runtime.Atn.ATN)">
            <summary>
            Analyze the
            <see cref="T:Antlr4.Runtime.Atn.StarLoopEntryState"/>
            states in the specified ATN to set
            the
            <see cref="F:Antlr4.Runtime.Atn.StarLoopEntryState.isPrecedenceDecision"/>
            field to the
            correct value.
            </summary>
            <param name="atn">The ATN.</param>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.ERROR">
            Must distinguish between missing edge and edge we know leads nowhere 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ATNSimulator.sharedContextCache">
            The context cache maps all PredictionContext objects that are equals()
              to a single cached copy. This cache is shared across all contexts
              in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
              to use only cached nodes/graphs in addDFAState(). We don't want to
              fill this during closure() since there are lots of contexts that
              pop up but are not used ever again. It also greatly slows down closure().
            
              <p>This cache makes a huge difference in memory and a little bit in speed.
              For the Java grammar on java.*, it dropped the memory requirements
              at the end from 25M to 16M. We don't store any of the full context
              graphs in the DFA because they are limited to local context only,
              but apparently there's a lot of repetition there as well. We optimize
              the config contexts before storing the config set in the DFA states
              by literally rebuilding them with cached subgraphs only.</p>
            
              <p>I tried a cache for use during closure operations, that was
              whacked after each adaptivePredict(). It cost a little bit
              more time I think and doesn't save on the overall footprint
              so it's not worth the complexity.</p>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ATNSimulator.ClearDFA">
             Clear the DFA cache used by the current instance. Since the DFA cache may
             be shared by multiple ATN simulators, this method may affect the
             performance (but not accuracy) of other parsers which are being used
             concurrently.
            
             @throws UnsupportedOperationException if the current instance does not
             support clearing the DFA.
            
             @since 4.3
        </member>
        <member name="T:Antlr4.Runtime.Atn.ATNType">
            <summary>Represents the type of recognizer an ATN applies to.</summary>
            <remarks>Represents the type of recognizer an ATN applies to.</remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.AtomTransition">
            <summary>TODO: make all transitions sets? no, should remove set edges</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.AtomTransition.token">
            <summary>The token type or character value; or, signifies special label.</summary>
            <remarks>The token type or character value; or, signifies special label.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicBlockStartState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BasicState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockEndState">
            <summary>
            Terminal node of a simple
            <c>(a|b|c)</c>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.BlockStartState">
            <summary>
            The start of a regular
            <c>(...)</c>
            block.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ConflictInfo">
            <summary>This class stores information about a configuration conflict.</summary>
            <author>Sam Harwell</author>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ConflictInfo.ConflictedAlts">
            <summary>Gets the set of conflicting alternatives for the configuration set.</summary>
            <remarks>Gets the set of conflicting alternatives for the configuration set.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ConflictInfo.IsExact">
            <summary>Gets whether or not the configuration conflict is an exact conflict.</summary>
            <remarks>
            Gets whether or not the configuration conflict is an exact conflict.
            An exact conflict occurs when the prediction algorithm determines that
            the represented alternatives for a particular configuration set cannot be
            further reduced by consuming additional input. After reaching an exact
            conflict during an SLL prediction, only switch to full-context prediction
            could reduce the set of viable alternatives. In LL prediction, an exact
            conflict indicates a true ambiguity in the input.
            <p>
            For the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION"/>
            prediction mode,
            accept states are conflicting but not exact are treated as non-accept
            states.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ContextSensitivityInfo">
            <summary>This class represents profiling event information for a context sensitivity.</summary>
            <remarks>
            This class represents profiling event information for a context sensitivity.
            Context sensitivities are decisions where a particular input resulted in an
            SLL conflict, but LL prediction produced a single unique alternative.
            <p>
            In some cases, the unique alternative identified by LL prediction is not
            equal to the minimum represented alternative in the conflicting SLL
            configuration set. Grammars and inputs which result in this scenario are
            unable to use
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.SLL"/>
            , which in turn means they cannot use
            the two-stage parsing strategy to improve parsing performance for that
            input.</p>
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportContextSensitivity(Antlr4.Runtime.Dfa.DFA,System.Int32,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32,System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ContextSensitivityInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ContextSensitivityInfo"/>
            class
            with the specified detailed context sensitivity information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state containing the unique
            alternative identified by full-context prediction
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the context sensitivity was
            identified during full-context prediction
            </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionEventInfo">
            <summary>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </summary>
            <remarks>
            This is the base class for gathering detailed information about prediction
            events which occur during parsing.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.decision">
            <summary>The invoked decision number which this event is related to.</summary>
            <remarks>The invoked decision number which this event is related to.</remarks>
            <seealso cref="F:Antlr4.Runtime.Atn.ATN.decisionToState"/>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.state">
            <summary>
            The simulator state containing additional information relevant to the
            prediction state when the current event occurred, or
            <see langword="null"/>
            if no
            additional information is relevant or available.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.input">
            <summary>The input token stream which is being parsed.</summary>
            <remarks>The input token stream which is being parsed.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.startIndex">
            <summary>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </summary>
            <remarks>
            The token index in the input stream at which the current prediction was
            originally invoked.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.stopIndex">
            <summary>The token index in the input stream at which the current event occurred.</summary>
            <remarks>The token index in the input stream at which the current event occurred.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionEventInfo.fullCtx">
            <summary>
            <see langword="true"/>
            if the current event occurred during LL prediction;
            otherwise,
            <see langword="false"/>
            if the input occurred during SLL prediction.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.DecisionInfo">
            <summary>This class contains profiling gathered for a particular decision.</summary>
            <remarks>
            This class contains profiling gathered for a particular decision.
            <p>
            Parsing performance in ANTLR 4 is heavily influenced by both static factors
            (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the
            choice of input and the state of the DFA cache at the time profiling
            operations are started). For best results, gather and use aggregate
            statistics from a large sample of inputs representing the inputs expected in
            production before using the results to make changes in the grammar.</p>
            </remarks>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.decision">
            The decision number, which is an index into {@link ATN#decisionToState}.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.invocations">
            The total number of times {@link ParserATNSimulator#adaptivePredict} was
            invoked for this decision.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.timeInPrediction">
             The total time spent in {@link ParserATNSimulator#adaptivePredict} for
             this decision, in nanoseconds.
            
             <p>
             The value of this field contains the sum of differential results obtained
             by {@link System#nanoTime()}, and is not adjusted to compensate for JIT
             and/or garbage collection overhead. For best accuracy, use a modern JVM
             implementation that provides precise results from
             {@link System#nanoTime()}, and perform profiling in a separate process
             which is warmed up by parsing the input prior to profiling. If desired,
             call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial
             state before starting the profiling measurement pass.</p>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_TotalLook">
            The sum of the lookahead required for SLL prediction for this decision.
            Note that SLL prediction is used before LL prediction for performance
            reasons even when {@link PredictionMode#LL} or
            {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MinLook">
            Gets the minimum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLook">
            Gets the maximum lookahead required for any single SLL prediction to
            complete for this decision, by reaching a unique prediction, reaching an
            SLL conflict state, or encountering a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_MaxLookEvent">
            Gets the {@link LookaheadEventInfo} associated with the event where the
            {@link #SLL_MaxLook} value was set.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_TotalLook">
            The sum of the lookahead required for LL prediction for this decision.
            Note that LL prediction is only used when SLL prediction reaches a
            conflict state.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MinLook">
            Gets the minimum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            {@link PredictionMode#LL}, an ambiguity state (for
            {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLook">
            Gets the maximum lookahead required for any single LL prediction to
            complete for this decision. An LL prediction completes when the algorithm
            reaches a unique prediction, a conflict state (for
            {@link PredictionMode#LL}, an ambiguity state (for
            {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_MaxLookEvent">
            Gets the {@link LookaheadEventInfo} associated with the event where the
            {@link #LL_MaxLook} value was set.
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities">
             A collection of {@link ContextSensitivityInfo} instances describing the
             context sensitivities encountered during LL prediction for this decision.
            
             @see ContextSensitivityInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.errors">
             A collection of {@link ErrorInfo} instances describing the parse errors
             identified during calls to {@link ParserATNSimulator#adaptivePredict} for
             this decision.
            
             @see ErrorInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.ambiguities">
             A collection of {@link AmbiguityInfo} instances describing the
             ambiguities encountered during LL prediction for this decision.
            
             @see AmbiguityInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.predicateEvals">
             A collection of {@link PredicateEvalInfo} instances describing the
             results of evaluating individual predicates during prediction for this
             decision.
            
             @see PredicateEvalInfo
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_ATNTransitions">
             The total number of ATN transitions required during SLL prediction for
             this decision. An ATN transition is determined by the number of times the
             DFA does not contain an edge that is required for prediction, resulting
             in on-the-fly computation of that edge.
            
             <p>
             If DFA caching of SLL transitions is employed by the implementation, ATN
             computation may cache the computed edge for efficient lookup during
             future parsing of this decision. Otherwise, the SLL parsing algorithm
             will use ATN transitions exclusively.</p>
            
             @see #SLL_ATNTransitions
             @see ParserATNSimulator#computeTargetState
             @see LexerATNSimulator#computeTargetState
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.SLL_DFATransitions">
             The total number of DFA transitions required during SLL prediction for
             this decision.
            
             <p>If the ATN simulator implementation does not use DFA caching for SLL
             transitions, this value will be 0.</p>
            
             @see ParserATNSimulator#getExistingTargetState
             @see LexerATNSimulator#getExistingTargetState
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_Fallback">
             Gets the total number of times SLL prediction completed in a conflict
             state, resulting in fallback to LL prediction.
            
             <p>Note that this value is not related to whether or not
             {@link PredictionMode#SLL} may be used successfully with a particular
             grammar. If the ambiguity resolution algorithm applied to the SLL
             conflicts for this decision produce the same result as LL prediction for
             this decision, {@link PredictionMode#SLL} would produce the same overall
             parsing result as {@link PredictionMode#LL}.</p>
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_ATNTransitions">
             The total number of ATN transitions required during LL prediction for
             this decision. An ATN transition is determined by the number of times the
             DFA does not contain an edge that is required for prediction, resulting
             in on-the-fly computation of that edge.
            
             <p>
             If DFA caching of LL transitions is employed by the implementation, ATN
             computation may cache the computed edge for efficient lookup during
             future parsing of this decision. Otherwise, the LL parsing algorithm will
             use ATN transitions exclusively.</p>
            
             @see #LL_DFATransitions
             @see ParserATNSimulator#computeTargetState
             @see LexerATNSimulator#computeTargetState
        </member>
        <member name="F:Antlr4.Runtime.Atn.DecisionInfo.LL_DFATransitions">
             The total number of DFA transitions required during LL prediction for
             this decision.
            
             <p>If the ATN simulator implementation does not use DFA caching for LL
             transitions, this value will be 0.</p>
            
             @see ParserATNSimulator#getExistingTargetState
             @see LexerATNSimulator#getExistingTargetState
        </member>
        <member name="M:Antlr4.Runtime.Atn.DecisionInfo.#ctor(System.Int32)">
             Constructs a new instance of the {@link DecisionInfo} class to contain
             statistics for a particular decision.
            
             @param decision The decision number
        </member>
        <member name="P:Antlr4.Runtime.Atn.EpsilonTransition.OutermostPrecedenceReturn">
            <returns>
            the rule index of a precedence rule for which this transition is
            returning from, where the precedence value is 0; otherwise, -1.
            </returns>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNConfig.IsPrecedenceFilterSuppressed"/>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet)"/>
            <since>4.4.1</since>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ErrorInfo">
            <summary>
            This class represents profiling event information for a syntax error
            identified during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for a syntax error
            identified during prediction. Syntax errors occur when the prediction
            algorithm is unable to identify an alternative which would lead to a
            successful parse.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(Antlr4.Runtime.IToken,System.String,Antlr4.Runtime.RecognitionException)"/>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)"/>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ErrorInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.ErrorInfo"/>
            class with the
            specified detailed syntax error information.
            </summary>
            <param name="decision">The decision number</param>
            <param name="state">
            The final simulator state reached during prediction
            prior to reaching the
            <see cref="F:Antlr4.Runtime.Atn.ATNSimulator.ERROR"/>
            state
            </param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">The index at which the syntax error was identified</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ILexerAction">
            <summary>
            Represents a single action which can be executed following the successful
            match of a lexer rule.
            </summary>
            <remarks>
            Represents a single action which can be executed following the successful
            match of a lexer rule. Lexer actions are used for both embedded action syntax
            and ANTLR 4's new lexer command syntax.
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.ActionType">
            <summary>Gets the serialization type of the lexer action.</summary>
            <remarks>Gets the serialization type of the lexer action.</remarks>
            <returns>The serialization type of the lexer action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent">
             <summary>Gets whether the lexer action is position-dependent.</summary>
             <remarks>
             Gets whether the lexer action is position-dependent. Position-dependent
             actions may have different semantics depending on the
             <see cref="T:Antlr4.Runtime.ICharStream"/>
             index at the time the action is executed.
             <p>Many lexer commands, including
             <c>type</c>
             ,
             <c>skip</c>
             , and
             <c>more</c>
             , do not check the input index during their execution.
             Actions like this are position-independent, and may be stored more
             efficiently as part of the
             <see cref="F:Antlr4.Runtime.Atn.LexerATNConfig.lexerActionExecutor"/>
             .</p>
             </remarks>
             <returns>
            
             <see langword="true"/>
             if the lexer action semantics can be affected by the
             position of the input
             <see cref="T:Antlr4.Runtime.ICharStream"/>
             at the time it is executed;
             otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            Execute the lexer action in the context of the specified
            <see cref="T:Antlr4.Runtime.Lexer"/>
            .
            <p>For position-dependent actions, the input stream must already be
            positioned correctly prior to calling this method.</p>
            </summary>
            <param name="lexer">The lexer instance.</param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionExecutor">
            <summary>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            </summary>
            <remarks>
            Represents an executor for a sequence of lexer actions which traversed during
            the matching operation of a lexer rule (token).
            <p>The executor tracks position information for position-dependent lexer actions
            efficiently, ensuring that actions appearing only at the end of the rule do
            not cause bloating of the
            <see cref="T:Antlr4.Runtime.Dfa.DFA"/>
            created for the lexer.</p>
            </remarks>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode">
            <summary>
            Caches the result of
            <see cref="F:Antlr4.Runtime.Atn.LexerActionExecutor.hashCode"/>
            since the hash code is an element
            of the performance-critical
            <see cref="M:Antlr4.Runtime.Atn.ATNConfig.GetHashCode"/>
            operation.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.#ctor(Antlr4.Runtime.Atn.ILexerAction[])">
            <summary>
            Constructs an executor for a sequence of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            actions.
            </summary>
            <param name="lexerActions">The lexer actions to execute.</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which executes the actions for
            the input
            <paramref name="lexerActionExecutor"/>
            followed by a specified
            <paramref name="lexerAction"/>
            .
            </summary>
            <param name="lexerActionExecutor">
            The executor for actions already traversed by
            the lexer while matching a token within a particular
            <see cref="T:Antlr4.Runtime.Atn.ATNConfig"/>
            . If this is
            <see langword="null"/>
            , the method behaves as though
            it were an empty executor.
            </param>
            <param name="lexerAction">
            The lexer action to execute after the actions
            specified in
            <paramref name="lexerActionExecutor"/>
            .
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            for executing the combine actions
            of
            <paramref name="lexerActionExecutor"/>
            and
            <paramref name="lexerAction"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)">
            <summary>
            Creates a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which encodes the current offset
            for position-dependent lexer actions.
            <p>Normally, when the executor encounters lexer actions where
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <see langword="true"/>
            , it calls
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            on the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            to set the input
            position to the <em>end</em> of the current token. This behavior provides
            for efficient DFA representation of lexer actions which appear at the end
            of a lexer rule, even when the lexer rule matches a variable number of
            characters.</p>
            <p>Prior to traversing a match transition in the ATN, the current offset
            from the token start index is assigned to all position-dependent lexer
            actions which have not already been assigned a fixed offset. By storing
            the offsets relative to the token start index, the DFA representation of
            lexer actions which appear in the middle of tokens remains efficient due
            to sharing among tokens of the same length, regardless of their absolute
            position in the input stream.</p>
            <p>If the current executor already has offsets assigned to all
            position-dependent lexer actions, the method returns
            <c>this</c>
            .</p>
            </summary>
            <param name="offset">
            The current offset to assign to all position-dependent
            lexer actions which do not already have offsets assigned.
            </param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which stores input stream offsets
            for all position-dependent lexer actions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerActionExecutor.LexerActions">
            <summary>Gets the lexer actions to be executed by this executor.</summary>
            <remarks>Gets the lexer actions to be executed by this executor.</remarks>
            <returns>The lexer actions to be executed by this executor.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerActionExecutor.Execute(Antlr4.Runtime.Lexer,Antlr4.Runtime.ICharStream,System.Int32)">
             <summary>
             Execute the actions encapsulated by this executor within the context of a
             particular
             <see cref="T:Antlr4.Runtime.Lexer"/>
             .
             <p>This method calls
             <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
             to set the position of the
             <paramref name="input"/>
            
             <see cref="T:Antlr4.Runtime.ICharStream"/>
             prior to calling
             <see cref="M:Antlr4.Runtime.Atn.ILexerAction.Execute(Antlr4.Runtime.Lexer)"/>
             on a position-dependent action. Before the
             method returns, the input position will be restored to the same position
             it was in when the method was invoked.</p>
             </summary>
             <param name="lexer">The lexer instance.</param>
             <param name="input">
             The input stream which is the source for the current token.
             When this method is called, the current
             <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
             for
             <paramref name="input"/>
             should be the start of the following token, i.e. 1
             character past the end of the current token.
             </param>
             <param name="startIndex">
             The token start index. This value may be passed to
             <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
             to set the
             <paramref name="input"/>
             position to the beginning
             of the token.
             </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerActionType">
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNConfig.lexerActionExecutor">
            This is the backing field for {@link #getLexerActionExecutor}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNConfig.getLexerActionExecutor">
            Gets the {@link LexerActionExecutor} capable of executing the embedded
            action(s) for the current configuration.
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerATNSimulator">
            <summary>"dup" of ParserInterpreter</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.startIndex">
            The current token's starting index into the character stream.
            Shared across DFA to ATN simulation in case the ATN fails and the
            DFA did not have a previous accept state. In this case, we use the
            ATN-generated exception object.
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.thisLine">
            line number 1..n within the input 
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.charPositionInLine">
            The index of the character relative to the beginning of the line 0..n-1 
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerATNSimulator.prevAccept">
            Used during DFA/ATN exec to record the most recent accept configuration info 
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Get an existing target state for an edge in the DFA. If the target state
             for the edge has not yet been computed or is otherwise not available,
             this method returns {@code null}.
            
             @param s The current DFA state
             @param t The next input symbol
             @return The existing target DFA state for the given input symbol
             {@code t}, or {@code null} if the target state for this edge is not
             already cached
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.ComputeTargetState(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Compute a target state for an edge in the DFA, and attempt to add the
             computed state and corresponding edge to the DFA.
            
             @param input The input stream
             @param s The current DFA state
             @param t The next input symbol
            
             @return The computed target DFA state for the given input symbol
             {@code t}. If {@code t} does not lead to a valid DFA state, this method
             returns {@link #ERROR}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetReachableConfigSet(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.Atn.ATNConfigSet,System.Int32)">
            Given a starting configuration set, figure out all ATN configurations
            we can reach upon input {@code t}. Parameter {@code reach} is a return
            parameter.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.Closure(Antlr4.Runtime.ICharStream,Antlr4.Runtime.Atn.LexerATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean,System.Boolean,System.Boolean)">
             Since the alternatives within any lexer decision are ordered by
             preference, this method stops pursuing the closure as soon as an accept
             state is reached. After the first accept state is reached by depth-first
             search from {@code config}, all other (potentially reachable) states for
             this rule would have a lower priority.
            
             @return {@code true} if an accept state is reached, otherwise
             {@code false}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.EvaluatePredicate(Antlr4.Runtime.ICharStream,System.Int32,System.Int32,System.Boolean)">
             Evaluate a predicate specified in the lexer.
            
             <p>If {@code speculative} is {@code true}, this method was called before
             {@link #consume} for the matched character. This method should call
             {@link #consume} before evaluating the predicate to ensure position
             sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},
             and {@link Lexer#getCharPositionInLine}, properly reflect the current
             lexer state. This method should restore {@code input} and the simulator
             to the original state before returning (i.e. undo the actions made by the
             call to {@link #consume}.</p>
            
             @param input The input stream.
             @param ruleIndex The rule containing the predicate.
             @param predIndex The index of the predicate within the rule.
             @param speculative {@code true} if the current index in {@code input} is
             one character before the predicate's location.
            
             @return {@code true} if the specified predicate evaluates to
             {@code true}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.AddDFAState(Antlr4.Runtime.Atn.ATNConfigSet)">
            Add a new DFA state if there isn't one with this set of
            			configurations already. This method also detects the first
            			configuration containing an ATN rule stop state. Later, when
            			traversing the DFA, we will know which rule to accept.
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerATNSimulator.GetText(Antlr4.Runtime.ICharStream)">
            Get the text matched so far for the current token.
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimState">
            When we hit an accept state in either the DFA or the ATN, we
              have to notify the character stream to start buffering characters
              via {@link IntStream#mark} and record the current state. The current sim state
              includes the current index into the input, the current line,
              and current character position in that line. Note that the Lexer is
              tracking the starting line and characterization of the token. These
              variables track the "state" of the simulator when it hits an accept state.
            
              <p>We track these variables separately for the DFA and ATN simulation
              because the DFA simulation often has to fail over to the ATN
              simulation. If the ATN simulation fails, we need the DFA to fall
              back to its previously accepted state, if any. If the ATN succeeds,
              then the ATN does the accept and the DFA simulator that invoked it
              can simply return the predicted token type.</p>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerChannelAction">
            <summary>
            Implements the
            <c>channel</c>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the assigned channel.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="channel"/>
            action with the specified channel value.
            </summary>
            <param name="channel">
            The channel value to pass to
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel">
            <summary>
            Gets the channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </summary>
            <returns>
            The channel to use for the
            <see cref="T:Antlr4.Runtime.IToken"/>
            created by the lexer.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Channel"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerChannelAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerChannelAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerChannelAction.Channel"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerCustomAction">
            <summary>
            Executes a custom lexer action by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            rule and action indexes assigned to the custom action. The implementation of
            a custom action is added to the generated code for the lexer in an override
            of
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            when the grammar is compiled.
            <p>This class may represent embedded actions created with the <code>{...}</code>
            syntax in ANTLR 4, as well as actions created for lexer commands where the
            command argument could not be evaluated when the grammar was compiled.</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </summary>
            <remarks>
            Constructs a custom lexer action with the specified rule and action
            indexes.
            </remarks>
            <param name="ruleIndex">
            The rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
            <param name="actionIndex">
            The action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.RuleIndex">
            <summary>
            Gets the rule index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The rule index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionIndex">
            <summary>
            Gets the action index to use for calls to
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            .
            </summary>
            <returns>The action index for the custom action.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Custom"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerCustomAction.IsPositionDependent">
            <summary>Gets whether the lexer action is position-dependent.</summary>
            <remarks>
            Gets whether the lexer action is position-dependent. Position-dependent
            actions may have different semantics depending on the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            index at the time the action is executed.
            <p>Custom actions are position-dependent since they may represent a
            user-defined embedded action which makes calls to methods like
            <see cref="P:Antlr4.Runtime.Lexer.Text"/>
            .</p>
            </remarks>
            <returns>
            This method returns
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>Custom actions are implemented by calling
            <see cref="M:Antlr4.Runtime.Recognizer`2.Action(Antlr4.Runtime.RuleContext,System.Int32,System.Int32)"/>
            with the
            appropriate rule and action indexes.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerIndexedCustomAction">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            is used for tracking input offsets
            for position-dependent actions within a
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            .
            <p>This action is not serialized as part of the ATN, and is only required for
            position-dependent lexer actions which appear at a location other than the
            end of a rule. For more information about DFA optimizations employed for
            lexer actions, see
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.Append(Antlr4.Runtime.Atn.LexerActionExecutor,Antlr4.Runtime.Atn.ILexerAction)"/>
            and
            <see cref="M:Antlr4.Runtime.Atn.LexerActionExecutor.FixOffsetBeforeMatch(System.Int32)"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.#ctor(System.Int32,Antlr4.Runtime.Atn.ILexerAction)">
            <summary>
            Constructs a new indexed custom action by associating a character offset
            with a
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            .
            <p>Note: This class is only required for lexer actions for which
            <see cref="P:Antlr4.Runtime.Atn.ILexerAction.IsPositionDependent"/>
            returns
            <see langword="true"/>
            .</p>
            </summary>
            <param name="offset">
            The offset into the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            , relative to
            the token start index, at which the specified lexer action should be
            executed.
            </param>
            <param name="action">
            The lexer action to execute at a particular offset in the
            input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Offset">
            <summary>
            Gets the location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed. The value is interpreted as an offset relative
            to the token start index.
            </summary>
            <returns>
            The location in the input
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            at which the lexer
            action should be executed.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action">
            <summary>Gets the lexer action to execute.</summary>
            <remarks>Gets the lexer action to execute.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            object which executes the lexer action.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns the result of calling
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.ActionType"/>
            on the
            <see cref="T:Antlr4.Runtime.Atn.ILexerAction"/>
            returned by
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="true"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This method calls
            <see cref="M:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Execute(Antlr4.Runtime.Lexer)"/>
            on the result of
            <see cref="P:Antlr4.Runtime.Atn.LexerIndexedCustomAction.Action"/>
            using the provided
            <paramref name="lexer"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerModeAction">
            <summary>
            Implements the
            <c>mode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with
            the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="mode"/>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <c>mode</c>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Mode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Mode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerMoreAction">
            <summary>
            Implements the
            <c>more</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .
            <p>The
            <c>more</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerMoreAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>more</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.More"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerMoreAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerMoreAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.More"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPopModeAction">
            <summary>
            Implements the
            <c>popMode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .
            <p>The
            <c>popMode</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerPopModeAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>popMode</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PopMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPopModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPopModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PopMode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerPushModeAction">
            <summary>
            Implements the
            <c>pushMode</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the assigned mode.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <c>pushMode</c>
            action with the specified mode value.
            </summary>
            <param name="mode">
            The mode value to pass to
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode">
            <summary>Get the lexer mode this action should transition the lexer to.</summary>
            <remarks>Get the lexer mode this action should transition the lexer to.</remarks>
            <returns>
            The lexer mode for this
            <c>pushMode</c>
            command.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.PushMode"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerPushModeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerPushModeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.PushMode(System.Int32)"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerPushModeAction.Mode"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerSkipAction">
            <summary>
            Implements the
            <c>skip</c>
            lexer action by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .
            <p>The
            <c>skip</c>
            command does not have any parameters, so this action is
            implemented as a singleton instance exposed by
            <see cref="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance"/>
            .</p>
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LexerSkipAction.Instance">
            <summary>Provides a singleton instance of this parameterless lexer action.</summary>
            <remarks>Provides a singleton instance of this parameterless lexer action.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.#ctor">
            <summary>
            Constructs the singleton instance of the lexer
            <c>skip</c>
            command.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Skip"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerSkipAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerSkipAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LexerTypeAction">
            <summary>
            Implements the
            <c>type</c>
            lexer action by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the assigned type.
            </summary>
            <author>Sam Harwell</author>
            <since>4.2</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <paramref name="type"/>
            action with the specified token type value.
            </summary>
            <param name="type">
            The type to assign to the token using
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            .
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.Type">
            <summary>Gets the type to assign to a token created by the lexer.</summary>
            <remarks>Gets the type to assign to a token created by the lexer.</remarks>
            <returns>The type to assign to a token created by the lexer.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.ActionType">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see cref="F:Antlr4.Runtime.Atn.LexerActionType.Type"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Atn.LexerTypeAction.IsPositionDependent">
            <summary><inheritDoc/></summary>
            <returns>
            This method returns
            <see langword="false"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LexerTypeAction.Execute(Antlr4.Runtime.Lexer)">
            <summary>
            <inheritDoc/>
            <p>This action is implemented by calling
            <see cref="P:Antlr4.Runtime.Lexer.Type"/>
            with the
            value provided by
            <see cref="P:Antlr4.Runtime.Atn.LexerTypeAction.Type"/>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred">
            <summary>
            Special value added to the lookahead sets to indicate that we hit
            a predicate during analysis if
            <c>seeThruPreds==false</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.GetDecisionLookahead(Antlr4.Runtime.Atn.ATNState)">
            <summary>
            Calculates the SLL(1) expected lookahead set for each outgoing transition
            of an
            <see cref="T:Antlr4.Runtime.Atn.ATNState"/>
            . The returned array has one element for each
            outgoing transition in
            <paramref name="s"/>
            . If the closure from transition
            <em>i</em> leads to a semantic predicate before matching a symbol, the
            element at index <em>i</em> of the result will be
            <see langword="null"/>
            .
            </summary>
            <param name="s">the ATN state</param>
            <returns>
            the expected symbols for each outgoing transition of
            <paramref name="s"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.RuleContext)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p>If
            <paramref name="ctx"/>
            is
            <see langword="null"/>
            and the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
            is added to the result set.
            If
            <paramref name="ctx"/>
            is not
            <see langword="null"/>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="ctx">
            the complete parser context, or
            <see langword="null"/>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.RuleContext)">
            <summary>
            Compute set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            <p>If
            <paramref name="ctx"/>
            is
            <see langword="null"/>
            and the end of the rule containing
            <paramref name="s"/>
            is reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
            is added to the result set.
            If
            <paramref name="ctx"/>
            is not
            <c>PredictionContext#EMPTY_LOCAL</c>
            and the end of the outermost rule is
            reached,
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            is added to the result set.</p>
            </summary>
            <param name="s">the ATN state</param>
            <param name="stopState">
            the ATN state to stop at. This can be a
            <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
            to detect epsilon paths through a closure.
            </param>
            <param name="ctx">
            the complete parser context, or
            <see langword="null"/>
            if the context
            should be ignored
            </param>
            <returns>
            The set of tokens that can follow
            <paramref name="s"/>
            in the ATN in the
            specified
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LL1Analyzer.Look(Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.ATNState,Antlr4.Runtime.Atn.PredictionContext,Antlr4.Runtime.Misc.IntervalSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},Antlr4.Runtime.Sharpen.BitSet,System.Boolean,System.Boolean)">
             <summary>
             Compute set of tokens that can follow
             <paramref name="s"/>
             in the ATN in the
             specified
             <paramref name="ctx"/>
             .
             <p/>
             If
             <paramref name="ctx"/>
             is
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             and
             <paramref name="stopState"/>
             or the end of the rule containing
             <paramref name="s"/>
             is reached,
             <see cref="F:Antlr4.Runtime.TokenConstants.EPSILON"/>
             is added to the result set. If
             <paramref name="ctx"/>
             is not
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             and
             <paramref name="addEOF"/>
             is
             <see langword="true"/>
             and
             <paramref name="stopState"/>
             or the end of the outermost rule is reached,
             <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
             is added to the result set.
             </summary>
             <param name="s">the ATN state.</param>
             <param name="stopState">
             the ATN state to stop at. This can be a
             <see cref="T:Antlr4.Runtime.Atn.BlockEndState"/>
             to detect epsilon paths through a closure.
             </param>
             <param name="ctx">
             The outer context, or
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             if
             the outer context should not be used.
             </param>
             <param name="look">The result lookahead set.</param>
             <param name="lookBusy">
             A set used for preventing epsilon closures in the ATN
             from causing a stack overflow. Outside code should pass
             <c>new HashSet&lt;ATNConfig&gt;</c>
             for this argument.
             </param>
             <param name="calledRuleStack">
             A set used for preventing left recursion in the
             ATN from causing a stack overflow. Outside code should pass
             <c>new BitSet()</c>
             for this argument.
             </param>
             <param name="seeThruPreds">
            
             <see langword="true"/>
             to true semantic predicates as
             implicitly
             <see langword="true"/>
             and "see through them", otherwise
             <see langword="false"/>
             to treat semantic predicates as opaque and add
             <see cref="F:Antlr4.Runtime.Atn.LL1Analyzer.HitPred"/>
             to the
             result if one is encountered.
             </param>
             <param name="addEOF">
             Add
             <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
             to the result if the end of the
             outermost context is reached. This parameter has no effect if
             <paramref name="ctx"/>
             is
             <see cref="F:Antlr4.Runtime.Atn.PredictionContext.EMPTY"/>
             .
             </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LookaheadEventInfo">
            <summary>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </summary>
            <remarks>
            This class represents profiling event information for tracking the lookahead
            depth required in order to make a prediction.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Atn.LookaheadEventInfo.#ctor(System.Int32,Antlr4.Runtime.Atn.SimulatorState,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,System.Boolean)">
             <summary>
             Constructs a new instance of the
             <see cref="T:Antlr4.Runtime.Atn.LookaheadEventInfo"/>
             class with
             the specified detailed lookahead information.
             </summary>
             <param name="decision">The decision number</param>
             <param name="state">
             The final simulator state containing the necessary
             information to determine the result of a prediction, or
             <see langword="null"/>
             if
             the final state is not available
             </param>
             <param name="input">The input token stream</param>
             <param name="startIndex">The start index for the current prediction</param>
             <param name="stopIndex">The index at which the prediction was finally made</param>
             <param name="fullCtx">
            
             <see langword="true"/>
             if the current lookahead is part of an LL
             prediction; otherwise,
             <see langword="false"/>
             if the current lookahead is part of
             an SLL prediction
             </param>
        </member>
        <member name="T:Antlr4.Runtime.Atn.LoopEndState">
            <summary>Mark the end of a * or + loop.</summary>
            <remarks>Mark the end of a * or + loop.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParseInfo">
             This class provides access to specific and aggregate statistics gathered
             during profiling of a parser.
            
             @since 4.3
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getDecisionInfo">
             Gets an array of {@link DecisionInfo} instances containing the profiling
             information gathered for each decision in the ATN.
            
             @return An array of {@link DecisionInfo} instances, indexed by decision
             number.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getLLDecisions">
             Gets the decision numbers for decisions that required one or more
             full-context predictions during parsing. These are decisions for which
             {@link DecisionInfo#LL_Fallback} is non-zero.
            
             @return A list of decision numbers which required one or more
             full-context predictions during parsing.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalTimeInPrediction">
            Gets the total time spent during prediction across all decisions made
            during parsing. This value is the sum of
            {@link DecisionInfo#timeInPrediction} for all decisions.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalSLLLookaheadOps">
            Gets the total number of SLL lookahead operations across all decisions
            made during parsing. This value is the sum of
            {@link DecisionInfo#SLL_TotalLook} for all decisions.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalLLLookaheadOps">
            Gets the total number of LL lookahead operations across all decisions
            made during parsing. This value is the sum of
            {@link DecisionInfo#LL_TotalLook} for all decisions.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalSLLATNLookaheadOps">
            Gets the total number of ATN lookahead operations for SLL prediction
            across all decisions made during parsing.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalLLATNLookaheadOps">
            Gets the total number of ATN lookahead operations for LL prediction
            across all decisions made during parsing.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getTotalATNLookaheadOps">
             Gets the total number of ATN lookahead operations for SLL and LL
             prediction across all decisions made during parsing.
            
             <p>
             This value is the sum of {@link #getTotalSLLATNLookaheadOps} and
             {@link #getTotalLLATNLookaheadOps}.</p>
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getDFASize">
            Gets the total number of DFA states stored in the DFA cache for all
            decisions in the ATN.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParseInfo.getDFASize(System.Int32)">
            Gets the total number of DFA states stored in the DFA cache for a
            particular decision.
        </member>
        <member name="T:Antlr4.Runtime.Atn.ParserATNSimulator">
             The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
            
             <p>
             The basic complexity of the adaptive strategy makes it harder to understand.
             We begin with ATN simulation to build paths in a DFA. Subsequent prediction
             requests go through the DFA first. If they reach a state without an edge for
             the current symbol, the algorithm fails over to the ATN simulation to
             complete the DFA path for the current input (until it finds a conflict state
             or uniquely predicting state).</p>
            
             <p>
             All of that is done without using the outer context because we want to create
             a DFA that is not dependent upon the rule invocation stack when we do a
             prediction. One DFA works in all contexts. We avoid using context not
             necessarily because it's slower, although it can be, but because of the DFA
             caching problem. The closure routine only considers the rule invocation stack
             created during prediction beginning in the decision rule. For example, if
             prediction occurs without invoking another rule's ATN, there are no context
             stacks in the configurations. When lack of context leads to a conflict, we
             don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
             strategy (versus full LL(*)).</p>
            
             <p>
             When SLL yields a configuration set with conflict, we rewind the input and
             retry the ATN simulation, this time using full outer context without adding
             to the DFA. Configuration context stacks will be the full invocation stacks
             from the start rule. If we get a conflict using full context, then we can
             definitively say we have a true ambiguity for that input sequence. If we
             don't get a conflict, it implies that the decision is sensitive to the outer
             context. (It is not context-sensitive in the sense of context-sensitive
             grammars.)</p>
            
             <p>
             The next time we reach this DFA state with an SLL conflict, through DFA
             simulation, we will again retry the ATN simulation using full context mode.
             This is slow because we can't save the results and have to "interpret" the
             ATN each time we get that input.</p>
            
             <p>
             <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
            
             <p>
             We could cache results from full context to predicted alternative easily and
             that saves a lot of time but doesn't work in presence of predicates. The set
             of visible predicates from the ATN start state changes depending on the
             context, because closure can fall off the end of a rule. I tried to cache
             tuples (stack context, semantic context, predicted alt) but it was slower
             than interpreting and much more complicated. Also required a huge amount of
             memory. The goal is not to create the world's fastest parser anyway. I'd like
             to keep this algorithm simple. By launching multiple threads, we can improve
             the speed of parsing across a large number of files.</p>
            
             <p>
             There is no strict ordering between the amount of input used by SLL vs LL,
             which makes it really hard to build a cache for full context. Let's say that
             we have input A B C that leads to an SLL conflict with full context X. That
             implies that using X we might only use A B but we could also use A B C D to
             resolve conflict. Input A B C D could predict alternative 1 in one position
             in the input and A B C E could predict alternative 2 in another position in
             input. The conflicting SLL configurations could still be non-unique in the
             full context prediction, which would lead us to requiring more input than the
             original A B C.	To make a	prediction cache work, we have to track	the exact
             input	used during the previous prediction. That amounts to a cache that maps
             X to a specific DFA for that context.</p>
            
             <p>
             Something should be done for left-recursive expression predictions. They are
             likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
             with full LL thing Sam does.</p>
            
             <p>
             <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
            
             <p>
             We avoid doing full context retry when the outer context is empty, we did not
             dip into the outer context by falling off the end of the decision state rule,
             or when we force SLL mode.</p>
            
             <p>
             As an example of the not dip into outer context case, consider as super
             constructor calls versus function calls. One grammar might look like
             this:</p>
            
             <pre>
             ctorBody
               : '{' superCall? stat* '}'
               ;
             </pre>
            
             <p>
             Or, you might see something like</p>
            
             <pre>
             stat
               : superCall ';'
               | expression ';'
               | ...
               ;
             </pre>
            
             <p>
             In both cases I believe that no closure operations will dip into the outer
             context. In the first case ctorBody in the worst case will stop at the '}'.
             In the 2nd case it should stop at the ';'. Both cases should stay within the
             entry rule and not dip into the outer context.</p>
            
             <p>
             <strong>PREDICATES</strong></p>
            
             <p>
             Predicates are always evaluated if present in either SLL or LL both. SLL and
             LL simulation deals with predicates differently. SLL collects predicates as
             it performs closure operations like ANTLR v3 did. It delays predicate
             evaluation until it reaches and accept state. This allows us to cache the SLL
             ATN simulation whereas, if we had evaluated predicates on-the-fly during
             closure, the DFA state configuration sets would be different and we couldn't
             build up a suitable DFA.</p>
            
             <p>
             When building a DFA accept state during ATN simulation, we evaluate any
             predicates and return the sole semantically valid alternative. If there is
             more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
             we throw an exception. Alternatives without predicates act like they have
             true predicates. The simple way to think about it is to strip away all
             alternatives with false predicates and choose the minimum alternative that
             remains.</p>
            
             <p>
             When we start in the DFA and reach an accept state that's predicated, we test
             those and return the minimum semantically viable alternative. If no
             alternatives are viable, we throw an exception.</p>
            
             <p>
             During full LL ATN simulation, closure always evaluates predicates and
             on-the-fly. This is crucial to reducing the configuration set size during
             closure. It hits a landmine when parsing with the Java grammar, for example,
             without this on-the-fly evaluation.</p>
            
             <p>
             <strong>SHARING DFA</strong></p>
            
             <p>
             All instances of the same parser share the same decision DFAs through a
             static field. Each instance gets its own ATN simulator but they share the
             same {@link #decisionToDFA} field. They also share a
             {@link PredictionContextCache} object that makes sure that all
             {@link PredictionContext} objects are shared among the DFA states. This makes
             a big size difference.</p>
            
             <p>
             <strong>THREAD SAFETY</strong></p>
            
             <p>
             The {@link ParserATNSimulator} locks on the {@link #decisionToDFA} field when
             it adds a new DFA object to that array. {@link #addDFAEdge}
             locks on the DFA for the current decision when setting the
             {@link DFAState#edges} field. {@link #addDFAState} locks on
             the DFA for the current decision when looking up a DFA state to see if it
             already exists. We must make sure that all requests to add DFA states that
             are equivalent result in the same shared DFA object. This is because lots of
             threads will be trying to update the DFA at once. The
             {@link #addDFAState} method also locks inside the DFA lock
             but this time on the shared context cache when it rebuilds the
             configurations' {@link PredictionContext} objects using cached
             subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
             safe as long as we can guarantee that all threads referencing
             {@code s.edge[t]} get the same physical target {@link DFAState}, or
             {@code null}. Once into the DFA, the DFA simulation does not reference the
             {@link DFA#states} map. It follows the {@link DFAState#edges} field to new
             targets. The DFA simulator will either find {@link DFAState#edges} to be
             {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
             {@code dfa.edges[t]} to be non-null. The
             {@link #addDFAEdge} method could be racing to set the field
             but in either case the DFA simulator works; if {@code null}, and requests ATN
             simulation. It could also race trying to get {@code dfa.edges[t]}, but either
             way it will work because it's not doing a test and set operation.</p>
            
             <p>
             <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
             Parsing)</strong></p>
            
             <p>
             Sam pointed out that if SLL does not give a syntax error, then there is no
             point in doing full LL, which is slower. We only have to try LL if we get a
             syntax error. For maximum speed, Sam starts the parser set to pure SLL
             mode with the {@link BailErrorStrategy}:</p>
            
             <pre>
             parser.{@link Parser#getInterpreter() getInterpreter()}.{@link #setPredictionMode setPredictionMode}{@code (}{@link PredictionMode#SLL}{@code )};
             parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
             </pre>
            
             <p>
             If it does not get a syntax error, then we're done. If it does get a syntax
             error, we need to retry with the combined SLL/LL strategy.</p>
            
             <p>
             The reason this works is as follows. If there are no SLL conflicts, then the
             grammar is SLL (at least for that input set). If there is an SLL conflict,
             the full LL analysis must yield a set of viable alternatives which is a
             subset of the alternatives reported by SLL. If the LL set is a singleton,
             then the grammar is LL but not SLL. If the LL set is the same size as the SLL
             set, the decision is SLL. If the LL set has size &gt; 1, then that decision
             is truly ambiguous on the current input. If the LL set is smaller, then the
             SLL conflict resolution might choose an alternative that the full LL would
             rule out as a possibility based upon better context information. If that's
             the case, then the SLL parse will definitely get an error because the full LL
             analysis says it's not viable. If SLL conflict resolution chooses an
             alternative within the LL set, them both SLL and LL would choose the same
             alternative because they both choose the minimum of multiple conflicting
             alternatives.</p>
            
             <p>
             Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
             a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
             parsing will get an error because SLL will pursue alternative 1. If
             <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
             choose the same alternative because alternative one is the minimum of either
             set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
             error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
            
             <p>
             Of course, if the input is invalid, then we will get an error for sure in
             both SLL and LL parsing. Erroneous input will therefore require 2 passes over
             the input.</p>
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.mode">
            SLL, LL, or LL + exact ambig detection? 
        </member>
        <member name="F:Antlr4.Runtime.Atn.ParserATNSimulator.mergeCache">
            Each prediction operation uses a cache for merge of prediction contexts.
            Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
            isn't synchronized but we're ok since two threads shouldn't reuse same
            parser/atnsim object because it can only handle one input at a time.
            This maps graphs a and b to merged result c. (a,b)?c. We can avoid
            the merge if we ever see a and b again.  Note that (b,a)?c should
            also be examined during cache lookup.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.#ctor(Antlr4.Runtime.Atn.ATN,Antlr4.Runtime.Dfa.DFA[],Antlr4.Runtime.Atn.PredictionContextCache)">
            Testing only! 
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ExecATN(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,Antlr4.Runtime.ITokenStream,System.Int32,Antlr4.Runtime.ParserRuleContext)">
            Performs ATN simulation to compute a predicted alternative based
            		 *  upon the remaining input, but also updates the DFA cache to avoid
            		 *  having to traverse the ATN again for the same input sequence.
            
            		 There are some key conditions we're looking for after computing a new
            		 set of ATN configs (proposed DFA state):
            			   * if the set is empty, there is no viable alternative for current symbol
            			   * does the state uniquely predict an alternative?
            			   * does the state have a conflict that would prevent us from
            				 putting it on the work list?
            
            		 We also have some key operations to do:
            			   * add an edge from previous DFA state to potentially new DFA state, D,
            				 upon current symbol but only if adding to work list, which means in all
            				 cases except no viable alternative (and possibly non-greedy decisions?)
            			   * collecting predicates and adding semantic context to DFA accept states
            			   * adding rule context to context-sensitive DFA accept states
            			   * consuming an input symbol
            			   * reporting a conflict
            			   * reporting an ambiguity
            			   * reporting a context sensitivity
            			   * reporting insufficient predicates
            
            		 cover these cases:
            			dead end
            			single alt
            			single alt + preds
            			conflict
            			conflict + preds
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetExistingTargetState(Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Get an existing target state for an edge in the DFA. If the target state
             for the edge has not yet been computed or is otherwise not available,
             this method returns {@code null}.
            
             @param previousD The current DFA state
             @param t The next input symbol
             @return The existing target DFA state for the given input symbol
             {@code t}, or {@code null} if the target state for this edge is not
             already cached
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ComputeTargetState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32)">
             Compute a target state for an edge in the DFA, and attempt to add the
             computed state and corresponding edge to the DFA.
            
             @param dfa The DFA
             @param previousD The current DFA state
             @param t The next input symbol
            
             @return The computed target DFA state for the given input symbol
             {@code t}. If {@code t} does not lead to a valid DFA state, this method
             returns {@link #ERROR}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.RemoveAllConfigsNotInRuleStopState(Antlr4.Runtime.Atn.ATNConfigSet,System.Boolean)">
             Return a configuration set containing only the configurations from
             {@code configs} which are in a {@link RuleStopState}. If all
             configurations in {@code configs} are already in a rule stop state, this
             method simply returns {@code configs}.
            
             <p>When {@code lookToEndOfRule} is true, this method uses
             {@link ATN#nextTokens} for each configuration in {@code configs} which is
             not already in a rule stop state to see if a rule stop state is reachable
             from the configuration via epsilon-only transitions.</p>
            
             @param configs the configuration set to update
             @param lookToEndOfRule when true, this method checks for rule stop states
             reachable by epsilon-only transitions from each configuration in
             {@code configs}.
            
             @return {@code configs} if all configurations in {@code configs} are in a
             rule stop state, otherwise return a new configuration set containing only
             the configurations from {@code configs} which are in a rule stop state
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ApplyPrecedenceFilter(Antlr4.Runtime.Atn.ATNConfigSet)">
             This method transforms the start state computed by
             {@link #computeStartState} to the special start state used by a
             precedence DFA for a particular precedence value. The transformation
             process applies the following changes to the start state's configuration
             set.
            
             <ol>
             <li>Evaluate the precedence predicates for each configuration using
             {@link SemanticContext#evalPrecedence}.</li>
             <li>When {@link ATNConfig#isPrecedenceFilterSuppressed} is {@code false},
             remove all configurations which predict an alternative greater than 1,
             for which another configuration that predicts alternative 1 is in the
             same ATN state with the same prediction context. This transformation is
             valid for the following reasons:
             <ul>
             <li>The closure block cannot contain any epsilon transitions which bypass
             the body of the closure, so all states reachable via alternative 1 are
             part of the precedence alternatives of the transformed left-recursive
             rule.</li>
             <li>The "primary" portion of a left recursive rule cannot contain an
             epsilon transition, so the only way an alternative other than 1 can exist
             in a state that is also reachable via alternative 1 is by nesting calls
             to the left-recursive rule, with the outer calls not being at the
             preferred precedence level. The
             {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN
             configurations which do not meet this condition, and therefore are not
             eligible for elimination during the filtering process.</li>
             </ul>
             </li>
             </ol>
            
             <p>
             The prediction context must be considered by this filter to address
             situations like the following.
             </p>
             <code>
             <pre>
             grammar TA;
             prog: statement* EOF;
             statement: letterA | statement letterA 'b' ;
             letterA: 'a';
             </pre>
             </code>
             <p>
             If the above grammar, the ATN state immediately before the token
             reference {@code 'a'} in {@code letterA} is reachable from the left edge
             of both the primary and closure blocks of the left-recursive rule
             {@code statement}. The prediction context associated with each of these
             configurations distinguishes between them, and prevents the alternative
             which stepped out to {@code prog} (and then back in to {@code statement}
             from being eliminated by the filter.
             </p>
            
             @param configs The configuration set computed by
             {@link #computeStartState} as the start state for the DFA.
             @return The transformed configuration set representing the start state
             for a precedence DFA at a particular precedence level (determined by
             calling {@link Parser#getPrecedence}).
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext)">
             This method is used to improve the localization of error messages by
             choosing an alternative rather than throwing a
             {@link NoViableAltException} in particular prediction scenarios where the
             {@link #ERROR} state was reached during ATN simulation.
            
             <p>
             The default implementation of this method uses the following
             algorithm to identify an ATN configuration which successfully parsed the
             decision entry rule. Choosing such an alternative ensures that the
             {@link ParserRuleContext} returned by the calling rule will be complete
             and valid, and the syntax error will be reported later at a more
             localized location.</p>
            
             <ul>
             <li>If a syntactically valid path or paths reach the end of the decision rule and
             they are semantically valid if predicated, return the min associated alt.</li>
             <li>Else, if a semantically invalid but syntactically valid path exist
             or paths exist, return the minimum associated alt.
             </li>
             <li>Otherwise, return {@link ATN#INVALID_ALT_NUMBER}.</li>
             </ul>
            
             <p>
             In some scenarios, the algorithm described above could predict an
             alternative which will result in a {@link FailedPredicateException} in
             the parser. Specifically, this could occur if the <em>only</em> configuration
             capable of successfully parsing to the end of the decision rule is
             blocked by a semantic predicate. By choosing this alternative within
             {@link #adaptivePredict} instead of throwing a
             {@link NoViableAltException}, the resulting
             {@link FailedPredicateException} in the parser will identify the specific
             predicate which is preventing the parser from successfully parsing the
             decision rule, which helps developers identify and correct logic errors
             in semantic predicates.
             </p>
            
             @param configs The ATN configurations which were valid immediately before
             the {@link #ERROR} state was reached
             @param outerContext The is the \gamma_0 initial parser context from the paper
             or the parser stack at the instant before prediction commences.
            
             @return The value to return from {@link #adaptivePredict}, or
             {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not
             identified and {@link #adaptivePredict} should report an error instead.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.SplitAccordingToSemanticValidity(Antlr4.Runtime.Atn.ATNConfigSet,Antlr4.Runtime.ParserRuleContext)">
            Walk the list of configurations and split them according to
              those that have preds evaluating to true/false.  If no pred, assume
              true pred and include in succeeded set.  Returns Pair of sets.
            
              Create a new set so as not to alter the incoming parameter.
            
              Assumption: the input stream has been restored to the starting point
              prediction, which is where predicates need to evaluate.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)">
            Look through a list of predicate/alt pairs, returning alts for the
            pairs that win. A {@code NONE} predicate indicates an alt containing an
            unpredicated config which behaves as "always true." If !complete
            then we stop at the first predicate that evaluates to true. This
            includes pairs with null predicates.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean)">
             Evaluate a semantic context within a specific parser context.
            
             <p>
             This method might not be called for every semantic context evaluated
             during the prediction process. In particular, we currently do not
             evaluate the following but it may change in the future:</p>
            
             <ul>
             <li>Precedence predicates (represented by
             {@link SemanticContext.PrecedencePredicate}) are not currently evaluated
             through this method.</li>
             <li>Operator predicates (represented by {@link SemanticContext.AND} and
             {@link SemanticContext.OR}) are evaluated as a single semantic
             context, rather than evaluating the operands individually.
             Implementations which require evaluation results from individual
             predicates should override this method to explicitly handle evaluation of
             the operands within operator predicates.</li>
             </ul>
            
             @param pred The semantic context to evaluate
             @param parserCallStack The parser context in which to evaluate the
             semantic context
             @param alt The alternative which is guarded by {@code pred}
             @param fullCtx {@code true} if the evaluation is occurring during LL
             prediction; otherwise, {@code false} if the evaluation is occurring
             during SLL prediction
            
             @since 4.3
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.Closure_(Antlr4.Runtime.Atn.ATNConfig,Antlr4.Runtime.Atn.ATNConfigSet,System.Collections.Generic.HashSet{Antlr4.Runtime.Atn.ATNConfig},System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            Do the actual work of walking epsilon edges 
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.CanDropLoopEntryEdgeInLeftRecursiveRule(Antlr4.Runtime.Atn.ATNConfig)">
            Implements first-edge (loop entry) elimination as an optimization
              during closure operations.  See antlr/antlr4#1398.
            
             The optimization is to avoid adding the loop entry config when
             the exit path can only lead back to the same
             StarLoopEntryState after popping context at the rule end state
             (traversing only epsilon edges, so we're still in closure, in
             this same rule).
            
             We need to detect any state that can reach loop entry on
             epsilon w/o exiting rule. We don't have to look at FOLLOW
             links, just ensure that all stack tops for config refer to key
             states in LR rule.
            
             To verify we are in the right situation we must first check
             closure is at a StarLoopEntryState generated during LR removal.
             Then we check that each stack top of context is a return state
             from one of these cases:
            
               1. 'not' expr, '(' type ')' expr. The return state points at loop entry state
               2. expr op expr. The return state is the block end of internal block of (...)*
               3. 'between' expr 'and' expr. The return state of 2nd expr reference.
                  That state points at block end of internal block of (...)*.
               4. expr '?' expr ':' expr. The return state points at block end,
                  which points at loop entry state.
            
             If any is true for each stack top, then closure does not add a
             config to the current config set for edge[0], the loop entry branch.
            
              Conditions fail if any context for the current config is:
            
               a. empty (we'd fall out of expr to do a global FOLLOW which could
                  even be to some weird spot in expr) or,
               b. lies outside of expr or,
               c. lies within expr but at a state not the BlockEndState
               generated during LR removal
            
             Do we need to evaluate predicates ever in closure for this case?
            
             No. Predicates, including precedence predicates, are only
             evaluated when computing a DFA start state. I.e., only before
             the lookahead (but not parser) consumes a token.
            
             There are no epsilon edges allowed in LR rule alt blocks or in
             the "primary" part (ID here). If closure is in
             StarLoopEntryState any lookahead operation will have consumed a
             token as there are no epsilon-paths that lead to
             StarLoopEntryState. We do not have to evaluate predicates
             therefore if we are in the generated StarLoopEntryState of a LR
             rule. Note that when making a prediction starting at that
             decision point, decision d=2, compute-start-state performs
             closure starting at edges[0], edges[1] emanating from
             StarLoopEntryState. That means it is not performing closure on
             StarLoopEntryState during compute-start-state.
            
             How do we know this always gives same prediction answer?
            
             Without predicates, loop entry and exit paths are ambiguous
             upon remaining input +b (in, say, a+b). Either paths lead to
             valid parses. Closure can lead to consuming + immediately or by
             falling out of this call to expr back into expr and loop back
             again to StarLoopEntryState to match +b. In this special case,
             we choose the more efficient path, which is to take the bypass
             path.
            
             The lookahead language has not changed because closure chooses
             one path over the other. Both paths lead to consuming the same
             remaining input during a lookahead operation. If the next token
             is an operator, lookahead will enter the choice block with
             operators. If it is not, lookahead will exit expr. Same as if
             closure had chosen to enter the choice block immediately.
            
             Closure is examining one config (some loopentrystate, some alt,
             context) which means it is considering exactly one alt. Closure
             always copies the same alt to any derived configs.
            
             How do we know this optimization doesn't mess up precedence in
             our parse trees?
            
             Looking through expr from left edge of stat only has to confirm
             that an input, say, a+b+c; begins with any valid interpretation
             of an expression. The precedence actually doesn't matter when
             making a decision in stat seeing through expr. It is only when
             parsing rule expr that we must use the precedence to get the
             right interpretation and, hence, parse tree.
            
             @since 4.6
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetConflictingAlts(Antlr4.Runtime.Atn.ATNConfigSet)">
             Gets a {@link BitSet} containing the alternatives in {@code configs}
             which are part of one or more conflicting alternative subsets.
            
             @param configs The {@link ATNConfigSet} to analyze.
             @return The alternatives in {@code configs} which are part of one or more
             conflicting alternative subsets. If {@code configs} does not contain any
             conflicting subsets, this method returns an empty {@link BitSet}.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.GetConflictingAltsOrUniqueAlt(Antlr4.Runtime.Atn.ATNConfigSet)">
            		 Sam pointed out a problem with the previous definition, v3, of
            		 ambiguous states. If we have another state associated with conflicting
            		 alternatives, we should keep going. For example, the following grammar
            
            		 s : (ID | ID ID?) ';' ;
            
            		 When the ATN simulation reaches the state before ';', it has a DFA
            		 state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
            		 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
            		 because alternative to has another way to continue, via [6|2|[]].
            		 The key is that we have a single state that has config's only associated
            		 with a single alternative, 2, and crucially the state transitions
            		 among the configurations are all non-epsilon transitions. That means
            		 we don't consider any conflicts that include alternative 2. So, we
            		 ignore the conflict between alts 1 and 2. We ignore a set of
            		 conflicting alts when there is an intersection with an alternative
            		 associated with a single alt state in the state?config-list map.
            
            		 It's also the case that we might have two conflicting configurations but
            		 also a 3rd nonconflicting configuration for a different alternative:
            		 [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
            
            		 a : A | A | A B ;
            
            		 After matching input A, we reach the stop state for rule A, state 1.
            		 State 8 is the state right before B. Clearly alternatives 1 and 2
            		 conflict and no amount of further lookahead will separate the two.
            		 However, alternative 3 will be able to continue and so we do not
            		 stop working on this state. In the previous example, we're concerned
            		 with states associated with the conflicting alternatives. Here alt
            		 3 is not associated with the conflicting configs, but since we can continue
            		 looking for input reasonably, I don't declare the state done. We
            		 ignore a set of conflicting alts when we have an alternative
            		 that we still need to pursue.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.DumpDeadEndConfigs(Antlr4.Runtime.NoViableAltException)">
            Used for debugging in adaptivePredict around execATN but I cut
            it out for clarity now that alg. works well. We can leave this
            "dead" code for a bit.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAEdge(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,Antlr4.Runtime.Dfa.DFAState)">
             Add an edge to the DFA, if possible. This method calls
             {@link #addDFAState} to ensure the {@code to} state is present in the
             DFA. If {@code from} is {@code null}, or if {@code t} is outside the
             range of edges that can be represented in the DFA tables, this method
             returns without adding the edge to the DFA.
            
             <p>If {@code to} is {@code null}, this method returns {@code null}.
             Otherwise, this method returns the {@link DFAState} returned by calling
             {@link #addDFAState} for the {@code to} state.</p>
            
             @param dfa The DFA
             @param from The source state for the edge
             @param t The input symbol
             @param to The target state for the edge
            
             @return If {@code to} is {@code null}, this method returns {@code null};
             otherwise this method returns the result of calling {@link #addDFAState}
             on {@code to}
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.AddDFAState(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState)">
             Add state {@code D} to the DFA if it is not already present, and return
             the actual instance stored in the DFA. If a state equivalent to {@code D}
             is already in the DFA, the existing state is returned. Otherwise this
             method returns {@code D} after adding it to the DFA.
            
             <p>If {@code D} is {@link #ERROR}, this method returns {@link #ERROR} and
             does not change the DFA.</p>
            
             @param dfa The dfa
             @param D The DFA state to add
             @return The state stored in the DFA. This will be either the existing
             state if {@code D} is already in the DFA, or {@code D} itself if the
             state was not already present.
        </member>
        <member name="M:Antlr4.Runtime.Atn.ParserATNSimulator.ReportAmbiguity(Antlr4.Runtime.Dfa.DFA,Antlr4.Runtime.Dfa.DFAState,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            If context sensitive parsing, we know it's ambiguity not conflict 
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusBlockStartState">
            <summary>
            Start of
            <c>(A|B|...)+</c>
            loop. Technically a decision state, but
            we don't use for code generation; somebody might need it, so I'm defining
            it for completeness. In reality, the
            <see cref="T:Antlr4.Runtime.Atn.PlusLoopbackState"/>
            node is the
            real decision-making note for
            <c>A+</c>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PlusLoopbackState">
            <summary>
            Decision state for
            <c>A+</c>
            and
            <c>(A|B)+</c>
            .  It has two transitions:
            one to the loop back to start of the block and one to exit.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PrecedencePredicateTransition">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateEvalInfo">
            <summary>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </summary>
            <remarks>
            This class represents profiling event information for semantic predicate
            evaluations which occur during prediction.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Dfa.PredPrediction[],Antlr4.Runtime.ParserRuleContext,System.Boolean)"/>
            <since>4.3</since>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx">
            <summary>The semantic context which was evaluated.</summary>
            <remarks>The semantic context which was evaluated.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt">
            <summary>
            The alternative number for the decision which is guarded by the semantic
            context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            . Note that other ATN
            configurations may predict the same alternative which are guarded by
            other semantic contexts and/or
            <see cref="F:Antlr4.Runtime.Atn.SemanticContext.NONE"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredicateEvalInfo.evalResult">
            <summary>
            The result of evaluating the semantic context
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.semctx"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredicateEvalInfo.#ctor(Antlr4.Runtime.Atn.SimulatorState,System.Int32,Antlr4.Runtime.ITokenStream,System.Int32,System.Int32,Antlr4.Runtime.Atn.SemanticContext,System.Boolean,System.Int32)">
            <summary>
            Constructs a new instance of the
            <see cref="T:Antlr4.Runtime.Atn.PredicateEvalInfo"/>
            class with the
            specified detailed predicate evaluation information.
            </summary>
            <param name="state">The simulator state</param>
            <param name="decision">The decision number</param>
            <param name="input">The input token stream</param>
            <param name="startIndex">The start index for the current prediction</param>
            <param name="stopIndex">
            The index at which the predicate evaluation was
            triggered. Note that the input stream may be reset to other positions for
            the actual evaluation of individual predicates.
            </param>
            <param name="semctx">The semantic context which was evaluated</param>
            <param name="evalResult">The results of evaluating the semantic context</param>
            <param name="predictedAlt">
            The alternative number for the decision which is
            guarded by the semantic context
            <paramref name="semctx"/>
            . See
            <see cref="F:Antlr4.Runtime.Atn.PredicateEvalInfo.predictedAlt"/>
            for more information.
            </param>
            <seealso cref="M:Antlr4.Runtime.Atn.ParserATNSimulator.EvalSemanticContext(Antlr4.Runtime.Atn.SemanticContext,Antlr4.Runtime.ParserRuleContext,System.Int32,System.Boolean)"/>
            <seealso cref="M:Antlr4.Runtime.Atn.SemanticContext.Eval``2(Antlr4.Runtime.Recognizer{``0,``1},Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredicateTransition">
            <summary>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            </summary>
            <remarks>
            TODO: this is old comment:
            A tree of semantic predicates from the grammar AST if label==SEMPRED.
            In the ATN, labels will always be exactly one predicate, but the DFA
            may have to combine a bunch of them as it collects predicates from
            multiple ATN configurations into a single DFA state.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionContextCache.Add(Antlr4.Runtime.Atn.PredictionContext)">
            Add a context to the cache and return it. If the context already exists,
            return that one instead and do not add a new context to the cache.
            Protect shared cache from unsafe thread access.
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode">
            <summary>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </summary>
            <remarks>
            This enumeration defines the prediction modes available in ANTLR 4 along with
            utility methods for analyzing configuration sets for conflicts and/or
            ambiguities.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.SLL">
            <summary>The SLL(*) prediction mode.</summary>
            <remarks>
            The SLL(*) prediction mode. This prediction mode ignores the current
            parser context when making predictions. This is the fastest prediction
            mode, and provides correct results for many grammars. This prediction
            mode is more powerful than the prediction mode provided by ANTLR 3, but
            may result in syntax errors for grammar and input combinations which are
            not SLL.
            <p>
            When using this prediction mode, the parser will either return a correct
            parse tree (i.e. the same parse tree that would be returned with the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL"/>
            prediction mode), or it will report a syntax error. If a
            syntax error is encountered when using the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.SLL"/>
            prediction mode,
            it may be due to either an actual syntax error in the input or indicate
            that the particular combination of grammar and input requires the more
            powerful
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL"/>
            prediction abilities to complete successfully.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LL">
            <summary>The LL(*) prediction mode.</summary>
            <remarks>
            The LL(*) prediction mode. This prediction mode allows the current parser
            context to be used for resolving SLL conflicts that occur during
            prediction. This is the fastest prediction mode that guarantees correct
            parse results for all combinations of grammars with syntactically correct
            inputs.
            <p>
            When using this prediction mode, the parser will make correct decisions
            for all syntactically-correct grammar and input combinations. However, in
            cases where the grammar is truly ambiguous this prediction mode might not
            report a precise answer for <em>exactly which</em> alternatives are
            ambiguous.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION">
            <summary>The LL(*) prediction mode with exact ambiguity detection.</summary>
            <remarks>
            The LL(*) prediction mode with exact ambiguity detection. In addition to
            the correctness guarantees provided by the
            <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL"/>
            prediction mode,
            this prediction mode instructs the prediction algorithm to determine the
            complete and exact set of ambiguous alternatives for every ambiguous
            decision encountered while parsing.
            <p>
            This prediction mode may be used for diagnosing ambiguities during
            grammar development. Due to the performance overhead of calculating sets
            of ambiguous alternatives, this prediction mode should be avoided when
            the exact results are not necessary.</p>
            <p>
            This prediction mode does not provide any guarantees for prediction
            behavior for syntactically-incorrect inputs.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.PredictionMode.AltAndContextMap">
            <summary>A Map that uses just the state and the stack context as the key.</summary>
            <remarks>A Map that uses just the state and the stack context as the key.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AltAndContextConfigEqualityComparator.GetHashCode(Antlr4.Runtime.Atn.ATNConfig)">
            <summary>
            The hash code is only a function of the
            <see cref="F:Antlr4.Runtime.Atn.ATNState.stateNumber"/>
            and
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.context"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasSLLConflictTerminatingPrediction(Antlr4.Runtime.Atn.PredictionMode,Antlr4.Runtime.Atn.ATNConfigSet)">
             <summary>Computes the SLL prediction termination condition.</summary>
             <remarks>
             Computes the SLL prediction termination condition.
             <p>
             This method computes the SLL prediction termination condition for both of
             the following cases.</p>
             <ul>
             <li>The usual SLL+LL fallback upon SLL conflict</li>
             <li>Pure SLL without LL fallback</li>
             </ul>
             <p><strong>COMBINED SLL+LL PARSING</strong></p>
             <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
             ensured regardless of how the termination condition is computed by this
             method. Due to the substantially higher cost of LL prediction, the
             prediction should only fall back to LL when the additional lookahead
             cannot lead to a unique SLL prediction.</p>
             <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
             conflicting subsets should fall back to full LL, even if the
             configuration sets don't resolve to the same alternative (e.g.
             <c/>
            
             1,2}} and
             <c/>
            
             3,4}}. If there is at least one non-conflicting
             configuration, SLL could continue with the hopes that more lookahead will
             resolve via one of those non-conflicting configurations.</p>
             <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
             stops when it sees only conflicting configuration subsets. In contrast,
             full LL keeps going when there is uncertainty.</p>
             <p><strong>HEURISTIC</strong></p>
             <p>As a heuristic, we stop prediction when we see any conflicting subset
             unless we see a state that only has one alternative associated with it.
             The single-alt-state thing lets prediction continue upon rules like
             (otherwise, it would admit defeat too soon):</p>
             <p>
             <c>[12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;</c>
             </p>
             <p>When the ATN simulation reaches the state before
             <c>';'</c>
             , it has a
             DFA state that looks like:
             <c>[12|1|[], 6|2|[], 12|2|[]]</c>
             . Naturally
             <c>12|1|[]</c>
             and
             <c>12|2|[]</c>
             conflict, but we cannot stop
             processing this node because alternative to has another way to continue,
             via
             <c>[6|2|[]]</c>
             .</p>
             <p>It also let's us continue for this rule:</p>
             <p>
             <c>[1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;</c>
             </p>
             <p>After matching input A, we reach the stop state for rule A, state 1.
             State 8 is the state right before B. Clearly alternatives 1 and 2
             conflict and no amount of further lookahead will separate the two.
             However, alternative 3 will be able to continue and so we do not stop
             working on this state. In the previous example, we're concerned with
             states associated with the conflicting alternatives. Here alt 3 is not
             associated with the conflicting configs, but since we can continue
             looking for input reasonably, don't declare the state done.</p>
             <p><strong>PURE SLL PARSING</strong></p>
             <p>To handle pure SLL parsing, all we have to do is make sure that we
             combine stack contexts for configurations that differ only by semantic
             predicate. From there, we can do the usual SLL termination heuristic.</p>
             <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
             <p>SLL decisions don't evaluate predicates until after they reach DFA stop
             states because they need to create the DFA cache that works in all
             semantic situations. In contrast, full LL evaluates predicates collected
             during start state computation so it can ignore predicates thereafter.
             This means that SLL termination detection can totally ignore semantic
             predicates.</p>
             <p>Implementation-wise,
             <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
             combines stack contexts but not
             semantic predicate contexts so we might see two configurations like the
             following.</p>
             <p>
             <c/>
             (s, 1, x,
             ), (s, 1, x', {p})}</p>
             <p>Before testing these configurations against others, we have to merge
             <c>x</c>
             and
             <c>x'</c>
             (without modifying the existing configurations).
             For example, we test
             <c>(x+x')==x''</c>
             when looking for conflicts in
             the following configurations.</p>
             <p>
             <c/>
             (s, 1, x,
             ), (s, 1, x', {p}), (s, 2, x'', {})}</p>
             <p>If the configuration set has predicates (as indicated by
             <see cref="F:Antlr4.Runtime.Atn.ATNConfigSet.hasSemanticContext"/>
             ), this algorithm makes a copy of
             the configurations to strip out all of the predicates so that a standard
             <see cref="T:Antlr4.Runtime.Atn.ATNConfigSet"/>
             will merge everything ignoring predicates.</p>
             </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConfigInRuleStopState(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
             <summary>
             Checks if any configuration in
             <paramref name="configs"/>
             is in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             . Configurations meeting this condition have reached
             the end of the decision rule (local context) or end of start rule (full
             context).
             </summary>
             <param name="configs">the configuration set to test</param>
             <returns>
            
             <see langword="true"/>
             if any configuration in
             <paramref name="configs"/>
             is in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             , otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllConfigsInRuleStopStates(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
             <summary>
             Checks if all configurations in
             <paramref name="configs"/>
             are in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             . Configurations meeting this condition have reached
             the end of the decision rule (local context) or end of start rule (full
             context).
             </summary>
             <param name="configs">the configuration set to test</param>
             <returns>
            
             <see langword="true"/>
             if all configurations in
             <paramref name="configs"/>
             are in a
             <see cref="T:Antlr4.Runtime.Atn.RuleStopState"/>
             , otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.ResolvesToJustOneViableAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>Full LL prediction termination.</summary>
             <remarks>
             Full LL prediction termination.
             <p>Can we stop looking ahead during ATN simulation or is there some
             uncertainty as to which alternative we will ultimately pick, after
             consuming more input? Even if there are partial conflicts, we might know
             that everything is going to resolve to the same minimum alternative. That
             means we can stop since no more lookahead will change that fact. On the
             other hand, there might be multiple conflicts that resolve to different
             minimums. That means we need more look ahead to decide which of those
             alternatives we should predict.</p>
             <p>The basic idea is to split the set of configurations
             <c>C</c>
             , into
             conflicting subsets
             <c>(s, _, ctx, _)</c>
             and singleton subsets with
             non-conflicting configurations. Two configurations conflict if they have
             identical
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.state"/>
             and
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.context"/>
             values
             but different
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt"/>
             value, e.g.
             <c>(s, i, ctx, _)</c>
             and
             <c>(s, j, ctx, _)</c>
             for
             <c>i!=j</c>
             .</p>
             <p/>
             Reduce these configuration subsets to the set of possible alternatives.
             You can compute the alternative subsets in one pass as follows:
             <p/>
             <c/>
             A_s,ctx =
             i | (s, i, ctx, _)}} for each configuration in
             <c>C</c>
             holding
             <c>s</c>
             and
             <c>ctx</c>
             fixed.
             <p/>
             Or in pseudo-code, for each configuration
             <c>c</c>
             in
             <c>C</c>
             :
             <pre>
             map[c] U= c.
             <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt">getAlt()</see>
             # map hash/equals uses s and x, not
             alt and not pred
             </pre>
             <p>The values in
             <c>map</c>
             are the set of
             <c>A_s,ctx</c>
             sets.</p>
             <p>If
             <c>|A_s,ctx|=1</c>
             then there is no conflict associated with
             <c>s</c>
             and
             <c>ctx</c>
             .</p>
             <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
             the union of these alternative subsets is a singleton, then no amount of
             more lookahead will help us. We will always pick that alternative. If,
             however, there is more than one alternative, then we are uncertain which
             alternative to predict and must continue looking for resolution. We may
             or may not discover an ambiguity in the future, even if there are no
             conflicting subsets this round.</p>
             <p>The biggest sin is to terminate early because it means we've made a
             decision but were uncertain as to the eventual outcome. We haven't used
             enough lookahead. On the other hand, announcing a conflict too late is no
             big deal; you will still have the conflict. It's just inefficient. It
             might even look until the end of file.</p>
             <p>No special consideration for semantic predicates is required because
             predicates are evaluated on-the-fly for full LL prediction, ensuring that
             no configuration contains a semantic context during the termination
             check.</p>
             <p><strong>CONFLICTING CONFIGS</strong></p>
             <p>Two configurations
             <c>(s, i, x)</c>
             and
             <c>(s, j, x')</c>
             , conflict
             when
             <c>i!=j</c>
             but
             <c>x=x'</c>
             . Because we merge all
             <c>(s, i, _)</c>
             configurations together, that means that there are at
             most
             <c>n</c>
             configurations associated with state
             <c>s</c>
             for
             <c>n</c>
             possible alternatives in the decision. The merged stacks
             complicate the comparison of configuration contexts
             <c>x</c>
             and
             <c>x'</c>
             . Sam checks to see if one is a subset of the other by calling
             merge and checking to see if the merged result is either
             <c>x</c>
             or
             <c>x'</c>
             . If the
             <c>x</c>
             associated with lowest alternative
             <c>i</c>
             is the superset, then
             <c>i</c>
             is the only possible prediction since the
             others resolve to
             <c>min(i)</c>
             as well. However, if
             <c>x</c>
             is
             associated with
             <c>j&gt;i</c>
             then at least one stack configuration for
             <c>j</c>
             is not in conflict with alternative
             <c>i</c>
             . The algorithm
             should keep going, looking for more lookahead due to the uncertainty.</p>
             <p>For simplicity, I'm doing a equality check between
             <c>x</c>
             and
             <c>x'</c>
             that lets the algorithm continue to consume lookahead longer
             than necessary. The reason I like the equality is of course the
             simplicity but also because that is the test you need to detect the
             alternatives that are actually in conflict.</p>
             <p><strong>CONTINUE/STOP RULE</strong></p>
             <p>Continue if union of resolved alternative sets from non-conflicting and
             conflicting alternative subsets has more than one alternative. We are
             uncertain about which alternative to predict.</p>
             <p>The complete set of alternatives,
             <c>[i for (_,i,_)]</c>
             , tells us which
             alternatives are still in the running for the amount of input we've
             consumed at this point. The conflicting sets let us to strip away
             configurations that won't lead to more states because we resolve
             conflicts to the configuration with a minimum alternate for the
             conflicting set.</p>
             <p><strong>CASES</strong></p>
             <ul>
             <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s, 3, z)</c>
             ,
             <c>(s', 1, y)</c>
             ,
             <c>(s', 2, y)</c>
             yields non-conflicting set
             <c/>
            
             3}} U conflicting sets
             <c/>
             min(
             1,2})} U
             <c/>
             min(
             1,2})} =
             <c/>
            
             1,3}} =&gt; continue
             </li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 1, y)</c>
             ,
             <c>(s', 2, y)</c>
             ,
             <c>(s'', 1, z)</c>
             yields non-conflicting set
             <c/>
            
             1}} U conflicting sets
             <c/>
             min(
             1,2})} U
             <c/>
             min(
             1,2})} =
             <c/>
            
             1}} =&gt; stop and predict 1</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 1, y)</c>
             ,
             <c>(s', 2, y)</c>
             yields conflicting, reduced sets
             <c/>
            
             1}} U
             <c/>
            
             1}} =
             <c/>
            
             1}} =&gt; stop and predict 1, can announce
             ambiguity
             <c/>
            
             1,2}}</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 2, y)</c>
             ,
             <c>(s', 3, y)</c>
             yields conflicting, reduced sets
             <c/>
            
             1}} U
             <c/>
            
             2}} =
             <c/>
            
             1,2}} =&gt; continue</li>
             <li>
             <c>(s, 1, x)</c>
             ,
             <c>(s, 2, x)</c>
             ,
             <c>(s', 3, y)</c>
             ,
             <c>(s', 4, y)</c>
             yields conflicting, reduced sets
             <c/>
            
             1}} U
             <c/>
            
             3}} =
             <c/>
            
             1,3}} =&gt; continue</li>
             </ul>
             <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
             <p>If all states report the same conflicting set of alternatives, then we
             know we have the exact ambiguity set.</p>
             <p><code>|A_<em>i</em>|&gt;1</code> and
             <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
             <p>In other words, we continue examining lookahead until all
             <c>A_i</c>
             have more than one alternative and all
             <c>A_i</c>
             are the same. If
             <c/>
             A=
             {1,2}, {1,3}}}, then regular LL prediction would terminate
             because the resolved set is
             <c/>
            
             1}}. To determine what the real
             ambiguity is, we have to know whether the ambiguity is between one and
             two or one and three so we keep going. We can only stop prediction when
             we need exact ambiguity detection when the sets look like
             <c/>
             A=
             {1,2}}} or
             <c/>
            
             {1,2},{1,2}}}, etc...</p>
             </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsConflict(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if every alternative subset in
             <paramref name="altsets"/>
             contains more
             than one alternative.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if every
             <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
             in
             <paramref name="altsets"/>
             has
             <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
             &gt; 1, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasNonConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if any single alternative subset in
             <paramref name="altsets"/>
             contains
             exactly one alternative.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="altsets"/>
             contains a
             <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
             with
             <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
             1, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.HasConflictingAltSet(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if any single alternative subset in
             <paramref name="altsets"/>
             contains
             more than one alternative.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="altsets"/>
             contains a
             <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
             with
             <see cref="M:Antlr4.Runtime.Sharpen.BitSet.Cardinality">cardinality</see>
             &gt; 1, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.AllSubsetsEqual(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
             <summary>
             Determines if every alternative subset in
             <paramref name="altsets"/>
             is equivalent.
             </summary>
             <param name="altsets">a collection of alternative subsets</param>
             <returns>
            
             <see langword="true"/>
             if every member of
             <paramref name="altsets"/>
             is equal to the
             others, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetUniqueAlt(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Returns the unique alternative predicted by all alternative subsets in
            <paramref name="altsets"/>
            . If no such alternative exists, this method returns
            <see cref="F:Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER"/>
            .
            </summary>
            <param name="altsets">a collection of alternative subsets</param>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetAlts(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Sharpen.BitSet})">
            <summary>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets.
            </summary>
            <remarks>
            Gets the complete set of represented alternatives for a collection of
            alternative subsets. This method returns the union of each
            <see cref="T:Antlr4.Runtime.Sharpen.BitSet"/>
            in
            <paramref name="altsets"/>
            .
            </remarks>
            <param name="altsets">a collection of alternative subsets</param>
            <returns>
            the set of represented alternatives in
            <paramref name="altsets"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetConflictingAltSubsets(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>This function gets the conflicting alt subsets from a configuration set.</summary>
            <remarks>
            This function gets the conflicting alt subsets from a configuration set.
            For each configuration
            <c>c</c>
            in
            <paramref name="configs"/>
            :
            <pre>
            map[c] U= c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt">getAlt()</see>
            # map hash/equals uses s and x, not
            alt and not pred
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Atn.PredictionMode.GetStateToAltMap(System.Collections.Generic.IEnumerable{Antlr4.Runtime.Atn.ATNConfig})">
            <summary>Get a map from state to alt subset from a configuration set.</summary>
            <remarks>
            Get a map from state to alt subset from a configuration set. For each
            configuration
            <c>c</c>
            in
            <paramref name="configs"/>
            :
            <pre>
            map[c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.state"/>
            ] U= c.
            <see cref="F:Antlr4.Runtime.Atn.ATNConfig.alt"/>
            </pre>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.ProfilingATNSimulator">
            @since 4.3
        </member>
        <member name="F:Antlr4.Runtime.Atn.ProfilingATNSimulator.conflictingAltResolvedBySLL">
            At the point of LL failover, we record how SLL would resolve the conflict so that
            we can determine whether or not a decision / input pair is context-sensitive.
            If LL gives a different result than SLL's predicted alternative, we have a
            context sensitivity for sure. The converse is not necessarily true, however.
            It's possible that after conflict resolution chooses minimum alternatives,
            SLL could get the same answer as LL. Regardless of whether or not the result indicates
            an ambiguity, it is not treated as a context sensitivity because LL prediction
            was not required in order to produce a correct prediction for this decision and input sequence.
            It may in fact still be a context sensitivity but we don't know by looking at the
            minimum alternatives for the current input.
        </member>
        <member name="T:Antlr4.Runtime.Atn.RuleStopState">
            <summary>The last node in the ATN for a rule, unless that rule is the start symbol.</summary>
            <remarks>
            The last node in the ATN for a rule, unless that rule is the start symbol.
            In that case, there is one transition to EOF. Later, we might encode
            references to all calls to this rule to compute FOLLOW sets for
            error handling.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.ruleIndex">
            <summary>Ptr to the rule definition object for this rule ref</summary>
        </member>
        <member name="F:Antlr4.Runtime.Atn.RuleTransition.followState">
            <summary>What node to begin computations following ref to rule</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SetTransition">
            <summary>A transition containing a set of values.</summary>
            <remarks>A transition containing a set of values.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Atn.SimulatorState">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Atn.StarBlockStartState">
            <summary>The block that begins a closure loop.</summary>
            <remarks>The block that begins a closure loop.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.StarLoopEntryState.isPrecedenceDecision">
            <summary>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            </summary>
            <remarks>
            Indicates whether this state can benefit from a precedence DFA during SLL
            decision making.
            <p>This is a computed property that is calculated during ATN deserialization
            and stored for use in
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            and
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa"/>
        </member>
        <member name="T:Antlr4.Runtime.Atn.TokensStartState">
            <summary>The Tokens rule start state linking to each lexer rule start state</summary>
        </member>
        <member name="T:Antlr4.Runtime.Atn.Transition">
            <summary>An ATN transition between any two ATN states.</summary>
            <remarks>
            An ATN transition between any two ATN states.  Subclasses define
            atom, set, epsilon, action, predicate, rule transitions.
            <p>This is a one way link.  It emanates from a state (usually via a list of
            transitions) and has a target state.</p>
            <p>Since we never have to change the ATN transitions once we construct it,
            we can fix these transitions as specific classes. The DFA transitions
            on the other hand need to update the labels as it adds transitions to
            the states. We'll use the term Edge for the DFA to distinguish them from
            ATN transitions.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Atn.Transition.target">
            <summary>The target of this transition.</summary>
            <remarks>The target of this transition.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Atn.Transition.IsEpsilon">
             <summary>Determines if the transition is an "epsilon" transition.</summary>
             <remarks>
             Determines if the transition is an "epsilon" transition.
             <p>The default implementation returns
             <see langword="false"/>
             .</p>
             </remarks>
             <returns>
            
             <see langword="true"/>
             if traversing this transition in the ATN does not
             consume an input symbol; otherwise,
             <see langword="false"/>
             if traversing this
             transition consumes (matches) an input symbol.
             </returns>
        </member>
        <member name="T:Antlr4.Runtime.BailErrorStrategy">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            responds to syntax errors
            by immediately canceling the parse operation with a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            . The implementation ensures that the
            <see cref="F:Antlr4.Runtime.ParserRuleContext.exception"/>
            field is set for all parse tree nodes
            that were not completed prior to encountering the error.
            <p>
            This error strategy is useful in the following scenarios.</p>
            <ul>
            <li><strong>Two-stage parsing:</strong> This error strategy allows the first
            stage of two-stage parsing to immediately terminate if an error is
            encountered, and immediately fall back to the second stage. In addition to
            avoiding wasted work by attempting to recover from errors here, the empty
            implementation of
            <see cref="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            improves the performance of
            the first stage.</li>
            <li><strong>Silent validation:</strong> When syntax errors are not being
            reported or logged, and the parse result is simply ignored if errors occur,
            the
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            avoids wasting work on recovering from errors
            when the result will be ignored either way.</li>
            </ul>
            <p>
            <c>myparser.setErrorHandler(new BailErrorStrategy());</c>
            </p>
            </summary>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Instead of recovering from exception
            <paramref name="e"/>
            , re-throw it wrapped
            in a
            <see cref="T:Antlr4.Runtime.Misc.ParseCanceledException"/>
            so it is not caught by the
            rule function catches.  Use
            <see cref="P:System.Exception.InnerException"/>
            to get the
            original
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </summary>
            <remarks>
            Make sure we don't attempt to recover inline; if the parser
            successfully recovers, it won't throw an exception.
            </remarks>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.BailErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>Make sure we don't attempt to recover from problems in subrules.</summary>
            <remarks>Make sure we don't attempt to recover from problems in subrules.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.BaseErrorListener">
            <summary>
            Provides an empty default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            . The
            default implementation of each method does nothing, but can be overridden as
            necessary.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.BufferedTokenStream">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            loads tokens from a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            on-demand, and places the tokens in a buffer to provide
            access to any previous token by index.
            <p>
            This token stream ignores the value of
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            . If your
            parser requires the token stream filter tokens to only those on a particular
            channel, such as
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            or
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            , use a filtering token stream such a
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream._tokenSource">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            from which tokens for this stream are fetched.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.tokens">
            <summary>A collection of all tokens fetched from the token source.</summary>
            <remarks>
            A collection of all tokens fetched from the token source. The list is
            considered a complete view of the input once
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            is set
            to
            <see langword="true"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.p">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            of the current token (next token to
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            ).
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            <c>[</c>
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            <c>]</c>
            should be
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.LT(System.Int32)">LT(1)</see>
            .
            <p>This field is set to -1 when the stream is first constructed or when
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)"/>
            is called, indicating that the first token has
            not yet been fetched from the token source. For additional information,
            see the documentation of
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            for a description of
            Initializing Methods.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF">
            <summary>
            Indicates whether the
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            token has been fetched from
            <see cref="F:Antlr4.Runtime.BufferedTokenStream._tokenSource"/>
            and added to
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            . This field improves
            performance for the following cases:
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            : The lookahead check in
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Consume"/>
            to prevent
            consuming the EOF symbol is optimized by checking the values of
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.fetchedEOF"/>
            and
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.p"/>
            instead of calling
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.LA(System.Int32)"/>
            .</li>
            <li>
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)"/>
            : The check to prevent adding multiple EOF symbols into
            <see cref="F:Antlr4.Runtime.BufferedTokenStream.tokens"/>
            is trivial with this field.</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Sync(System.Int32)">
             <summary>
             Make sure index
             <paramref name="i"/>
             in tokens has a token.
             </summary>
             <returns>
            
             <see langword="true"/>
             if a token is located at index
             <paramref name="i"/>
             , otherwise
             <see langword="false"/>
             .
             </returns>
             <seealso cref="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fetch(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            elements to buffer.
            </summary>
            <returns>The actual number of elements added to the buffer.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Get(System.Int32,System.Int32)">
            <summary>Get all tokens from start..stop inclusively.</summary>
            <remarks>Get all tokens from start..stop inclusively.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.AdjustSeekIndex(System.Int32)">
            <summary>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation.
            </summary>
            <remarks>
            Allowed derived classes to modify the behavior of operations which change
            the current stream position by adjusting the target token index of a seek
            operation. The default implementation simply returns
            <paramref name="i"/>
            . If an
            exception is thrown in this method, the current stream index should not be
            changed.
            <p>For example,
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            overrides this method to ensure that
            the seek target is always an on-channel token.</p>
            </remarks>
            <param name="i">The target token index.</param>
            <returns>The adjusted target token index.</returns>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.SetTokenSource(Antlr4.Runtime.ITokenSource)">
            <summary>Reset this token stream by setting its token source.</summary>
            <remarks>Reset this token stream by setting its token source.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetTokens(System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet)">
            <summary>
            Given a start and stop index, return a
            <c>List</c>
            of all tokens in
            the token type
            <c>BitSet</c>
            .  Return
            <see langword="null"/>
            if no tokens were found.  This
            method looks at both on and off channel tokens.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.NextTokenOnChannel(System.Int32,System.Int32)">
            <summary>Given a starting index, return the index of the next token on channel.</summary>
            <remarks>
            Given a starting index, return the index of the next token on channel.
            Return
            <paramref name="i"/>
            if
            <c>tokens[i]</c>
            is on channel. Return the index of
            the EOF token if there are no tokens on channel between
            <paramref name="i"/>
            and
            EOF.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.PreviousTokenOnChannel(System.Int32,System.Int32)">
            <summary>
            Given a starting index, return the index of the previous token on
            channel.
            </summary>
            <remarks>
            Given a starting index, return the index of the previous token on
            channel. Return
            <paramref name="i"/>
            if
            <c>tokens[i]</c>
            is on channel. Return -1
            if there are no tokens on channel between
            <paramref name="i"/>
            and 0.
            <p>
            If
            <paramref name="i"/>
            specifies an index at or after the EOF token, the EOF token
            index is returned. This is due to the fact that the EOF token is treated
            as though it were on every channel.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or
            EOF. If
            <paramref name="channel"/>
            is
            <c>-1</c>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToRight(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the right of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            or EOF.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32,System.Int32)">
            <summary>
            Collect all tokens on specified channel to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            If
            <paramref name="channel"/>
            is
            <c>-1</c>
            , find any non default channel token.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetHiddenTokensToLeft(System.Int32)">
            <summary>
            Collect all hidden tokens (any off-default channel) to the left of
            the current token up until we see a token on
            <see cref="F:Antlr4.Runtime.Lexer.DefaultTokenChannel"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.GetText">
            <summary>Get the text of all tokens in this buffer.</summary>
            <remarks>Get the text of all tokens in this buffer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.BufferedTokenStream.Fill">
            <summary>Get all tokens from lexer until EOF.</summary>
            <remarks>Get all tokens from lexer until EOF.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.CharStreams">
             <summary>Utility class to create <see cref="T:Antlr4.Runtime.ICharStream"/>s from various sources of
             string data.
            
             The methods in this utility class support the full range of
             Unicode code points up to U+10FFFF, unlike <see cref="T:Antlr4.Runtime.AntlrInputStream"/>,
             which is limited to 16-bit Unicode code units up to U+FFFF.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromPath(System.String)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given a path to a UTF-8
             encoded file on disk.
            
             Reads the entire contents of the file into the result before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromPath(System.String,System.Text.Encoding)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given a path to a
             file on disk and the encoding of the bytes contained in the file.
            
             Reads the entire contents of the file into the result before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromTextReader(System.IO.TextReader)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given an opened
             <see cref="T:System.IO.TextReader"/>.
            
             Reads the entire contents of the TextReader then closes the reader before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromStream(System.IO.Stream)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given an opened
             <see cref="T:System.IO.Stream"/> from which UTF-8 encoded bytes can be read.
            
             Reads the entire contents of the stream into the result then
             closes the stream before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromStream(System.IO.Stream,System.Text.Encoding)">
             <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given an opened
             <see cref="T:System.IO.Stream"/> as well as the encoding of the bytes
             to be read from the stream.
            
             Reads the entire contents of the stream into the result then
             closes the stream before returning.
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.CharStreams.fromstring(System.String)">
            <summary>Creates an <see cref="T:Antlr4.Runtime.ICharStream"/> given a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.EmptySource">
            <summary>
            An empty
            <see cref="T:System.Tuple`2"/>
            which is used as the default value of
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            for tokens that do not have a source.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._type">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Type"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._line">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Line"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.charPositionInLine">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Column"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._channel">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Channel"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.source">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.CommonToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.CommonToken.InputStream"/>
            .
            <p>
            These properties share a field to reduce the memory footprint of
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            . Tokens created by a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            from
            the same source and input stream share a reference to the same
            <see cref="T:System.Tuple`2"/>
            containing these values.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken._text">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.Text"/> property.
            </summary>
            <seealso cref="P:Antlr4.Runtime.CommonToken.Text"/>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.index">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.TokenIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.start">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StartIndex"/> property.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonToken.stop">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.CommonToken.StopIndex"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type.
            </summary>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            with the specified token type and
            text.
            </summary>
            <param name="type">The token type.</param>
            <param name="text">The text of the token.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonToken.#ctor(Antlr4.Runtime.IToken)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            as a copy of another
            <see cref="T:Antlr4.Runtime.IToken"/>
            .
            <p>
            If
            <paramref name="oldToken"/>
            is also a
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            instance, the newly
            constructed token will share a reference to the
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            field and
            the
            <see cref="T:System.Tuple`2"/>
            stored in
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            . Otherwise,
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will
            be assigned the result of calling
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            , and
            <see cref="F:Antlr4.Runtime.CommonToken.source"/>
            will be constructed from the result of
            <see cref="P:Antlr4.Runtime.IToken.TokenSource"/>
            and
            <see cref="P:Antlr4.Runtime.IToken.InputStream"/>
            .</p>
            </summary>
            <param name="oldToken">The token to copy.</param>
        </member>
        <member name="P:Antlr4.Runtime.CommonToken.Text">
            <summary>Explicitly set the text for this token.</summary>
            <remarks>
            Explicitly set the text for this token. If {code text} is not
            <see langword="null"/>
            , then
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            will return this value rather than
            extracting the text from the input.
            </remarks>
            <value>
            The explicit text of the token, or
            <see langword="null"/>
            if the text
            should be obtained from the input along with the start and stop indexes
            of the token.
            </value>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenFactory">
            <summary>
            This default implementation of
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            creates
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            objects.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.Default">
            <summary>
            The default
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            instance.
            <p>
            This token factory does not explicitly copy token text when constructing
            tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenFactory.copyText">
            <summary>
            Indicates whether
            <see cref="P:Antlr4.Runtime.CommonToken.Text"/>
            should be called after
            constructing tokens to explicitly set the text. This is useful for cases
            where the input stream might not be able to provide arbitrary substrings
            of text from the input after the lexer creates a token (e.g. the
            implementation of
            <see cref="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            in
            <see cref="T:Antlr4.Runtime.UnbufferedCharStream"/>
            throws an
            <see cref="T:System.NotSupportedException"/>
            ). Explicitly setting the token text
            allows
            <see cref="P:Antlr4.Runtime.IToken.Text"/>
            to be called at any time regardless of the
            input stream implementation.
            <p>
            The default value is
            <see langword="false"/>
            to avoid the performance and memory
            overhead of copying text for every token unless explicitly requested.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor(System.Boolean)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with the specified value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            <p>
            When
            <paramref name="copyText"/>
            is
            <see langword="false"/>
            , the
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance
            should be used instead of constructing a new instance.</p>
            </summary>
            <param name="copyText">
            The value for
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            .
            </param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenFactory.#ctor">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.CommonTokenFactory"/>
            with
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.copyText"/>
            set to
            <see langword="false"/>
            .
            <p>
            The
            <see cref="F:Antlr4.Runtime.CommonTokenFactory.Default"/>
            instance should be used instead of calling this
            directly.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.CommonTokenStream">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.BufferedTokenStream"/>
            with functionality to filter
            token streams to tokens on a particular channel (tokens where
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            returns a particular value).
            <p>
            This token stream provides access to all tokens by index or when calling
            methods like
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.GetText"/>
            . The channel filtering is only used for code
            accessing tokens via the lookahead methods
            <see cref="M:Antlr4.Runtime.BufferedTokenStream.LA(System.Int32)"/>
            ,
            <see cref="M:Antlr4.Runtime.CommonTokenStream.LT(System.Int32)"/>
            , and
            <see cref="M:Antlr4.Runtime.CommonTokenStream.Lb(System.Int32)"/>
            .</p>
            <p>
            By default, tokens are placed on the default channel
            (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ), but may be reassigned by using the
            <c>-&gt;channel(HIDDEN)</c>
            lexer command, or by using an embedded action to
            call
            <see cref="P:Antlr4.Runtime.Lexer.Channel"/>
            .
            </p>
            <p>
            Note: lexer rules which use the
            <c>-&gt;skip</c>
            lexer command or call
            <see cref="M:Antlr4.Runtime.Lexer.Skip"/>
            do not produce tokens at all, so input text matched by
            such a rule will not be available as part of the token stream, regardless of
            channel.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.CommonTokenStream.channel">
            <summary>Specifies the channel to use for filtering tokens.</summary>
            <remarks>
            Specifies the channel to use for filtering tokens.
            <p>
            The default value is
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            , which matches the
            default channel assigned to tokens created by the lexer.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and the default token channel (
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            ).
            </summary>
            <param name="tokenSource">The token source.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.#ctor(Antlr4.Runtime.ITokenSource,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            using the specified token
            source and filtering tokens to the specified channel. Only tokens whose
            <see cref="P:Antlr4.Runtime.IToken.Channel"/>
            matches
            <paramref name="channel"/>
            or have the
            <see cref="P:Antlr4.Runtime.IToken.Type"/>
            equal to
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            will be returned by the
            token stream lookahead methods.
            </summary>
            <param name="tokenSource">The token source.</param>
            <param name="channel">The channel to use for filtering tokens.</param>
        </member>
        <member name="M:Antlr4.Runtime.CommonTokenStream.GetNumberOfOnChannelTokens">
            <summary>Count EOF just once.</summary>
            <remarks>Count EOF just once.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.ConsoleErrorListener`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.ConsoleErrorListener`1.Instance">
            <summary>
            Provides a default instance of
            <see cref="T:Antlr4.Runtime.ConsoleErrorListener`1"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ConsoleErrorListener`1.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>
            This implementation prints messages to
            <see cref="P:System.Console.Error"/>
            containing the
            values of
            <paramref name="line"/>
            ,
            <paramref name="charPositionInLine"/>
            , and
            <paramref name="msg"/>
            using
            the following format.</p>
            <pre>
            line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
            </pre>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.DefaultErrorStrategy">
            <summary>
            This is the default implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            used for
            error reporting and recovery in ANTLR parsers.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.errorRecoveryMode">
            <summary>
            Indicates whether the error strategy is currently "recovering from an
            error".
            </summary>
            <remarks>
            Indicates whether the error strategy is currently "recovering from an
            error". This is used to suppress reporting multiple error messages while
            attempting to recover from a detected syntax error.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)"/>
        </member>
        <member name="F:Antlr4.Runtime.DefaultErrorStrategy.lastErrorIndex">
            <summary>The index into the input stream where the last error occurred.</summary>
            <remarks>
            The index into the input stream where the last error occurred.
            This is used to prevent infinite loops where an error is found
            but no token is consumed during recovery...another error is found,
            ad nauseum.  This is a failsafe mechanism to guarantee that at least
            one token/tree node is consumed for two errors.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            ensure that the handler is not in error recovery mode.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </summary>
            <remarks>
            This method is called to enter error recovery mode when a recognition
            exception is reported.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </summary>
            <remarks>
            This method is called to leave error recovery mode after recovering from
            a recognition exception.
            </remarks>
            <param name="recognizer"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation simply calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.EndErrorCondition(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns immediately if the handler is already
            in error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            and dispatches the reporting task based on the runtime type of
            <paramref name="e"/>
            according to the following table.</p>
            <ul>
            <li>
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)"/>
            </li>
            <li>
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            : Dispatches the call to
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)"/>
            </li>
            <li>All other types: calls
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            to report
            the exception</li>
            </ul>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            <inheritDoc/>
            <p>The default implementation resynchronizes the parser by consuming tokens
            until we find one in the resynchronization set--loosely the set of tokens
            that can follow the current rule.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            The default implementation of
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            makes sure
            that the current lookahead symbol is consistent with what were expecting
            at this point in the ATN. You can call this anytime but ANTLR only
            generates code to check before subrules/loops and each iteration.
            <p>Implements Jim Idle's magic sync mechanism in closures and optional
            subrules. E.g.,</p>
            <pre>
            a : sync ( stuff sync )* ;
            sync : {consume to what can follow sync} ;
            </pre>
            At the start of a sub rule upon error,
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            performs single
            token deletion, if possible. If it can't do that, it bails on the current
            rule and uses the default error recovery, which consumes until the
            resynchronization set of the current rule.
            <p>If the sub rule is optional (
            <c>(...)?</c>
            ,
            <c>(...)*</c>
            , or block
            with an empty alternative), then the expected set includes what follows
            the subrule.</p>
            <p>During loop iteration, it consumes until it sees a token that can start a
            sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
            stay in the loop as long as possible.</p>
            <p><strong>ORIGINS</strong></p>
            <p>Previous versions of ANTLR did a poor job of their recovery within loops.
            A single mismatch token or missing token would force the parser to bail
            out of the entire rules surrounding the loop. So, for rule</p>
            <pre>
            classDef : 'class' ID '{' member* '}'
            </pre>
            input with an extra token between members would force the parser to
            consume until it found the next class definition rather than the next
            member definition of the current class.
            <p>This functionality cost a little bit of effort because the parser has to
            compare token set at the start of the loop and at each iteration. If for
            some reason speed is suffering for you, you can turn off this
            functionality by simply overriding this method as a blank { }.</p>
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportNoViableAlternative(Antlr4.Runtime.Parser,Antlr4.Runtime.NoViableAltException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportInputMismatch(Antlr4.Runtime.Parser,Antlr4.Runtime.InputMismatchException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportFailedPredicate(Antlr4.Runtime.Parser,Antlr4.Runtime.FailedPredicateException)">
            <summary>
            This is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            when the exception is a
            <see cref="T:Antlr4.Runtime.FailedPredicateException"/>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the removal
            of a token from the input stream. At the time this method is called, the
            erroneous symbol is current
            <c>LT(1)</c>
            symbol and has not yet been
            removed from the input stream. When this method returns,
            <paramref name="recognizer"/>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token deletion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMissingToken(Antlr4.Runtime.Parser)">
            <summary>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream.
            </summary>
            <remarks>
            This method is called to report a syntax error which requires the
            insertion of a missing token into the input stream. At the time this
            method is called, the missing token has not yet been inserted. When this
            method returns,
            <paramref name="recognizer"/>
            is in error recovery mode.
            <p>This method is called when
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            identifies
            single-token insertion as a viable recovery strategy for a mismatched
            input error.</p>
            <p>The default implementation simply returns if the handler is already in
            error recovery mode. Otherwise, it calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.BeginErrorCondition(Antlr4.Runtime.Parser)"/>
            to
            enter error recovery mode, followed by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            <inheritDoc/>
            <p>The default implementation attempts to recover from the mismatched input
            by using single token insertion and deletion as described below. If the
            recovery attempt fails, this method throws an
            <see cref="T:Antlr4.Runtime.InputMismatchException"/>
            .</p>
            <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
            <p>
            <c>LA(1)</c>
            is not what we are looking for. If
            <c>LA(2)</c>
            has the
            right token, however, then assume
            <c>LA(1)</c>
            is some extra spurious
            token and delete it. Then consume and return the next token (which was
            the
            <c>LA(2)</c>
            token) as the successful result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
            <p>If current token (at
            <c>LA(1)</c>
            ) is consistent with what could come
            after the expected
            <c>LA(1)</c>
            token, then assume the token is missing
            and use the parser's
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to create it on the fly. The
            "insertion" is performed by returning the created token as the successful
            result of the match operation.</p>
            <p>This recovery strategy is implemented by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)"/>
            .</p>
            <p><strong>EXAMPLE</strong></p>
            <p>For example, Input
            <c>i=(3;</c>
            is clearly missing the
            <c>')'</c>
            . When
            the parser returns from the nested call to
            <c>expr</c>
            , it will have
            call chain:</p>
            <pre>
            stat &#x2192; expr &#x2192; atom
            </pre>
            and it will be trying to match the
            <c>')'</c>
            at this point in the
            derivation:
            <pre>
            =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
            ^
            </pre>
            The attempt to match
            <c>')'</c>
            will fail when it sees
            <c>';'</c>
            and
            call
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            . To recover, it sees that
            <c>LA(1)==';'</c>
            is in the set of tokens that can follow the
            <c>')'</c>
            token reference
            in rule
            <c>atom</c>
            . It can assume that you forgot the
            <c>')'</c>
            .
            </summary>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenInsertion(Antlr4.Runtime.Parser)">
             <summary>
             This method implements the single-token insertion inline error recovery
             strategy.
             </summary>
             <remarks>
             This method implements the single-token insertion inline error recovery
             strategy. It is called by
             <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
             if the single-token
             deletion strategy fails to recover from the mismatched input. If this
             method returns
             <see langword="true"/>
             ,
             <paramref name="recognizer"/>
             will be in error recovery
             mode.
             <p>This method determines whether or not single-token insertion is viable by
             checking if the
             <c>LA(1)</c>
             input symbol could be successfully matched
             if it were instead the
             <c>LA(2)</c>
             symbol. If this method returns
             <see langword="true"/>
             , the caller is responsible for creating and inserting a
             token with the correct type to produce this behavior.</p>
             </remarks>
             <param name="recognizer">the parser instance</param>
             <returns>
            
             <see langword="true"/>
             if single-token insertion is a viable recovery
             strategy for the current mismatched input, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.SingleTokenDeletion(Antlr4.Runtime.Parser)">
            <summary>
            This method implements the single-token deletion inline error recovery
            strategy.
            </summary>
            <remarks>
            This method implements the single-token deletion inline error recovery
            strategy. It is called by
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            to attempt to recover
            from mismatched input. If this method returns null, the parser and error
            handler state will not have changed. If this method returns non-null,
            <paramref name="recognizer"/>
            will <em>not</em> be in error recovery mode since the
            returned token was a successful match.
            <p>If the single-token deletion is successful, this method calls
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportUnwantedToken(Antlr4.Runtime.Parser)"/>
            to report the error, followed by
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            to actually "delete" the extraneous token. Then,
            before returning
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            is called to signal a successful
            match.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <returns>
            the successfully matched
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance if single-token
            deletion successfully recovers from the mismatched input, otherwise
            <see langword="null"/>
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetMissingSymbol(Antlr4.Runtime.Parser)">
            <summary>Conjure up a missing token during error recovery.</summary>
            <remarks>
            Conjure up a missing token during error recovery.
            The recognizer attempts to recover from single missing
            symbols. But, actions might refer to that missing symbol.
            For example, x=ID {f($x);}. The action clearly assumes
            that there has been an identifier matched previously and that
            $x points at that token. If that token is missing, but
            the next token in the stream is what we want we assume that
            this token is missing and we keep going. Because we
            have to return some token to replace the missing token,
            we have to conjure one up. This method gives the user control
            over the tokens returned for missing tokens. Mostly,
            you will want to create something special for identifier
            tokens. For literals such as '{' and ',', the default
            action in the parser or tree parser works. It simply creates
            a CommonToken of the appropriate type. The text will be the token.
            If you change what tokens must be created by the lexer,
            override this method to create the appropriate tokens.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.DefaultErrorStrategy.ConsumeUntil(Antlr4.Runtime.Parser,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Consume tokens until one matches the given token set.</summary>
            <remarks>Consume tokens until one matches the given token set.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dependents">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.AcceptStateInfo">
            <summary>
            Stores information about a
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            which is an accept state under
            some condition. Certain settings, such as
            <see cref="P:Antlr4.Runtime.Atn.ParserATNSimulator.PredictionMode"/>
            , may be used in addition to
            this information to determine whether or not a particular state is an accept
            state.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.AcceptStateInfo.Prediction">
            <summary>Gets the prediction made by this accept state.</summary>
            <remarks>
            Gets the prediction made by this accept state. Note that this value
            assumes the predicates, if any, in the
            <see cref="T:Antlr4.Runtime.Dfa.DFAState"/>
            evaluate to
            <see langword="true"/>
            . If predicate evaluation is enabled, the final prediction of
            the accept state will be determined by the result of predicate
            evaluation.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Dfa.AcceptStateInfo.LexerActionExecutor">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.Atn.LexerActionExecutor"/>
            which can be used to execute actions
            and/or commands after the lexer matches a token.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.ArrayEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.states">
            A set of all DFA states. Use {@link Map} so we can get old state back
            ({@link Set} only allows you to see if it's there).
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.atnStartState">
            From which ATN state did we create this DFA? 
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFA.precedenceDfa">
            {@code true} if this DFA is for a precedence decision; otherwise,
            {@code false}. This is the backing field for {@link #isPrecedenceDfa}.
        </member>
        <member name="P:Antlr4.Runtime.Dfa.DFA.IsPrecedenceDfa">
             Gets whether this DFA is a precedence DFA. Precedence DFAs use a special
             start state {@link #s0} which is not stored in {@link #states}. The
             {@link DFAState#edges} array for this start state contains outgoing edges
             supplying individual start states corresponding to specific precedence
             values.
            
             @return {@code true} if this is a precedence DFA; otherwise,
             {@code false}.
             @see Parser#getPrecedence()
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.GetPrecedenceStartState(System.Int32)">
             Get the start state for a specific precedence value.
            
             @param precedence The current precedence.
             @return The start state corresponding to the specified precedence, or
             {@code null} if no start state exists for the specified precedence.
            
             @throws IllegalStateException if this is not a precedence DFA.
             @see #isPrecedenceDfa()
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.SetPrecedenceStartState(System.Int32,Antlr4.Runtime.Dfa.DFAState)">
             Set the start state for a specific precedence value.
            
             @param precedence The current precedence.
             @param startState The start state corresponding to the specified
             precedence.
            
             @throws IllegalStateException if this is not a precedence DFA.
             @see #isPrecedenceDfa()
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFA.GetStates">
            Return a list of all states in this DFA, ordered by state number.
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFASerializer">
            <summary>A DFA walker that knows how to dump them to serialized strings.</summary>
            <remarks>A DFA walker that knows how to dump them to serialized strings.</remarks>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.DFAState">
            <summary>A DFA state represents a set of possible ATN configurations.</summary>
            <remarks>
            A DFA state represents a set of possible ATN configurations.
            As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
            to keep track of all possible states the ATN can be in after
            reading each input symbol.  That is to say, after reading
            input a1a2..an, the DFA is in a state that represents the
            subset T of the states of the ATN that are reachable from the
            ATN's start state along some path labeled a1a2..an."
            In conventional NFA&#x2192;DFA conversion, therefore, the subset T
            would be a bitset representing the set of states the
            ATN could be in.  We need to track the alt predicted by each
            state as well, however.  More importantly, we need to maintain
            a stack of states, tracking the closure operations as they
            jump from rule to rule, emulating rule invocations (method calls).
            I have to add a stack to simulate the proper lookahead sequences for
            the underlying LL grammar from which the ATN was derived.
            <p>I use a set of ATNConfig objects not simple states.  An ATNConfig
            is both a state (ala normal conversion) and a RuleContext describing
            the chain of rules (if any) followed to arrive at that state.</p>
            <p>A DFA state may have multiple references to a particular state,
            but with different ATN contexts (with same or different alts)
            meaning that state was reached via a different set of rule invocations.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.edges">
            {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
            {@link Token#EOF} maps to {@code edges[0]}.
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.prediction">
            if accept state, what ttype do we match or alt do we predict?
            This is set to {@link ATN#INVALID_ALT_NUMBER} when {@link #predicates}{@code !=null} or
            {@link #requiresFullContext}.
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.requiresFullContext">
            Indicates that this state was created during SLL prediction that
            discovered a conflict between the configurations in the state. Future
            {@link ParserATNSimulator#execATN} invocations immediately jumped doing
            full context prediction if this field is true.
        </member>
        <member name="F:Antlr4.Runtime.Dfa.DFAState.predicates">
            During SLL parsing, this is a list of predicates associated with the
              ATN configurations of the DFA state. When we have predicates,
              {@link #requiresFullContext} is {@code false} since full context prediction evaluates predicates
              on-the-fly. If this is not null, then {@link #prediction} is
              {@link ATN#INVALID_ALT_NUMBER}.
            
              <p>We only use these for non-{@link #requiresFullContext} but conflicting states. That
              means we know from the context (it's $ or we don't dip into outer
              context) that it's an ambiguity not a conflict.</p>
            
              <p>This list is computed by {@link ParserATNSimulator#predicateDFAState}.</p>
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.getAltSet">
            Get the set of all alts mentioned by all ATN configurations in this
            DFA state.
        </member>
        <member name="M:Antlr4.Runtime.Dfa.DFAState.Equals(System.Object)">
             Two {@link DFAState} instances are equal if their ATN configuration sets
             are the same. This method is used to see if a state already exists.
            
             <p>Because the number of alternatives and number of ATN configurations are
             finite, there is a finite number of DFA states that can be processed.
             This is necessary to show that the algorithm terminates.</p>
            
             <p>Cannot test the DFA state numbers here because in
             {@link ParserATNSimulator#addDFAState} we need to know if any other state
             exists that has this exact set of ATN configurations. The
             {@link #stateNumber} is irrelevant.</p>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.PredPrediction">
            Map a predicate to a predicted alternative. 
        </member>
        <member name="T:Antlr4.Runtime.Dfa.EmptyEdgeMap`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.Dfa.AbstractEdgeMap`1"/>
            represents an empty edge map.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.IEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SingletonEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Dfa.SparseEdgeMap`1">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.DiagnosticErrorListener">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            can be used to identify
            certain potential correctness and performance problems in grammars. "Reports"
            are made by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            with the appropriate
            message.
            <ul>
            <li><b>Ambiguities</b>: These are cases where more than one path through the
            grammar can match the input.</li>
            <li><b>Weak context sensitivity</b>: These are cases where full-context
            prediction resolved an SLL conflict to a unique alternative which equaled the
            minimum alternative of the SLL conflict.</li>
            <li><b>Strong (forced) context sensitivity</b>: These are cases where the
            full-context prediction resolved an SLL conflict to a unique alternative,
            <em>and</em> the minimum alternative of the SLL conflict was found to not be
            a truly viable alternative. Two-stage parsing cannot be used for inputs where
            this situation occurs.</li>
            </ul>
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.DiagnosticErrorListener.exactOnly">
            <summary>
            When
            <see langword="true"/>
            , only exactly known ambiguities are reported.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor">
            <summary>
            Initializes a new instance of
            <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
            which only
            reports exact ambiguities.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.#ctor(System.Boolean)">
             <summary>
             Initializes a new instance of
             <see cref="T:Antlr4.Runtime.DiagnosticErrorListener"/>
             , specifying
             whether all ambiguities or only exact ambiguities are reported.
             </summary>
             <param name="exactOnly">
            
             <see langword="true"/>
             to report only exact ambiguities, otherwise
             <see langword="false"/>
             to report all ambiguities.
             </param>
        </member>
        <member name="M:Antlr4.Runtime.DiagnosticErrorListener.GetConflictingAlts(Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
            <summary>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </summary>
            <remarks>
            Computes the set of conflicting or ambiguous alternatives from a
            configuration set, if that information was not already provided by the
            parser.
            </remarks>
            <param name="reportedAlts">
            The set of conflicting or ambiguous alternatives, as
            reported by the parser.
            </param>
            <param name="configSet">The conflicting or ambiguous configuration set.</param>
            <returns>
            Returns
            <paramref name="reportedAlts"/>
            if it is not
            <see langword="null"/>
            , otherwise
            returns the set of alternatives represented in
            <paramref name="configSet"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.FailedPredicateException">
            <summary>A semantic predicate failed during validation.</summary>
            <remarks>
            A semantic predicate failed during validation.  Validation of predicates
            occurs when normally parsing the alternative just like matching a token.
            Disambiguating predicate evaluation occurs when we test a predicate during
            prediction.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorListener`1">
            <summary>How to emit recognition errors.</summary>
            <remarks>How to emit recognition errors.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorListener`1.SyntaxError(System.IO.TextWriter,Antlr4.Runtime.IRecognizer,`0,System.Int32,System.Int32,System.String,Antlr4.Runtime.RecognitionException)">
            <summary>Upon syntax error, notify any interested parties.</summary>
            <remarks>
            Upon syntax error, notify any interested parties. This is not how to
            recover from errors or compute error messages.
            <see cref="T:Antlr4.Runtime.IAntlrErrorStrategy"/>
            specifies how to recover from syntax errors and how to compute error
            messages. This listener's job is simply to emit a computed message,
            though it has enough information to create its own message in many cases.
            <p>The
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            is non-null for all syntax errors except
            when we discover mismatched token errors that we can recover from
            in-line, without returning from the surrounding rule (via the single
            token insertion and deletion mechanism).</p>
            </remarks>
            <param name="output">
            Where the error should be written.
            </param>
            <param name="recognizer">
            What parser got the error. From this
            object, you can access the context as well
            as the input stream.
            </param>
            <param name="offendingSymbol">
            The offending token in the input token
            stream, unless recognizer is a lexer (then it's null). If
            no viable alternative error,
            <paramref name="e"/>
            has token at which we
            started production for the decision.
            </param>
            <param name="line">The line number in the input where the error occurred.</param>
            <param name="charPositionInLine">The character position within that line where the error occurred.</param>
            <param name="msg">The message to emit.</param>
            <param name="e">
            The exception generated by the parser that led to
            the reporting of an error. It is null in the case where
            the parser was able to recover in line without exiting the
            surrounding rule.
            </param>
        </member>
        <member name="T:Antlr4.Runtime.IAntlrErrorStrategy">
            <summary>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers.
            </summary>
            <remarks>
            The interface for defining strategies to deal with syntax errors encountered
            during a parse by ANTLR-generated parsers. We distinguish between three
            different kinds of errors:
            <ul>
            <li>The parser could not figure out which path to take in the ATN (none of
            the available alternatives could possibly match)</li>
            <li>The current input does not match what we were looking for</li>
            <li>A predicate evaluated to false</li>
            </ul>
            Implementations of this interface report syntax errors by calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            .
            <p>TODO: what to do about lexers</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Reset(Antlr4.Runtime.Parser)">
            <summary>
            Reset the error handler state for the specified
            <paramref name="recognizer"/>
            .
            </summary>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)">
            <summary>
            This method is called when an unexpected symbol is encountered during an
            inline match operation, such as
            <see cref="M:Antlr4.Runtime.Parser.Match(System.Int32)"/>
            . If the error
            strategy successfully recovers from the match failure, this method
            returns the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance which should be treated as the
            successful result of the match.
            <p>Note that the calling code will not report an error if this method
            returns successfully. The error strategy implementation is responsible
            for calling
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            as appropriate.</p>
            </summary>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy was not able to
            recover from the unexpected input symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Recover(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            This method is called to recover from exception
            <paramref name="e"/>
            . This method is
            called after
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            by the default exception handler
            generated for a rule method.
            </summary>
            <seealso cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)"/>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to recover from</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the error strategy could not recover from
            the recognition exception
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)">
            <summary>
            This method provides the error handler with an opportunity to handle
            syntactic or semantic errors in the input stream before they result in a
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            .
            <p>The generated code currently contains calls to
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            after
            entering the decision state of a closure block (
            <c>(...)*</c>
            or
            <c>(...)+</c>
            ).</p>
            <p>For an implementation based on Jim Idle's "magic sync" mechanism, see
            <see cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            .</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.DefaultErrorStrategy.Sync(Antlr4.Runtime.Parser)"/>
            <param name="recognizer">the parser instance</param>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if an error is detected by the error
            strategy but cannot be automatically recovered at the current state in
            the parsing process
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.InErrorRecoveryMode(Antlr4.Runtime.Parser)">
             <summary>
             Tests whether or not
             <paramref name="recognizer"/>
             is in the process of recovering
             from an error. In error recovery mode,
             <see cref="M:Antlr4.Runtime.Parser.Consume"/>
             adds
             symbols to the parse tree by calling
             <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
             instead of
             <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
             .
             </summary>
             <param name="recognizer">the parser instance</param>
             <returns>
            
             <see langword="true"/>
             if the parser is currently recovering from a parse
             error, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)">
            <summary>
            This method is called by when the parser successfully matches an input
            symbol.
            </summary>
            <remarks>
            This method is called by when the parser successfully matches an input
            symbol.
            </remarks>
            <param name="recognizer">the parser instance</param>
        </member>
        <member name="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportError(Antlr4.Runtime.Parser,Antlr4.Runtime.RecognitionException)">
            <summary>
            Report any kind of
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            . This method is called by
            the default exception handler generated for a rule method.
            </summary>
            <param name="recognizer">the parser instance</param>
            <param name="e">the recognition exception to report</param>
        </member>
        <member name="T:Antlr4.Runtime.ICharStream">
            <summary>A source of characters for an ANTLR lexer.</summary>
            <remarks>A source of characters for an ANTLR lexer.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.ICharStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            This method returns the text for a range of characters within this input
            stream.
            </summary>
            <remarks>
            This method returns the text for a range of characters within this input
            stream. This method is guaranteed to not throw an exception if the
            specified
            <paramref name="interval"/>
            lies entirely within a marked range. For more
            information about marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            </remarks>
            <param name="interval">an interval within the stream</param>
            <returns>the text of the specified interval</returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="interval"/>
            is
            <see langword="null"/>
            </exception>
            <exception cref="T:System.ArgumentException">
            if
            <c>interval.a &lt; 0</c>
            , or if
            <c>interval.b &lt; interval.a - 1</c>
            , or if
            <c>interval.b</c>
            lies at or
            past the end of the stream
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            getting the text of the specified interval
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.IIntStream">
            <summary>A simple stream of symbols whose values are represented as integers.</summary>
            <remarks>
            A simple stream of symbols whose values are represented as integers. This
            interface provides <em>marked ranges</em> with support for a minimum level
            of buffering necessary to implement arbitrary lookahead during prediction.
            For more information on marked ranges, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .
            <p><strong>Initializing Methods:</strong> Some methods in this interface have
            unspecified behavior if no call to an initializing method has occurred after
            the stream was constructed. The following is a list of initializing methods:</p>
            <ul>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)"/>
            </li>
            <li>
            <see cref="M:Antlr4.Runtime.IIntStream.Consume"/>
            </li>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            </li>
            </ul>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Consume">
            <summary>Consumes the current symbol in the stream.</summary>
            <remarks>
            Consumes the current symbol in the stream. This method has the following
            effects:
            <ul>
            <li><strong>Forward movement:</strong> The value of
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            before calling this method is less than the value of
            <c>index()</c>
            after calling this method.</li>
            <li><strong>Ordered lookahead:</strong> The value of
            <c>LA(1)</c>
            before
            calling this method becomes the value of
            <c>LA(-1)</c>
            after calling
            this method.</li>
            </ul>
            Note that calling this method does not guarantee that
            <c>index()</c>
            is
            incremented by exactly 1, as that would preclude the ability to implement
            filtering streams (e.g.
            <see cref="T:Antlr4.Runtime.CommonTokenStream"/>
            which distinguishes
            between "on-channel" and "off-channel" tokens).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            if an attempt is made to consume the the
            end of the stream (i.e. if
            <c>LA(1)==</c>
            <see cref="F:Antlr4.Runtime.IntStreamConstants.EOF">EOF</see>
            before calling
            <c>consume</c>
            ).
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.LA(System.Int32)">
            <summary>
            Gets the value of the symbol at offset
            <paramref name="i"/>
            from the current
            position. When
            <c>i==1</c>
            , this method returns the value of the current
            symbol in the stream (which is the next symbol to be consumed). When
            <c>i==-1</c>
            , this method returns the value of the previously read
            symbol in the stream. It is not valid to call this method with
            <c>i==0</c>
            , but the specific behavior is unspecified because this
            method is frequently called from performance-critical code.
            <p>This method is guaranteed to succeed if any of the following are true:</p>
            <ul>
            <li>
            <c>i&gt;0</c>
            </li>
            <li>
            <c>i==-1</c>
            and
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            returns a value greater
            than the value of
            <c>index()</c>
            after the stream was constructed
            and
            <c>LA(1)</c>
            was called in that order. Specifying the current
            <c>index()</c>
            relative to the index after the stream was created
            allows for filtering implementations that do not return every symbol
            from the underlying source. Specifying the call to
            <c>LA(1)</c>
            allows for lazily initialized streams.</li>
            <li>
            <c>LA(i)</c>
            refers to a symbol consumed within a marked region
            that has not yet been released.</li>
            </ul>
            <p>If
            <paramref name="i"/>
            represents a position at or beyond the end of the stream,
            this method returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.EOF"/>
            .</p>
            <p>The return value is unspecified if
            <c>i&lt;0</c>
            and fewer than
            <c>-i</c>
            calls to
            <see cref="M:Antlr4.Runtime.IIntStream.Consume">consume()</see>
            have occurred from the beginning of
            the stream before calling this method.</p>
            </summary>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the value of the specified symbol
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Mark">
            <summary>
            A mark provides a guarantee that
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek()</see>
            operations will be
            valid over a "marked range" extending from the index where
            <c>mark()</c>
            was called to the current
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            . This allows the use of
            streaming input sources by specifying the minimum buffering requirements
            to support arbitrary lookahead during prediction.
            <p>The returned mark is an opaque handle (type
            <c>int</c>
            ) which is passed
            to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the guarantees provided by the marked
            range are no longer necessary. When calls to
            <c>mark()</c>
            /
            <c>release()</c>
            are nested, the marks must be released
            in reverse order of which they were obtained. Since marked regions are
            used during performance-critical sections of prediction, the specific
            behavior of invalid usage is unspecified (i.e. a mark is not released, or
            a mark is released twice, or marks are not released in reverse order from
            which they were created).</p>
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            <p>This method does not change the current position in the input stream.</p>
            <p>The following example shows the use of
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            ,
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release(mark)</see>
            ,
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            , and
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">seek(index)</see>
            as part of an operation to safely work within a
            marked region, then restore the stream position to its original value and
            release the mark.</p>
            <pre>
            IntStream stream = ...;
            int index = -1;
            int mark = stream.mark();
            try {
            index = stream.index();
            // perform work here...
            } finally {
            if (index != -1) {
            stream.seek(index);
            }
            stream.release(mark);
            }
            </pre>
            </summary>
            <returns>
            An opaque marker which should be passed to
            <see cref="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">release()</see>
            when the marked range is no longer required.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Release(System.Int32)">
            <summary>
            This method releases a marked range created by a call to
            <see cref="M:Antlr4.Runtime.IIntStream.Mark">mark()</see>
            . Calls to
            <c>release()</c>
            must appear in the
            reverse order of the corresponding calls to
            <c>mark()</c>
            . If a mark is
            released twice, or if marks are not released in reverse order of the
            corresponding calls to
            <c>mark()</c>
            , the behavior is unspecified.
            <p>For more information and an example, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            .</p>
            </summary>
            <param name="marker">
            A marker returned by a call to
            <c>mark()</c>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.IIntStream.Mark"/>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Index">
            <summary>
            Return the index into the stream of the input symbol referred to by
            <c>LA(1)</c>
            .
            <p>The behavior of this method is unspecified if no call to an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream was
            constructed.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)">
            <summary>
            Set the input cursor to the position indicated by
            <paramref name="index"/>
            . If the
            specified index lies past the end of the stream, the operation behaves as
            though
            <paramref name="index"/>
            was the index of the EOF symbol. After this method
            returns without throwing an exception, the at least one of the following
            will be true.
            <ul>
            <li>
            <see cref="P:Antlr4.Runtime.IIntStream.Index">index()</see>
            will return the index of the first symbol
            appearing at or after the specified
            <paramref name="index"/>
            . Specifically,
            implementations which filter their sources should automatically
            adjust
            <paramref name="index"/>
            forward the minimum amount required for the
            operation to target a non-ignored symbol.</li>
            <li>
            <c>LA(1)</c>
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.EOF"/>
            </li>
            </ul>
            This operation is guaranteed to not throw an exception if
            <paramref name="index"/>
            lies within a marked region. For more information on marked regions, see
            <see cref="M:Antlr4.Runtime.IIntStream.Mark"/>
            . The behavior of this method is unspecified if no call to
            an
            <see cref="T:Antlr4.Runtime.IIntStream">initializing method</see>
            has occurred after this stream
            was constructed.
            </summary>
            <param name="index">The absolute index to seek to.</param>
            <exception cref="T:System.ArgumentException">
            if
            <paramref name="index"/>
            is less than 0
            </exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            seeking to the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.Size">
            <summary>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </summary>
            <remarks>
            Returns the total number of symbols in the stream, including a single EOF
            symbol.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the size of the stream is
            unknown.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.IIntStream.SourceName">
            <summary>Gets the name of the underlying symbol source.</summary>
            <remarks>
            Gets the name of the underlying symbol source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.EOF">
            <summary>
            The value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)">LA()</see>
            when the end of the stream is
            reached.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName">
            <summary>
            The value returned by
            <see cref="P:Antlr4.Runtime.IIntStream.SourceName"/>
            when the actual name of the
            underlying source is not known.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.InputMismatchException">
            <summary>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </summary>
            <remarks>
            This signifies any kind of mismatched input exceptions such as
            when the current input does not match the expected token.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.InterpreterRuleContext">
            <summary>
            This class extends
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            by allowing the value of
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            to be explicitly set for the context.
            <p>
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            does not include field storage for the rule index
            since the context classes created by the code generator override the
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            method to return the correct value for that context.
            Since the parser interpreter does not use the context classes generated for a
            parser, this class (with slightly more memory overhead per node) is used to
            provide equivalent functionality.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.InterpreterRuleContext.ruleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.InterpreterRuleContext.RuleIndex"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.InterpreterRuleContext.#ctor(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.InterpreterRuleContext"/>
            with the specified
            parent, invoking state, and rule index.
            </summary>
            <param name="parent">The parent context.</param>
            <param name="invokingStateNumber">The invoking state number.</param>
            <param name="ruleIndex">The rule index for the current context.</param>
        </member>
        <member name="T:Antlr4.Runtime.IParserErrorListener">
            <summary>How to emit recognition errors for parsers.</summary>
            <remarks>How to emit recognition errors for parsers.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)">
             <summary>
             This method is called by the parser when a full-context prediction
             results in an ambiguity.
             </summary>
             <remarks>
             This method is called by the parser when a full-context prediction
             results in an ambiguity.
             <p>Each full-context prediction which does not result in a syntax error
             will call either
             <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
             or
             <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
             .</p>
             <p>
             When
             <paramref name="ambigAlts"/>
             is not null, it contains the set of potentially
             viable alternatives identified by the prediction algorithm. When
             <paramref name="ambigAlts"/>
             is null, use
             <see cref="M:Antlr4.Runtime.Atn.ATNConfigSet.GetAlts"/>
             to obtain the represented
             alternatives from the
             <paramref name="configs"/>
             argument.</p>
             <p>When
             <paramref name="exact"/>
             is
             <see langword="true"/>
             , <em>all</em> of the potentially
             viable alternatives are truly viable, i.e. this is reporting an exact
             ambiguity. When
             <paramref name="exact"/>
             is
             <see langword="false"/>
             , <em>at least two</em> of
             the potentially viable alternatives are viable for the current input, but
             the prediction algorithm terminated as soon as it determined that at
             least the <em>minimum</em> potentially viable alternative is truly
             viable.</p>
             <p>When the
             <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION"/>
             prediction
             mode is used, the parser is required to identify exact ambiguities so
             <paramref name="exact"/>
             will always be
             <see langword="true"/>
             .</p>
             </remarks>
             <param name="recognizer">the parser instance</param>
             <param name="dfa">the DFA for the current decision</param>
             <param name="startIndex">the input index where the decision started</param>
             <param name="stopIndex">the input input where the ambiguity was identified</param>
             <param name="exact">
            
             <see langword="true"/>
             if the ambiguity is exactly known, otherwise
             <see langword="false"/>
             . This is always
             <see langword="true"/>
             when
             <see cref="F:Antlr4.Runtime.Atn.PredictionMode.LL_EXACT_AMBIG_DETECTION"/>
             is used.
             </param>
             <param name="ambigAlts">
             the potentially ambiguous alternatives, or
             <see langword="null"/>
             to indicate that the potentially ambiguous alternatives are the complete
             set of represented alternatives in
             <paramref name="configs"/>
             </param>
             <param name="configs">
             the ATN configuration set where the ambiguity was
             identified
             </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportAttemptingFullContext(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            </summary>
            <remarks>
            This method is called when an SLL conflict occurs and the parser is about
            to use the full context information to make an LL decision.
            <p>If one or more configurations in
            <c>configs</c>
            contains a semantic
            predicate, the predicates are evaluated before this method is called. The
            subset of alternatives which are still viable after predicates are
            evaluated is reported in
            <paramref name="conflictingAlts"/>
            .</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">the input index where the SLL conflict occurred</param>
            <param name="conflictingAlts">
            The specific conflicting alternatives. If this is
            <see langword="null"/>
            , the conflicting alternatives are all alternatives
            represented in
            <c>configs</c>
            .
            </param>
            <param name="conflictState">
            the simulator state when the SLL conflict was
            detected
            </param>
        </member>
        <member name="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)">
            <summary>
            This method is called by the parser when a full-context prediction has a
            unique result.
            </summary>
            <remarks>
            This method is called by the parser when a full-context prediction has a
            unique result.
            <p>Each full-context prediction which does not result in a syntax error
            will call either
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportContextSensitivity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Int32,Antlr4.Runtime.Atn.SimulatorState)"/>
            or
            <see cref="M:Antlr4.Runtime.IParserErrorListener.ReportAmbiguity(Antlr4.Runtime.Parser,Antlr4.Runtime.Dfa.DFA,System.Int32,System.Int32,System.Boolean,Antlr4.Runtime.Sharpen.BitSet,Antlr4.Runtime.Atn.ATNConfigSet)"/>
            .</p>
            <p>For prediction implementations that only evaluate full-context
            predictions when an SLL conflict is found (including the default
            <see cref="T:Antlr4.Runtime.Atn.ParserATNSimulator"/>
            implementation), this method reports cases
            where SLL conflicts were resolved to unique full-context predictions,
            i.e. the decision was context-sensitive. This report does not necessarily
            indicate a problem, and it may appear even in completely unambiguous
            grammars.</p>
            <p>
            <c>configs</c>
            may have more than one represented alternative if the
            full-context prediction algorithm does not evaluate predicates before
            beginning the full-context prediction. In all cases, the final prediction
            is passed as the
            <paramref name="prediction"/>
            argument.</p>
            <p>Note that the definition of "context sensitivity" in this method
            differs from the concept in
            <see cref="F:Antlr4.Runtime.Atn.DecisionInfo.contextSensitivities"/>
            .
            This method reports all instances where an SLL conflict occurred but LL
            parsing produced a unique result, whether or not that unique result
            matches the minimum alternative in the SLL conflicting set.</p>
            </remarks>
            <param name="recognizer">the parser instance</param>
            <param name="dfa">the DFA for the current decision</param>
            <param name="startIndex">the input index where the decision started</param>
            <param name="stopIndex">
            the input index where the context sensitivity was
            finally determined
            </param>
            <param name="prediction">the unambiguous result of the full-context prediction</param>
            <param name="acceptState">
            the simulator state when the unambiguous prediction
            was determined
            </param>
        </member>
        <member name="T:Antlr4.Runtime.IToken">
            <summary>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </summary>
            <remarks>
            A token has properties: text, type, line, character position in the line
            (so we can ignore tabs), token channel, index, and source from which
            we obtained this token.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Text">
            <summary>Get the text of the token.</summary>
            <remarks>Get the text of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Type">
            <summary>Get the token type of the token.</summary>
            <remarks>Get the token type of the token.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Line">
            <summary>
            The line number on which the 1st character of this token was matched,
            line=1..n
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Column">
            <summary>
            The index of the first character of this token relative to the
            beginning of the line at which it occurs, 0..n-1
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.Channel">
            <summary>Return the channel this token.</summary>
            <remarks>
            Return the channel this token. Each token can arrive at the parser
            on a different channel, but the parser only "tunes" to a single channel.
            The parser ignores everything not on DEFAULT_CHANNEL.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenIndex">
            <summary>An index from 0..n-1 of the token object in the input stream.</summary>
            <remarks>
            An index from 0..n-1 of the token object in the input stream.
            This must be valid in order to print token streams and
            use TokenRewriteStream.
            Return -1 to indicate that this token was conjured up since
            it doesn't have a valid index.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StartIndex">
            <summary>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </summary>
            <remarks>
            The starting character index of the token
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.StopIndex">
            <summary>The last character index of the token.</summary>
            <remarks>
            The last character index of the token.
            This method is optional; return -1 if not implemented.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.IToken.TokenSource">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which created this token.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.IToken.InputStream">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token was derived.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.EPSILON">
            <summary>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </summary>
            <remarks>
            During lookahead operations, this "token" signifies we hit rule end ATN state
            and did not follow it despite needing to.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.DefaultChannel">
            <summary>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".
            </summary>
            <remarks>
            All tokens go to the parser (unless skip() is called in that rule)
            on a particular "channel".  The parser tunes to a particular channel
            so that whitespace etc... can go to the parser on a "hidden" channel.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.HiddenChannel">
            <summary>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </summary>
            <remarks>
            Anything on different channel than DEFAULT_CHANNEL is not parsed
            by parser.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenConstants.MinUserChannelValue">
            <summary>
            This is the minimum constant value which can be assigned to a
            user-defined token channel.
            </summary>
            <remarks>
            This is the minimum constant value which can be assigned to a
            user-defined token channel.
            <p>
            The non-negative numbers less than
            <see cref="F:Antlr4.Runtime.TokenConstants.MinUserChannelValue"/>
            are
            assigned to the predefined channels
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            and
            <see cref="F:Antlr4.Runtime.TokenConstants.HiddenChannel"/>
            .</p>
            </remarks>
            <seealso cref="P:Antlr4.Runtime.IToken.Channel"/>
        </member>
        <member name="T:Antlr4.Runtime.ITokenFactory">
            <summary>The default mechanism for creating tokens.</summary>
            <remarks>
            The default mechanism for creating tokens. It's used by default in Lexer and
            the error handling strategy (to create missing tokens).  Notifying the parser
            of a new factory means that it notifies it's token source and error strategy.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Tuple{Antlr4.Runtime.ITokenSource,Antlr4.Runtime.ICharStream},System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the method used to create tokens in the lexer and in the
            error handling strategy.
            </summary>
            <remarks>
            This is the method used to create tokens in the lexer and in the
            error handling strategy. If text!=null, than the start and stop positions
            are wiped to -1 in the text override is set in the CommonToken.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ITokenFactory.Create(System.Int32,System.String)">
            <summary>Generically useful</summary>
        </member>
        <member name="T:Antlr4.Runtime.ITokenSource">
            <summary>
            A source of tokens must provide a sequence of tokens via
            <see cref="M:Antlr4.Runtime.ITokenSource.NextToken"/>
            and also must reveal it's source of characters;
            <see cref="T:Antlr4.Runtime.CommonToken"/>
            's text is
            computed from a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ; it only store indices into the char
            stream.
            <p>Errors from the lexer are never passed to the parser. Either you want to keep
            going or you do not upon token recognition error. If you do not want to
            continue lexing then you do not want to continue parsing. Just throw an
            exception not under
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            and Java will naturally toss
            you all the way out of the recognizers. If you want to continue lexing then
            you should not throw an exception to the parser--it has already requested a
            token. Keep lexing until you get a valid one. Just report errors and keep
            going, looking for a valid token.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenSource.NextToken">
            <summary>
            Return a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object from your input stream (usually a
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            ). Do not fail/return upon lexing error; keep chewing
            on the characters until you get a good one; errors are not passed through
            to the parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Line">
            <summary>Get the line number for the current position in the input stream.</summary>
            <remarks>
            Get the line number for the current position in the input stream. The
            first line in the input is line 1.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            0 if the current token source does not track line numbers.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.Column">
            <summary>
            Get the index into the current line for the current position in the input
            stream.
            </summary>
            <remarks>
            Get the index into the current line for the current position in the input
            stream. The first character on a line has position 0.
            </remarks>
            <returns>
            The line number for the current position in the input stream, or
            -1 if the current token source does not track character positions.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.InputStream">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            from which this token source is currently
            providing tokens.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ICharStream"/>
            associated with the current position in
            the input, or
            <see langword="null"/>
            if no input stream is available for the token
            source.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.SourceName">
            <summary>Gets the name of the underlying input source.</summary>
            <remarks>
            Gets the name of the underlying input source. This method returns a
            non-null, non-empty string. If such a name is not known, this method
            returns
            <see cref="F:Antlr4.Runtime.IntStreamConstants.UnknownSourceName"/>
            .
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.ITokenSource.TokenFactory">
            <summary>
            Set the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source should use for creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <value>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            to use for creating tokens.
            </value>
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            this token source is currently using for
            creating
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects from the input.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.ITokenFactory"/>
            currently used by this token source.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.ITokenStream">
            <summary>
            An
            <see cref="T:Antlr4.Runtime.IIntStream"/>
            whose symbols are
            <see cref="T:Antlr4.Runtime.IToken"/>
            instances.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.LT(System.Int32)">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance associated with the value returned by
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)">LA(k)</see>
            . This method has the same pre- and post-conditions as
            <see cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)"/>
            . In addition, when the preconditions of this method
            are met, the return value is non-null and the value of
            <c>LT(k).getType()==LA(k)</c>
            .
            </summary>
            <seealso cref="M:Antlr4.Runtime.IIntStream.LA(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IToken"/>
            at the specified
            <c>index</c>
            in the stream. When
            the preconditions of this method are met, the return value is non-null.
            <p>The preconditions for this method are the same as the preconditions of
            <see cref="M:Antlr4.Runtime.IIntStream.Seek(System.Int32)"/>
            . If the behavior of
            <c>seek(index)</c>
            is
            unspecified for the current state and given
            <c>index</c>
            , then the
            behavior of this method is also unspecified.</p>
            <p>The symbol referred to by
            <c>index</c>
            differs from
            <c>seek()</c>
            only
            in the case of filtering streams where
            <c>index</c>
            lies before the end
            of the stream. Unlike
            <c>seek()</c>
            , this method does not adjust
            <c>index</c>
            to point to a non-ignored symbol.</p>
            </summary>
            <exception cref="T:System.ArgumentException">if {code index} is less than 0</exception>
            <exception cref="T:System.NotSupportedException">
            if the stream does not support
            retrieving the token at the specified index
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ITokenStream.TokenSource">
            <summary>
            Gets the underlying
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            which provides tokens for this
            stream.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text of all tokens within the specified
            <paramref name="interval"/>
            . This
            method behaves like the following code (including potential exceptions
            for violating preconditions of
            <see cref="M:Antlr4.Runtime.ITokenStream.Get(System.Int32)"/>
            , but may be optimized by the
            specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = interval.a; i &lt;= interval.b; i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="interval">
            The interval of tokens within this stream to get text
            for.
            </param>
            <returns>
            The text of all tokens within the specified interval in this
            stream.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="interval"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText">
            <summary>Return the text of all tokens in the stream.</summary>
            <remarks>
            Return the text of all tokens in the stream. This method behaves like the
            following code, including potential exceptions from the calls to
            <see cref="P:Antlr4.Runtime.IIntStream.Size"/>
            and
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(new Interval(0, stream.size()));
            </pre>
            </remarks>
            <returns>The text of all tokens in the stream.</returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.RuleContext)">
            <summary>
            Return the text of all tokens in the source interval of the specified
            context.
            </summary>
            <remarks>
            Return the text of all tokens in the source interval of the specified
            context. This method behaves like the following code, including potential
            exceptions from the call to
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.Misc.Interval)"/>
            , but may be
            optimized by the specific implementation.
            <p>If
            <c>ctx.getSourceInterval()</c>
            does not return a valid interval of
            tokens provided by this stream, the behavior is unspecified.</p>
            <pre>
            TokenStream stream = ...;
            String text = stream.getText(ctx.getSourceInterval());
            </pre>
            </remarks>
            <param name="ctx">
            The context providing the source interval of tokens to get
            text for.
            </param>
            <returns>
            The text of all tokens within the source interval of
            <paramref name="ctx"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.ITokenStream.GetText(Antlr4.Runtime.IToken,Antlr4.Runtime.IToken)">
            <summary>
            Return the text of all tokens in this stream between
            <paramref name="start"/>
            and
            <paramref name="stop"/>
            (inclusive).
            <p>If the specified
            <paramref name="start"/>
            or
            <paramref name="stop"/>
            token was not provided by
            this stream, or if the
            <paramref name="stop"/>
            occurred before the
            <paramref name="start"/>
            token, the behavior is unspecified.</p>
            <p>For streams which ensure that the
            <see cref="P:Antlr4.Runtime.IToken.TokenIndex"/>
            method is
            accurate for all of its provided tokens, this method behaves like the
            following code. Other streams may implement this method in other ways
            provided the behavior is consistent with this at a high level.</p>
            <pre>
            TokenStream stream = ...;
            String text = "";
            for (int i = start.getTokenIndex(); i &lt;= stop.getTokenIndex(); i++) {
            text += stream.get(i).getText();
            }
            </pre>
            </summary>
            <param name="start">The first token in the interval to get text for.</param>
            <param name="stop">The last token in the interval to get text for (inclusive).</param>
            <returns>
            The text of all tokens lying between the specified
            <paramref name="start"/>
            and
            <paramref name="stop"/>
            tokens.
            </returns>
            <exception cref="T:System.NotSupportedException">
            if this stream does not support
            this method for the specified tokens
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.IVocabulary">
            <summary>
            This interface provides information about the vocabulary used by a
            recognizer.
            </summary>
            <remarks>
            This interface provides information about the vocabulary used by a
            recognizer.
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Recognizer`2.Vocabulary"/>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetLiteralName(System.Int32)">
            <summary>Gets the string literal associated with a token type.</summary>
            <remarks>
            Gets the string literal associated with a token type. The string returned
            by this method, when not
            <see langword="null"/>
            , can be used unaltered in a parser
            grammar to represent this token type.
            <p>The following table shows examples of lexer rules and the literal
            names assigned to the corresponding token types.</p>
            <table>
            <tr>
            <th>Rule</th>
            <th>Literal Name</th>
            <th>Java String Literal</th>
            </tr>
            <tr>
            <td>
            <c>THIS : 'this';</c>
            </td>
            <td>
            <c>'this'</c>
            </td>
            <td>
            <c>"'this'"</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>SQUOTE : '\'';</c>
            </td>
            <td>
            <c>'\''</c>
            </td>
            <td>
            <c>"'\\''"</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>ID : [A-Z]+;</c>
            </td>
            <td>n/a</td>
            <td>
            <see langword="null"/>
            </td>
            </tr>
            </table>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The string literal associated with the specified token type, or
            <see langword="null"/>
            if no string literal is associated with the type.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetSymbolicName(System.Int32)">
            <summary>Gets the symbolic name associated with a token type.</summary>
            <remarks>
            Gets the symbolic name associated with a token type. The string returned
            by this method, when not
            <see langword="null"/>
            , can be used unaltered in a parser
            grammar to represent this token type.
            <p>This method supports token types defined by any of the following
            methods:</p>
            <ul>
            <li>Tokens created by lexer rules.</li>
            <li>Tokens defined in a
            <c/>
            tokens
            block in a lexer or parser
            grammar.</li>
            <li>The implicitly defined
            <c>EOF</c>
            token, which has the token type
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            .</li>
            </ul>
            <p>The following table shows examples of lexer rules and the literal
            names assigned to the corresponding token types.</p>
            <table>
            <tr>
            <th>Rule</th>
            <th>Symbolic Name</th>
            </tr>
            <tr>
            <td>
            <c>THIS : 'this';</c>
            </td>
            <td>
            <c>THIS</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>SQUOTE : '\'';</c>
            </td>
            <td>
            <c>SQUOTE</c>
            </td>
            </tr>
            <tr>
            <td>
            <c>ID : [A-Z]+;</c>
            </td>
            <td>
            <c>ID</c>
            </td>
            </tr>
            </table>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The symbolic name associated with the specified token type, or
            <see langword="null"/>
            if no symbolic name is associated with the type.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.IVocabulary.GetDisplayName(System.Int32)">
            <summary>Gets the display name of a token type.</summary>
            <remarks>
            Gets the display name of a token type.
            <p>ANTLR provides a default implementation of this method, but
            applications are free to override the behavior in any manner which makes
            sense for the application. The default implementation returns the first
            result from the following list which produces a non-
            <see langword="null"/>
            result.</p>
            <ol>
            <li>The result of
            <see cref="M:Antlr4.Runtime.IVocabulary.GetLiteralName(System.Int32)"/>
            </li>
            <li>The result of
            <see cref="M:Antlr4.Runtime.IVocabulary.GetSymbolicName(System.Int32)"/>
            </li>
            <li>The result of
            <see cref="M:System.Int32.ToString"/>
            </li>
            </ol>
            </remarks>
            <param name="tokenType">The token type.</param>
            <returns>
            The display name of the token type, for use in error reporting or
            other user-visible messages which reference specific token types.
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Lexer">
            <summary>A lexer is recognizer that draws input symbols from a character stream.</summary>
            <remarks>
            A lexer is recognizer that draws input symbols from a character stream.
            lexer grammars result in a subclass of this object. A Lexer object
            uses simplified match() and error recovery mechanisms in the interest
            of speed.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._factory">
            <summary>How to create token objects</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._token">
            <summary>The goal of all lexer rules/methods is to create a token object.</summary>
            <remarks>
            The goal of all lexer rules/methods is to create a token object.
            This is an instance variable as multiple rules may collaborate to
            create a single token.  nextToken will return this object after
            matching lexer rule(s).  If you subclass to allow multiple token
            emissions, then set this to the last token to be matched or
            something nonnull so that the auto token emit mechanism will not
            emit another token.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartCharIndex">
            <summary>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.
            </summary>
            <remarks>
            What character index in the stream did the current token start at?
            Needed, for example, to get the text for current token.  Set at
            the start of nextToken.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartLine">
            <summary>The line on which the first character of the token resides</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._tokenStartColumn">
            <summary>The character position of first character within the line</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._hitEOF">
            <summary>Once we see EOF on char stream, next token will be EOF.</summary>
            <remarks>
            Once we see EOF on char stream, next token will be EOF.
            If you have DONE : EOF ; then you see DONE EOF.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._channel">
            <summary>The channel number for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._type">
            <summary>The token type for the current token</summary>
        </member>
        <member name="F:Antlr4.Runtime.Lexer._text">
            <summary>
            You can set the text for the current token to override what is in
            the input char buffer.
            </summary>
            <remarks>
            You can set the text for the current token to override what is in
            the input char buffer.  Use setText() or can set this instance var.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.NextToken">
            <summary>
            Return a token from this source; i.e., match a token on the char
            stream.
            </summary>
            <remarks>
            Return a token from this source; i.e., match a token on the char
            stream.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Skip">
            <summary>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.
            </summary>
            <remarks>
            Instruct the lexer to skip creating a token for current lexer rule
            and look for another token.  nextToken() knows to keep looking when
            a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
            if token==null at end of any token rule, it creates one for you
            and emits it.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.SetInputStream(Antlr4.Runtime.ICharStream)">
            <summary>Set the char stream and reset the lexer</summary>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit(Antlr4.Runtime.IToken)">
            <summary>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.
            </summary>
            <remarks>
            By default does not support multiple emits per nextToken invocation
            for efficiency reasons.  Subclass and override this method, nextToken,
            and getToken (to push tokens into a list and pull from that list
            rather than a single variable as this implementation does).
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Emit">
            <summary>
            The standard method called to automatically emit a token at the
            outermost lexical rule.
            </summary>
            <remarks>
            The standard method called to automatically emit a token at the
            outermost lexical rule.  The token object should point into the
            char buffer start..stop.  If there is a text override in 'text',
            use that to set the token's text.  Override this method to emit
            custom Token objects or provide a new factory.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.CharIndex">
            <summary>What is the index of the current character of lookahead?</summary>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Text">
            <summary>
            Return the text matched so far for the current token or any text
            override.
            </summary>
            <remarks>
            Return the text matched so far for the current token or any text
            override.
            </remarks>
            <summary>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </summary>
            <remarks>
            Set the complete text of this token; it wipes any previous changes to the
            text.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Lexer.Token">
            <summary>Override if emitting multiple tokens.</summary>
            <remarks>Override if emitting multiple tokens.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.GetAllTokens">
            <summary>Return a list of all Token objects in input char stream.</summary>
            <remarks>
            Return a list of all Token objects in input char stream.
            Forces load of all tokens. Does not include EOF token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Lexer.Recover(Antlr4.Runtime.RecognitionException)">
            <summary>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.
            </summary>
            <remarks>
            Lexers can normally match any char in it's vocabulary after matching
            a token, so do the easy thing and just kill a character and hope
            it all works out.  You can instead use the rule invocation stack
            to do sophisticated error recovery if you are in a fragment rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.startIndex">
            <summary>Matching attempted at what input index?</summary>
        </member>
        <member name="F:Antlr4.Runtime.LexerNoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LA(1)?</summary>
        </member>
        <member name="T:Antlr4.Runtime.ListTokenSource">
            <summary>
            Provides an implementation of
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            as a wrapper around a list
            of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            <p>If the final token in the list is an
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            token, it will be used
            as the EOF token for every call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            after the end of the
            list is reached. Otherwise, an EOF token will be created.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.tokens">
            <summary>
            The wrapped collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to return.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.sourceName">
            <summary>The name of the input source.</summary>
            <remarks>
            The name of the input source. If this value is
            <see langword="null"/>
            , a call to
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            should return the source name used to create the
            the next token in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            (or the previous token if the end of
            the input has been reached).
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.i">
            <summary>
            The index into
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            of token to return by the next call to
            <see cref="M:Antlr4.Runtime.ListTokenSource.NextToken"/>
            . The end of the input is indicated by this value
            being greater than or equal to the number of items in
            <see cref="F:Antlr4.Runtime.ListTokenSource.tokens"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource.eofToken">
            <summary>This field caches the EOF token for the token source.</summary>
            <remarks>This field caches the EOF token for the token source.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.ListTokenSource._factory">
            <summary>
            This is the backing field for the <see cref="P:Antlr4.Runtime.ListTokenSource.TokenFactory"/> property.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken})">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <exception>
            NullPointerException
            if
            <paramref name="tokens"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.#ctor(System.Collections.Generic.IList{Antlr4.Runtime.IToken},System.String)">
            <summary>
            Constructs a new
            <see cref="T:Antlr4.Runtime.ListTokenSource"/>
            instance from the specified
            collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects and source name.
            </summary>
            <param name="tokens">
            The collection of
            <see cref="T:Antlr4.Runtime.IToken"/>
            objects to provide as a
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            .
            </param>
            <param name="sourceName">
            The name of the
            <see cref="T:Antlr4.Runtime.ITokenSource"/>
            . If this value is
            <see langword="null"/>
            ,
            <see cref="P:Antlr4.Runtime.ListTokenSource.SourceName"/>
            will attempt to infer the name from
            the next
            <see cref="T:Antlr4.Runtime.IToken"/>
            (or the previous token if the end of the input has
            been reached).
            </param>
            <exception>
            NullPointerException
            if
            <paramref name="tokens"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Column">
            <summary><inheritDoc/></summary>
        </member>
        <member name="M:Antlr4.Runtime.ListTokenSource.NextToken">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.Line">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.InputStream">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.SourceName">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.ListTokenSource.TokenFactory">
            <summary><inheritDoc/></summary>
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Args">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Args.NotNull(System.String,System.Object)">
            <exception cref="T:System.ArgumentNullException">
            if
            <paramref name="value"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IIntSet">
            <summary>A generic set of integers.</summary>
            <remarks>A generic set of integers.</remarks>
            <seealso cref="T:Antlr4.Runtime.Misc.IntervalSet"/>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Add(System.Int32)">
            <summary>Adds the specified value to the current set.</summary>
            <remarks>Adds the specified value to the current set.</remarks>
            <param name="el">the value to add</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)">
             <summary>
             Modify the current
             <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
             object to contain all elements that are
             present in itself, the specified
             <paramref name="set"/>
             , or both.
             </summary>
             <param name="set">
             The set to add to the current set. A
             <see langword="null"/>
             argument is
             treated as though it were an empty set.
             </param>
             <returns>
            
             <c>this</c>
             (to support chained calls)
             </returns>
             <exception>
             IllegalStateException
             if the current set is read-only
             </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.And(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in both the current set and the specified set
            <paramref name="a"/>
            .
            </summary>
            <param name="a">
            The set to intersect with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the intersection of the
            current set and
            <paramref name="a"/>
            . The value
            <see langword="null"/>
            may be returned in
            place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in
            <paramref name="elements"/>
            but not present in the current set. The
            following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <c>x</c>
            and
            <c>y</c>
            .
            <ul>
            <li>
            <c>x.complement(y)</c>
            </li>
            <li>
            <c>y.subtract(x)</c>
            </li>
            </ul>
            </summary>
            <param name="elements">
            The set to compare with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <paramref name="elements"/>
            but not present in the current set. The value
            <see langword="null"/>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Or(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set, the specified set
            <paramref name="a"/>
            , or both.
            <p>
            This method is similar to
            <see cref="M:Antlr4.Runtime.Misc.IIntSet.AddAll(Antlr4.Runtime.Misc.IIntSet)"/>
            , but returns a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance instead of modifying the current set.</p>
            </summary>
            <param name="a">
            The set to union with the current set. A
            <see langword="null"/>
            argument
            is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the union of the current
            set and
            <paramref name="a"/>
            . The value
            <see langword="null"/>
            may be returned in place of an
            empty result set.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Subtract(Antlr4.Runtime.Misc.IIntSet)">
            <summary>
            Return a new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            object containing all elements that are
            present in the current set but not present in the input set
            <paramref name="a"/>
            .
            The following expressions are equivalent for input non-null
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instances
            <c>x</c>
            and
            <c>y</c>
            .
            <ul>
            <li>
            <c>y.subtract(x)</c>
            </li>
            <li>
            <c>x.complement(y)</c>
            </li>
            </ul>
            </summary>
            <param name="a">
            The set to compare with the current set. A
            <see langword="null"/>
            argument is treated as though it were an empty set.
            </param>
            <returns>
            A new
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            instance containing the elements present in
            <c>elements</c>
            but not present in the current set. The value
            <see langword="null"/>
            may be returned in place of an empty result set.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.Count">
            <summary>Return the total number of elements represented by the current set.</summary>
            <remarks>Return the total number of elements represented by the current set.</remarks>
            <returns>
            the total number of elements represented by the current set,
            regardless of the manner in which the elements are stored.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.IsNil">
             <summary>
             Returns
             <see langword="true"/>
             if this set contains no elements.
             </summary>
             <returns>
            
             <see langword="true"/>
             if the current set contains no elements; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Equals(System.Object)">
            <summary><inheritDoc/></summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IIntSet.SingleElement">
            <summary>
            Returns the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </summary>
            <returns>
            the single value contained in the set, if
            <see cref="P:Antlr4.Runtime.Misc.IIntSet.Count"/>
            is 1;
            otherwise, returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Contains(System.Int32)">
             <summary>
             Returns
             <see langword="true"/>
             if the set contains the specified element.
             </summary>
             <param name="el">The element to check for.</param>
             <returns>
            
             <see langword="true"/>
             if the set contains
             <paramref name="el"/>
             ; otherwise
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.Remove(System.Int32)">
            <summary>Removes the specified value from the current set.</summary>
            <remarks>
            Removes the specified value from the current set. If the current set does
            not contain the element, no changes are made.
            </remarks>
            <param name="el">the value to remove</param>
            <exception>
            IllegalStateException
            if the current set is read-only
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToList">
            <summary>Return a list containing the elements represented by the current set.</summary>
            <remarks>
            Return a list containing the elements represented by the current set. The
            list is returned in ascending numerical order.
            </remarks>
            <returns>
            A list containing all element present in the current set, sorted
            in ascending numerical order.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IIntSet.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.Interval">
            <summary>An immutable inclusive interval a..b.</summary>
            <remarks>An immutable inclusive interval a..b.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.a">
            <summary>The start of the interval.</summary>
            <remarks>The start of the interval.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Misc.Interval.b">
            <summary>The end of the interval (inclusive).</summary>
            <remarks>The end of the interval (inclusive).</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Of(System.Int32,System.Int32)">
            <summary>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.
            </summary>
            <remarks>
            Interval objects are used readonly so share all with the
            same single value a==b up to some max size.  Use an array as a perfect hash.
            Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new
            Interval object with a..a in it.  On Java.g4, 218623 IntervalSets
            have a..a (set with 1 element).
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Misc.Interval.Length">
            <summary>return number of elements between a and b inclusively.</summary>
            <remarks>
            return number of elements between a and b inclusively. x..x is length 1.
            if b &lt; a, then length is 0. 9..10 has length 2.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely before other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsBeforeNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start at or before other? Nondisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfter(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this.a start after other.b? May or may not be disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start completely after other? Disjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.StartsAfterNonDisjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Does this start after other? NonDisjoint</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Disjoint(Antlr4.Runtime.Misc.Interval)">
            <summary>Are both ranges disjoint? I.e., no overlap?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Adjacent(Antlr4.Runtime.Misc.Interval)">
            <summary>Are two intervals adjacent such as 0..41 and 42..42?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Union(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval computed from combining this and other</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.Intersection(Antlr4.Runtime.Misc.Interval)">
            <summary>Return the interval in common between this and o</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Interval.DifferenceNotProperlyContained(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the interval with elements from
            <c>this</c>
            not in
            <paramref name="other"/>
            ;
            <paramref name="other"/>
            must not be totally enclosed (properly contained)
            within
            <c>this</c>
            , which would result in two disjoint intervals
            instead of the single one returned by this method.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Misc.IntervalSet">
            <summary>
            This class implements the
            <see cref="T:Antlr4.Runtime.Misc.IIntSet"/>
            backed by a sorted array of
            non-overlapping intervals. It is particularly efficient for representing
            large collections of numbers, where the majority of elements appear as part
            of a sequential range of numbers that are all part of the set. For example,
            the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.
            <p>
            This class is able to represent sets containing any combination of values in
            the range
            <see cref="F:System.Int32.MinValue"/>
            to
            <see cref="F:System.Int32.MaxValue"/>
            (inclusive).</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Misc.IntervalSet.intervals">
            <summary>The list of sorted, disjoint intervals.</summary>
            <remarks>The list of sorted, disjoint intervals.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32)">
            <summary>Create a set with a single element, el.</summary>
            <remarks>Create a set with a single element, el.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Of(System.Int32,System.Int32)">
            <summary>Create a set with all ints within range [a..b] (inclusive)</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32)">
            <summary>Add a single element to the set.</summary>
            <remarks>
            Add a single element to the set.  An isolated element is stored
            as a range el..el.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Add(System.Int32,System.Int32)">
            <summary>Add interval; i.e., add all integers from a to b to set.</summary>
            <remarks>
            Add interval; i.e., add all integers from a to b to set.
            If b&lt;a, do nothing.
            Keep list in sorted order (by left range value).
            If overlap, combine ranges.  For example,
            If this is {1..5, 10..20}, adding 6..7 yields
            {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Or(Antlr4.Runtime.Misc.IntervalSet[])">
            <summary>combine all sets in the array returned the or'd value</summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Complement(Antlr4.Runtime.Misc.IIntSet)">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Subtract(Antlr4.Runtime.Misc.IntervalSet,Antlr4.Runtime.Misc.IntervalSet)">
            <summary>Compute the set difference between two interval sets.</summary>
            <remarks>
            Compute the set difference between two interval sets. The specific
            operation is
            <c>left - right</c>
            . If either of the input sets is
            <see langword="null"/>
            , it is treated as though it was an empty set.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.And(Antlr4.Runtime.Misc.IIntSet)">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Contains(System.Int32)">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.IsNil">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.SingleElement">
             <summary>
             <inheritDoc/>
            
             </summary>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MaxElement">
            <summary>Returns the maximum value contained in the set.</summary>
            <remarks>Returns the maximum value contained in the set.</remarks>
            <returns>
            the maximum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Misc.IntervalSet.MinElement">
            <summary>Returns the minimum value contained in the set.</summary>
            <remarks>Returns the minimum value contained in the set.</remarks>
            <returns>
            the minimum value contained in the set. If the set is empty, this
            method returns
            <see cref="F:Antlr4.Runtime.TokenConstants.InvalidType"/>
            .
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.GetIntervals">
            <summary>Return a list of Interval objects.</summary>
            <remarks>Return a list of Interval objects.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Misc.IntervalSet.Equals(System.Object)">
            <summary>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.
            </summary>
            <remarks>
            Are two IntervalSets equal?  Because all intervals are sorted
            and disjoint, equals is a simple linear walk over both lists
            to make sure they are the same.  Interval.equals() is used
            by the List.equals() method to check the ranges.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Misc.MurmurHash">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize">
            <summary>Initialize the hash using the default seed value.</summary>
            <remarks>Initialize the hash using the default seed value.</remarks>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Initialize(System.Int32)">
            <summary>
            Initialize the hash using the specified
            <paramref name="seed"/>
            .
            </summary>
            <param name="seed">the seed</param>
            <returns>the intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Int32)">
            <summary>
            Update the intermediate hash value for the next input
            <paramref name="value"/>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Update(System.Int32,System.Object)">
            <summary>
            Update the intermediate hash value for the next input
            <paramref name="value"/>
            .
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="value">the value to add to the current hash</param>
            <returns>the updated intermediate hash value</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.Finish(System.Int32,System.Int32)">
            <summary>
            Apply the final computation steps to the intermediate value
            <paramref name="hash"/>
            to form the final result of the MurmurHash 3 hash function.
            </summary>
            <param name="hash">the intermediate hash value</param>
            <param name="numberOfWords">the number of integer values added to the hash</param>
            <returns>the final hash result</returns>
        </member>
        <member name="M:Antlr4.Runtime.Misc.MurmurHash.HashCode``1(``0[],System.Int32)">
            <summary>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </summary>
            <remarks>
            Utility function to compute the hash code of an array using the
            MurmurHash algorithm.
            </remarks>
            <param name="data">the array data</param>
            <param name="seed">the seed for the MurmurHash algorithm</param>
            <returns>the hash code of the data</returns>
        </member>
        <member name="T:Antlr4.Runtime.Misc.ParseCanceledException">
            <summary>This exception is thrown to cancel a parsing operation.</summary>
            <remarks>
            This exception is thrown to cancel a parsing operation. This exception does
            not extend
            <see cref="T:Antlr4.Runtime.RecognitionException"/>
            , allowing it to bypass the standard
            error recovery mechanisms.
            <see cref="T:Antlr4.Runtime.BailErrorStrategy"/>
            throws this exception in
            response to a parse error.
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.Misc.RuleDependencyChecker">
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Misc.Utils.ToMap(System.String[])">
            <summary>Convert array of strings to string&#x2192;index map.</summary>
            <remarks>
            Convert array of strings to string&#x2192;index map. Useful for
            converting rulenames to name&#x2192;ruleindex map.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.NoViableAltException">
            <summary>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input.
            </summary>
            <remarks>
            Indicates that the parser could not decide which of two or more paths
            to take based upon the remaining input. It tracks the starting token
            of the offending input and also knows where the parser was
            in the various paths when the error. Reported by reportNoViableAlternative()
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.deadEndConfigs">
            <summary>Which configurations did we try at input.index() that couldn't match input.LT(1)?</summary>
        </member>
        <member name="F:Antlr4.Runtime.NoViableAltException.startToken">
            <summary>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it.
            </summary>
            <remarks>
            The token object at the start index; the input stream might
            not be buffering tokens so get a reference to it. (At the
            time the error occurred, of course the stream needs to keep a
            buffer all of the tokens but later we might not have access to those.)
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Parser">
            <summary>This is all the parsing support code essentially; most of it is error recovery stuff.</summary>
            <remarks>This is all the parsing support code essentially; most of it is error recovery stuff.</remarks>
        </member>
        <member name="F:Antlr4.Runtime.Parser.bypassAltsAtnCache">
            <summary>
            This field maps from the serialized ATN string to the deserialized
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            with
            bypass alternatives.
            </summary>
            <seealso cref="P:Antlr4.Runtime.Atn.ATNDeserializationOptions.GenerateRuleBypassTransitions"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._errHandler">
            <summary>The error handling strategy for the parser.</summary>
            <remarks>
            The error handling strategy for the parser. The default value is a new
            instance of
            <see cref="T:Antlr4.Runtime.DefaultErrorStrategy"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.ErrorHandler"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._input">
            <summary>The input stream.</summary>
            <remarks>The input stream.</remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.InputStream"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._ctx">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
            object for the currently executing rule.
            This is always non-null during the parsing process.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._buildParseTrees">
            <summary>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process.
            </summary>
            <remarks>
            Specifies whether or not the parser should construct a parse tree during
            the parsing process. The default value is
            <see langword="true"/>
            .
            </remarks>
            <seealso cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._tracer">
            <summary>
            When
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <c>(true)</c>
            is called, a reference to the
            <see cref="T:Antlr4.Runtime.Parser.TraceListener"/>
            is stored here so it can be easily removed in a
            later call to
            <see cref="P:Antlr4.Runtime.Parser.Trace"/>
            <c>(false)</c>
            . The listener itself is
            implemented as a parser listener so this field is not directly used by
            other parser methods.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Parser._parseListeners">
            <summary>
            The list of
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeListener"/>
            listeners registered to receive
            events during the parse.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="F:Antlr4.Runtime.Parser._syntaxErrors">
            <summary>The number of syntax errors reported during parsing.</summary>
            <remarks>
            The number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Reset">
            <summary>reset the parser's state</summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Match(System.Int32)">
            <summary>
            Match current input symbol against
            <paramref name="ttype"/>
            . If the symbol type
            matches,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are
            called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <see langword="true"/>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </summary>
            <param name="ttype">the token type to match</param>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            <paramref name="ttype"/>
            and the error strategy could not recover from the
            mismatched symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.MatchWildcard">
            <summary>Match current input symbol as a wildcard.</summary>
            <remarks>
            Match current input symbol as a wildcard. If the symbol type matches
            (i.e. has a value greater than 0),
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.ReportMatch(Antlr4.Runtime.Parser)"/>
            and
            <see cref="M:Antlr4.Runtime.Parser.Consume"/>
            are called to complete the match process.
            <p>If the symbol type does not match,
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is called on the current error
            strategy to attempt recovery. If
            <see cref="P:Antlr4.Runtime.Parser.BuildParseTree"/>
            is
            <see langword="true"/>
            and the token index of the symbol returned by
            <see cref="M:Antlr4.Runtime.IAntlrErrorStrategy.RecoverInline(Antlr4.Runtime.Parser)"/>
            is -1, the symbol is added to
            the parse tree by calling
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            .</p>
            </remarks>
            <returns>the matched symbol</returns>
            <exception cref="T:Antlr4.Runtime.RecognitionException">
            if the current input symbol did not match
            a wildcard and the error strategy could not recover from the mismatched
            symbol
            </exception>
            <exception cref="T:Antlr4.Runtime.RecognitionException"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.BuildParseTree">
             <summary>
             Track the
             <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
             objects during the parse and hook
             them up using the
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list so that it
             forms a parse tree. The
             <see cref="T:Antlr4.Runtime.ParserRuleContext"/>
             returned from the start
             rule represents the root of the parse tree.
             <p>Note that if we are not building parse trees, rule contexts only point
             upwards. When a rule exits, it returns the context but that gets garbage
             collected if nobody holds a reference. It points upwards but nobody
             points at it.</p>
             <p>When we build parse trees, we are adding all of these contexts to
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list. Contexts are then not candidates
             for garbage collection.</p>
             </summary>
             <summary>
             Gets whether or not a complete parse tree will be constructed while
             parsing.
             </summary>
             <remarks>
             Gets whether or not a complete parse tree will be constructed while
             parsing. This property is
             <see langword="true"/>
             for a newly constructed parser.
             </remarks>
             <returns>
            
             <see langword="true"/>
             if a complete parse tree will be constructed while
             parsing, otherwise
             <see langword="false"/>
             </returns>
        </member>
        <member name="P:Antlr4.Runtime.Parser.TrimParseTree">
             <summary>Trim the internal lists of the parse tree during parsing to conserve memory.</summary>
             <remarks>
             Trim the internal lists of the parse tree during parsing to conserve memory.
             This property is set to
             <see langword="false"/>
             by default for a newly constructed parser.
             </remarks>
             <value>
            
             <see langword="true"/>
             to trim the capacity of the
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list to its size after a rule is parsed.
             </value>
             <returns>
            
             <see langword="true"/>
             if the
             <see cref="F:Antlr4.Runtime.ParserRuleContext.children"/>
             list is trimmed
             using the default
             <see cref="T:Antlr4.Runtime.Parser.TrimToSizeListener"/>
             during the parse process.
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Registers
            <paramref name="listener"/>
            to receive events during the parsing process.
            <p>To support output-preserving grammar transformations (including but not
            limited to left-recursion removal, automated left-factoring, and
            optimized code generation), calls to listener methods during the parse
            may differ substantially from calls made by
            <see cref="F:Antlr4.Runtime.Tree.ParseTreeWalker.Default"/>
            used after the parse is complete. In
            particular, rule entry and exit events may occur in a different order
            during the parse than after the parser. In addition, calls to certain
            rule entry methods may be omitted.</p>
            <p>With the following specific exceptions, calls to listener events are
            <em>deterministic</em>, i.e. for identical input the calls to listener
            methods will be the same.</p>
            <ul>
            <li>Alterations to the grammar used to generate code may change the
            behavior of the listener calls.</li>
            <li>Alterations to the command line options passed to ANTLR 4 when
            generating the parser may change the behavior of the listener calls.</li>
            <li>Changing the version of the ANTLR Tool used to generate the parser
            may change the behavior of the listener calls.</li>
            </ul>
            </summary>
            <param name="listener">the listener to add</param>
            <exception cref="T:System.ArgumentNullException">
            if
            <c/>
            listener is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListener(Antlr4.Runtime.Tree.IParseTreeListener)">
            <summary>
            Remove
            <paramref name="listener"/>
            from the list of parse listeners.
            <p>If
            <paramref name="listener"/>
            is
            <see langword="null"/>
            or has not been added as a parse
            listener, this method does nothing.</p>
            </summary>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
            <param name="listener">the listener to remove</param>
        </member>
        <member name="M:Antlr4.Runtime.Parser.RemoveParseListeners">
            <summary>Remove all parse listeners.</summary>
            <remarks>Remove all parse listeners.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerEnterRuleEvent">
            <summary>Notify any parse listeners of an enter rule event.</summary>
            <remarks>Notify any parse listeners of an enter rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.TriggerExitRuleEvent">
            <summary>Notify any parse listeners of an exit rule event.</summary>
            <remarks>Notify any parse listeners of an exit rule event.</remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.AddParseListener(Antlr4.Runtime.Tree.IParseTreeListener)"/>
        </member>
        <member name="P:Antlr4.Runtime.Parser.NumberOfSyntaxErrors">
            <summary>Gets the number of syntax errors reported during parsing.</summary>
            <remarks>
            Gets the number of syntax errors reported during parsing. This value is
            incremented each time
            <see cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
            is called.
            </remarks>
            <seealso cref="M:Antlr4.Runtime.Parser.NotifyErrorListeners(System.String)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetATNWithBypassAlts">
            <summary>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </summary>
            <remarks>
            The ATN with bypass alternatives is expensive to create so we create it
            lazily.
            </remarks>
            <exception cref="T:System.NotSupportedException">
            if the current parser does not
            implement the
            <see cref="P:Antlr4.Runtime.Recognizer`2.SerializedAtn"/>
            method.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)">
            <summary>The preferred method of getting a tree pattern.</summary>
            <remarks>
            The preferred method of getting a tree pattern. For example, here's a
            sample use:
            <pre>
            ParseTree t = parser.expr();
            ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0", MyParser.RULE_expr);
            ParseTreeMatch m = p.match(t);
            String id = m.get("ID");
            </pre>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32,Antlr4.Runtime.Lexer)">
            <summary>
            The same as
            <see cref="M:Antlr4.Runtime.Parser.CompileParseTreePattern(System.String,System.Int32)"/>
            but specify a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            rather than trying to deduce it from this parser.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Parser.CurrentToken">
            <summary>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </summary>
            <remarks>
            Match needs to return the current input symbol, which gets put
            into the label for the associated token ref; e.g., x=ID.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.Consume">
            <summary>
            Consume and return the
            <linkplain>
            #getCurrentToken
            current symbol
            </linkplain>
            .
            <p>E.g., given the following input with
            <c>A</c>
            being the current
            lookahead symbol, this function moves the cursor to
            <c>B</c>
            and returns
            <c>A</c>
            .</p>
            <pre>
            A B
            ^
            </pre>
            If the parser is not in error recovery mode, the consumed symbol is added
            to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)"/>
            is called on any parse listeners.
            If the parser <em>is</em> in error recovery mode, the consumed symbol is
            added to the parse tree using
            <see cref="M:Antlr4.Runtime.ParserRuleContext.AddErrorNode(Antlr4.Runtime.IToken)"/>
            , and
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)"/>
            is called on any parse
            listeners.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>Always called by generated parsers upon entry to a rule.</summary>
            <remarks>
            Always called by generated parsers upon entry to a rule. Access field
            <see cref="F:Antlr4.Runtime.Parser._ctx"/>
            get the current context.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Precedence">
            <summary>Get the precedence level for the top-most precedence rule.</summary>
            <remarks>Get the precedence level for the top-most precedence rule.</remarks>
            <returns>
            The precedence level for the top-most precedence rule, or -1 if
            the parser context is not nested within a precedence rule.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.PushNewRecursionContext(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)">
            <summary>
            Like
            <see cref="M:Antlr4.Runtime.Parser.EnterRule(Antlr4.Runtime.ParserRuleContext,System.Int32,System.Int32)"/>
            but for recursive rules.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.IsExpectedToken(System.Int32)">
             <summary>
             Checks whether or not
             <paramref name="symbol"/>
             can follow the current state in the
             ATN. The behavior of this method is equivalent to the following, but is
             implemented such that the complete context-sensitive follow set does not
             need to be explicitly constructed.
             <pre>
             return getExpectedTokens().contains(symbol);
             </pre>
             </summary>
             <param name="symbol">the symbol type to check</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="symbol"/>
             can follow the current state in
             the ATN, otherwise
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetExpectedTokens">
            <summary>
            Computes the set of input symbols which could follow the current parser
            state and context, as given by
            <see cref="P:Antlr4.Runtime.Recognizer`2.State"/>
            and
            <see cref="P:Antlr4.Runtime.Parser.Context"/>
            ,
            respectively.
            </summary>
            <seealso cref="M:Antlr4.Runtime.Atn.ATN.GetExpectedTokens(System.Int32,Antlr4.Runtime.RuleContext)"/>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleIndex(System.String)">
            <summary>
            Get a rule's index (i.e.,
            <c>RULE_ruleName</c>
            field) or -1 if not found.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetRuleInvocationStack">
            <summary>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.
            </summary>
            <remarks>
            Return List&lt;String&gt; of the rule names in your parser instance
            leading up to a call to the current rule.  You could override if
            you want more details such as the file/line info of where
            in the ATN a rule is invoked.
            This is very useful for error messages.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.GetDFAStrings">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Parser.DumpDFA">
            <summary>For debugging and other purposes.</summary>
            <remarks>For debugging and other purposes.</remarks>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Profile">
            <since>4.3</since>
        </member>
        <member name="P:Antlr4.Runtime.Parser.Trace">
            <summary>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches.
            </summary>
            <remarks>
            During a parse is sometimes useful to listen in on the rule entry and exit
            events as well as token matches. This is for quick and dirty debugging.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.ParserInterpreter">
            <summary>
            A parser simulator that mimics what ANTLR's generated
            parser code does.
            </summary>
            <remarks>
            A parser simulator that mimics what ANTLR's generated
            parser code does. A ParserATNSimulator is used to make
            predictions via adaptivePredict but this class moves a pointer through the
            ATN to simulate parsing. ParserATNSimulator just
            makes us efficient rather than having to backtrack, for example.
            This properly creates parse trees even for left recursive rules.
            We rely on the left recursive rule invocation and special predicate
            transitions to make left recursive rules work.
            See TestParserInterpreter for examples.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserInterpreter.Parse(System.Int32)">
            <summary>Begin parsing at startRuleIndex</summary>
        </member>
        <member name="T:Antlr4.Runtime.ParserRuleContext">
            <summary>A rule invocation record for parsing.</summary>
            <remarks>
            A rule invocation record for parsing.
            Contains all of the information about the current rule not stored in the
            RuleContext. It handles parse tree children list, Any ATN state
            tracing, and the default values available for rule indications:
            start, stop, rule index, current alt number, current
            ATN state.
            Subclasses made for each rule and grammar track the parameters,
            return values, locals, and labels specific to that rule. These
            are the objects that are returned from rules.
            Note text is not an actual field of a rule return value; it is computed
            from start and stop using the input stream's toString() method.  I
            could add a ctor to this so that we can pass in and store the input
            stream, but I'm not sure we want to do that.  It would seem to be undefined
            to get the .text property anyway if the rule matches tokens from multiple
            input streams.
            I do not use getters for fields of objects that are used simply to
            group values such as this aggregate.  The getters/setters are there to
            satisfy the superclass interface.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.children">
            <summary>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context.
            </summary>
            <remarks>
            If we are debugging or building a parse tree for a visitor,
            we need to track all of the tokens and rule invocations associated
            with this rule's context. This is empty for parsing w/o tree constr.
            operation because we don't the need to track the details about
            how we parse this rule.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext._start">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext._stop">
            <summary>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            </summary>
            <remarks>
            For debugging/tracing purposes, we want to track all of the nodes in
            the ATN traversed by the parser for a particular rule.
            This list indicates the sequence of ATN nodes used to match
            the elements of the children list. This list does not include
            ATN nodes and other rules used to match rule invocations. It
            traces the rule invocation node itself but nothing inside that
            other rule's ATN submachine.
            There is NOT a one-to-one correspondence between the children and
            states list. There are typically many nodes in the ATN traversed
            for each element in the children list. For example, for a rule
            invocation there is the invoking state and the following state.
            The parser setState() method updates field s and adds it to this list
            if we are debugging/tracing.
            This does not trace states visited during prediction.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.ParserRuleContext.exception">
            <summary>The exception that forced this rule to return.</summary>
            <remarks>
            The exception that forced this rule to return. If the rule successfully
            completed, this is
            <see langword="null"/>
            .
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.CopyFrom(Antlr4.Runtime.ParserRuleContext)">
             <summary>
             COPY a ctx (I'm deliberately not using copy constructor) to avoid
             confusion with creating node with parent. Does not copy children.
            
             This is used in the generated parser code to flip a generic XContext
             node for rule X to a YContext for alt label Y. In that sense, it is
             not really a generic copy function.
            
             If we do an error sync() at start of a rule, we might add error nodes
             to the generic XContext so this function must copy those nodes to
             the YContext as well else they are lost!
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.AddChild(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Does not set parent link; other add methods do that</summary>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.RemoveLastChild">
            <summary>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule.
            </summary>
            <remarks>
            Used by enterOuterAlt to toss out a RuleContext previously added as
            we entered a rule. If we have # label, we will need to remove
            generic ruleContext object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.ParserRuleContext.ToInfoString(Antlr4.Runtime.Parser)">
            <summary>Used for rule context info debugging during parse-time, not so much for ATN debugging</summary>
        </member>
        <member name="T:Antlr4.Runtime.ProxyErrorListener`1">
            <summary>
            This implementation of
            <see cref="T:Antlr4.Runtime.IAntlrErrorListener`1"/>
            dispatches all calls to a
            collection of delegate listeners. This reduces the effort required to support multiple
            listeners.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.ProxyParserErrorListener">
            <author>Sam Harwell</author>
        </member>
        <member name="T:Antlr4.Runtime.RecognitionException">
            <summary>The root of the ANTLR exception hierarchy.</summary>
            <remarks>
            The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
            3 kinds of errors: prediction errors, failed predicate errors, and
            mismatched input errors. In each case, the parser knows where it is
            in the input, where it is in the ATN, the rule invocation stack,
            and what kind of problem occurred.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.recognizer">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception originated.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.RecognitionException.offendingToken">
            <summary>
            The current
            <see cref="T:Antlr4.Runtime.IToken"/>
            when an error occurred. Since not all streams
            support accessing symbols by index, we have to track the
            <see cref="T:Antlr4.Runtime.IToken"/>
            instance itself.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.OffendingState">
            <summary>
            Get the ATN state number the parser was in at the time the error
            occurred.
            </summary>
            <remarks>
            Get the ATN state number the parser was in at the time the error
            occurred. For
            <see cref="T:Antlr4.Runtime.NoViableAltException"/>
            and
            <see cref="T:Antlr4.Runtime.LexerNoViableAltException"/>
            exceptions, this is the
            <see cref="T:Antlr4.Runtime.Atn.DecisionState"/>
            number. For others, it is the state whose outgoing
            edge we couldn't match.
            <p>If the state number is not known, this method returns -1.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RecognitionException.GetExpectedTokens">
            <summary>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            </summary>
            <remarks>
            Gets the set of input symbols which could potentially follow the
            previously matched symbol at the time this exception was thrown.
            <p>If the set of expected tokens is not known and could not be computed,
            this method returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>
            The set of token types that could potentially follow the current
            state in the ATN, or
            <see langword="null"/>
            if the information is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Context">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            <p>If the context is not available, this method returns
            <see langword="null"/>
            .</p>
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            at the time this exception was thrown.
            If the context is not available, this method returns
            <see langword="null"/>
            .
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.InputStream">
            <summary>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            </summary>
            <remarks>
            Gets the input stream which is the symbol source for the recognizer where
            this exception was thrown.
            <p>If the input stream is not available, this method returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>
            The input stream which is the symbol source for the recognizer
            where this exception was thrown, or
            <see langword="null"/>
            if the stream is not
            available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.RecognitionException.Recognizer">
            <summary>
            Gets the
            <see cref="T:Antlr4.Runtime.IRecognizer"/>
            where this exception occurred.
            <p>If the recognizer is not available, this method returns
            <see langword="null"/>
            .</p>
            </summary>
            <returns>
            The recognizer where this exception occurred, or
            <see langword="null"/>
            if
            the recognizer is not available.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleNames">
            <summary>
            Used to print out token names like ID during debugging and
            error reporting.
            </summary>
            <remarks>
            Used to print out token names like ID during debugging and
            error reporting.  The generated parsers implement a method
            that overrides this to point to their String[] tokenNames.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Vocabulary">
            <summary>Get the vocabulary used by the recognizer.</summary>
            <remarks>Get the vocabulary used by the recognizer.</remarks>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            instance providing information about the
            vocabulary used by the grammar.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.TokenTypeMap">
            <summary>Get a map from token names to token types.</summary>
            <remarks>
            Get a map from token names to token types.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.RuleIndexMap">
            <summary>Get a map from rule names to rule indexes.</summary>
            <remarks>
            Get a map from rule names to rule indexes.
            <p>Used for XPath and tree pattern compilation.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.SerializedAtn">
            <summary>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            </summary>
            <remarks>
            If this recognizer was generated, it will have a serialized ATN
            representation of the grammar.
            <p>For interpreters, we don't know their serialized ATN despite having
            created the interpreter from it.</p>
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.GrammarFileName">
            <summary>For debugging and other purposes, might want the grammar name.</summary>
            <remarks>
            For debugging and other purposes, might want the grammar name.
            Have ANTLR generate an implementation for this method.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Atn">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            used by the recognizer for prediction.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.Interpreter">
            <summary>Get the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Get the ATN interpreter used by the recognizer for prediction.</remarks>
            <returns>The ATN interpreter used by the recognizer for prediction.</returns>
            <summary>Set the ATN interpreter used by the recognizer for prediction.</summary>
            <remarks>Set the ATN interpreter used by the recognizer for prediction.</remarks>
            <value>
            The ATN interpreter used by the recognizer for
            prediction.
            </value>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.ParseInfo">
            <summary>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </summary>
            <remarks>
            If profiling during the parse/lex, this will return DecisionInfo records
            for each decision in recognizer in a ParseInfo object.
            </remarks>
            <since>4.3</since>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetErrorHeader(Antlr4.Runtime.RecognitionException)">
            <summary>What is the error header, normally line/character position information?</summary>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.GetTokenErrorDisplay(Antlr4.Runtime.IToken)">
            <summary>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.
            </summary>
            <remarks>
            How should a token be displayed in an error message? The default
            is to display just the text, but during development you might
            want to have a lot of information spit out.  Override in that case
            to use t.toString() (which, for CommonToken, dumps everything about
            the token). This is better than forcing you to override a method in
            your token objects because you don't have to go modify your lexer
            so that it creates a new Java type.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Recognizer`2.AddErrorListener(Antlr4.Runtime.IAntlrErrorListener{`0})">
            <exception>
            NullPointerException
            if
            <paramref name="listener"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Recognizer`2.State">
            <summary>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.
            </summary>
            <remarks>
            Indicate that the recognizer has changed internal state that is
            consistent with the ATN state passed in.  This way we always know
            where we are in the ATN as the parser goes along. The rule
            context objects form a stack that lets us see the stack of
            invoking rules. Combine this and we have complete ATN
            configuration information.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.RuleContext">
            <summary>A rule context is a record of a single rule invocation.</summary>
            <remarks>
            A rule context is a record of a single rule invocation. It knows
            which context invoked it, if any. If there is no parent context, then
            naturally the invoking state is not valid.  The parent link
            provides a chain upwards from the current rule invocation to the root
            of the invocation tree, forming a stack. We actually carry no
            information about the rule associated with this context (except
            when parsing). We keep only the state number of the invoking state from
            the ATN submachine that invoked this. Contrast this with the s
            pointer inside ParserRuleContext that tracks the current state
            being "executed" for the current rule.
            The parent contexts are useful for computing lookahead sets and
            getting error information.
            These objects are used during parsing and prediction.
            For the special case of parsers, we use the subclass
            ParserRuleContext.
            </remarks>
            <seealso cref="T:Antlr4.Runtime.ParserRuleContext"/>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext._parent">
            <summary>What context invoked this rule?</summary>
        </member>
        <member name="F:Antlr4.Runtime.RuleContext.invokingState">
            <summary>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </summary>
            <remarks>
            What state invoked the rule associated with this context?
            The "return address" is the followState of invokingState
            If parent is null, this should be -1.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.RuleContext.IsEmpty">
            <summary>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </summary>
            <remarks>
            A context is empty if there is no invoking state; meaning nobody call
            current context.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.GetText">
            <summary>Return the combined text of all child nodes.</summary>
            <remarks>
            Return the combined text of all child nodes. This method only considers
            tokens which have been added to the parse tree.
            <p/>
            Since tokens on hidden channels (e.g. whitespace or comments) are not
            added to the parse trees, they will not appear in the output of this
            method.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            We have to know the recognizer so we can get rule names.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.RuleContext.ToStringTree(System.Collections.Generic.IList{System.String})">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            (root child1 ..
            </summary>
            <remarks>
            Print out a whole tree, not just a node, in LISP format
            (root child1 .. childN). Print just a node if this is a leaf.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter">
            <summary>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            </summary>
            <remarks>
            Useful for rewriting out a buffered input token stream after doing some
            augmentation or other manipulations on it.
            <p>
            You can insert stuff, replace, and delete chunks. Note that the operations
            are done lazily--only if you convert the buffer to a
            <see cref="T:System.String"/>
            with
            <see cref="M:Antlr4.Runtime.ITokenStream.GetText"/>
            . This is very efficient because you are not
            moving data around all the time. As the buffer of tokens is converted to
            strings, the
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            method(s) scan the input token stream and
            check to see if there is an operation at the current index. If so, the
            operation is done and then normal
            <see cref="T:System.String"/>
            rendering continues on the
            buffer. This is like having multiple Turing machine instruction streams
            (programs) operating on a single input tape. :)</p>
            <p>
            This rewriter makes no modifications to the token stream. It does not ask the
            stream to fill itself up nor does it advance the input cursor. The token
            stream
            <see cref="P:Antlr4.Runtime.IIntStream.Index"/>
            will return the same value before and
            after any
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            call.</p>
            <p>
            The rewriter only works on tokens that you have in the buffer and ignores the
            current input cursor. If you are buffering tokens on-demand, calling
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            halfway through the input will only do rewrites for those
            tokens in the first half of the file.</p>
            <p>
            Since the operations are done lazily at
            <see cref="M:Antlr4.Runtime.TokenStreamRewriter.GetText"/>
            -time, operations do
            not screw up the token index values. That is, an insert operation at token
            index
            <c>i</c>
            does not change the index values for tokens
            <c>i</c>
            +1..n-1.</p>
            <p>
            Because operations never actually alter the buffer, you may always get the
            original token stream back without undoing anything. Since the instructions
            are queued up, you can easily simulate transactions and roll back any changes
            if there is an error just by removing instructions. For example,</p>
            <pre>
            CharStream input = new ANTLRFileStream("input");
            TLexer lex = new TLexer(input);
            CommonTokenStream tokens = new CommonTokenStream(lex);
            T parser = new T(tokens);
            TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
            parser.startRule();
            </pre>
            <p>
            Then in the rules, you can execute (assuming rewriter is visible):</p>
            <pre>
            Token t,u;
            ...
            rewriter.insertAfter(t, "text to put after t");}
            rewriter.insertAfter(u, "text after u");}
            System.out.println(tokens.toString());
            </pre>
            <p>
            You can also have multiple "instruction streams" and get multiple rewrites
            from a single pass over the input. Just name the instruction streams and use
            that name again when printing the buffer. This could be useful for generating
            a C file and also its header file--all from the same buffer:</p>
            <pre>
            tokens.insertAfter("pass1", t, "text to put after t");}
            tokens.insertAfter("pass2", u, "text after u");}
            System.out.println(tokens.toString("pass1"));
            System.out.println(tokens.toString("pass2"));
            </pre>
            <p>
            If you don't use named rewrite streams, a "default" stream is used as the
            first example shows.</p>
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.instructionIndex">
            <summary>What index into rewrites List are we?</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.index">
            <summary>Token buffer index.</summary>
            <remarks>Token buffer index.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.RewriteOperation.Execute(System.Text.StringBuilder)">
            <summary>Execute the rewrite operation by possibly adding to the buffer.</summary>
            <remarks>
            Execute the rewrite operation by possibly adding to the buffer.
            Return the index of the next token to operate on.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.TokenStreamRewriter.ReplaceOp">
            <summary>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </summary>
            <remarks>
            I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
            instructions.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.tokens">
            <summary>Our source stream</summary>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.programs">
            <summary>You may have multiple, named streams of rewrite operations.</summary>
            <remarks>
            You may have multiple, named streams of rewrite operations.
            I'm calling these things "programs."
            Maps String (name) &#x2192; rewrite (List)
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.TokenStreamRewriter.lastRewriteTokenIndexes">
            <summary>Map String (program name) &#x2192; Integer index</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.Rollback(System.String,System.Int32)">
            <summary>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream.
            </summary>
            <remarks>
            Rollback the instruction stream for a program so that
            the indicated instruction (via instructionIndex) is no
            longer in the stream. UNTESTED!
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.DeleteProgram(System.String)">
            <summary>Reset the program so that no instructions exist</summary>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText">
            <summary>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </summary>
            <remarks>
            Return the text from the original tokens altered per the
            instructions given to this rewriter.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetText(Antlr4.Runtime.Misc.Interval)">
            <summary>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            </summary>
            <remarks>
            Return the text associated with the tokens in the interval from the
            original token stream but with the alterations given to this rewriter.
            The interval refers to the indexes in the original token stream.
            We do not alter the token stream in any way, so the indexes
            and intervals are still consistent. Includes any operations done
            to the first and last token in the interval. So, if you did an
            insertBefore on the first token, you would get that insertion.
            The same is true if you do an insertAfter the stop token.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.ReduceToSingleOperationPerIndex(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation})">
            <summary>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested).
            </summary>
            <remarks>
            We need to combine operations and report invalid operations (like
            overlapping replaces that are not completed nested). Inserts to
            same index need to be combined etc...  Here are the cases:
            I.i.u I.j.v								leave alone, nonoverlapping
            I.i.u I.i.v								combine: Iivu
            R.i-j.u R.x-y.v	| i-j in x-y			delete first R
            R.i-j.u R.i-j.v							delete first R
            R.i-j.u R.x-y.v	| x-y in i-j			ERROR
            R.i-j.u R.x-y.v	| boundaries overlap	ERROR
            Delete special case of replace (text==null):
            D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
            I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
            we're not deleting i)
            I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
            R.x-y.v I.i.u | i in x-y				ERROR
            R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
            R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
            I.i.u = insert u before op @ index i
            R.x-y.u = replace x-y indexed tokens with u
            First we need to examine replaces. For any replace op:
            1. wipe out any insertions before op within that range.
            2. Drop any replace op before that is contained completely within
            that range.
            3. Throw exception upon boundary overlap with any previous replace.
            Then we can deal with inserts:
            1. for any inserts to same index, combine even if not adjacent.
            2. for any prior replace with same left boundary, combine this
            insert with replace and delete this replace.
            3. throw exception if index in same range as previous replace
            Don't actually delete; make op null in list. Easier to walk list.
            Later we can throw as we add to index &#x2192; op map.
            Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
            inserted stuff would be before the replace range. But, if you
            add tokens in front of a method body '{' and then delete the method
            body, I think the stuff before the '{' you added should disappear too.
            Return a map from token index to operation.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.TokenStreamRewriter.GetKindOfOps``1(System.Collections.Generic.IList{Antlr4.Runtime.TokenStreamRewriter.RewriteOperation},System.Int32)">
            <summary>Get all operations before an index of a particular kind</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            <inheritDoc/>
            <p>The default implementation calls
            <see cref="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})"/>
            on the
            specified tree.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation initializes the aggregate result to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult()</see>
            . Before visiting each child, it
            calls
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">shouldVisitNextChild</see>
            ; if the result
            is
            <see langword="false"/>
            no more children are visited and the current aggregate
            result is returned. After visiting a child, the aggregate result is
            updated by calling
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">aggregateResult</see>
            with the
            previous aggregate result and the result of visiting the child.</p>
            <p>The default implementation is not safe for use in visitors that modify
            the tree structure. Visitors that modify the tree should override this
            method to behave properly in respect to the specific algorithm in use.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>
            <inheritDoc/>
            <p>The default implementation returns the result of
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">defaultResult</see>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult">
            <summary>Gets the default value returned by visitor methods.</summary>
            <remarks>
            Gets the default value returned by visitor methods. This value is
            returned by the default implementations of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">visitTerminal</see>
            ,
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">visitErrorNode</see>
            .
            The default implementation of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">visitChildren</see>
            initializes its aggregate result to this value.
            <p>The base implementation returns
            <see langword="null"/>
            .</p>
            </remarks>
            <returns>The default value returned by visitor methods.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.AggregateResult(`0,`0)">
            <summary>Aggregates the results of visiting multiple children of a node.</summary>
            <remarks>
            Aggregates the results of visiting multiple children of a node. After
            either all children are visited or
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)"/>
            returns
            <see langword="false"/>
            , the aggregate value is returned as the result of
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            .
            <p>The default implementation returns
            <paramref name="nextResult"/>
            , meaning
            <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            will return the result of the last child visited
            (or return the initial value if the node has no children).</p>
            </remarks>
            <param name="aggregate">
            The previous aggregate value. In the default
            implementation, the aggregate value is initialized to
            <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
            , which is passed as the
            <paramref name="aggregate"/>
            argument
            to this method after the first child node is visited.
            </param>
            <param name="nextResult">
            The result of the immediately preceeding call to visit
            a child node.
            </param>
            <returns>The updated aggregate result.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.ShouldVisitNextChild(Antlr4.Runtime.Tree.IRuleNode,`0)">
             <summary>
             This method is called after visiting each child in
             <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
             . This method is first called before the first
             child is visited; at that point
             <paramref name="currentResult"/>
             will be the initial
             value (in the default implementation, the initial value is returned by a
             call to
             <see cref="P:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.DefaultResult"/>
             . This method is not called after the last
             child is visited.
             <p>The default implementation always returns
             <see langword="true"/>
             , indicating that
             <c>visitChildren</c>
             should only return after all children are visited.
             One reason to override this method is to provide a "short circuit"
             evaluation option for situations where the result of visiting a single
             child has the potential to determine the result of the visit operation as
             a whole.</p>
             </summary>
             <param name="node">
             The
             <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
             whose children are currently being
             visited.
             </param>
             <param name="currentResult">
             The current aggregate result of the children visited
             to the current point.
             </param>
             <returns>
            
             <see langword="true"/>
             to continue visiting children. Otherwise return
             <see langword="false"/>
             to stop visiting children and immediately return the
             current aggregate result from
             <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
             .
             </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ErrorNodeImpl">
            <summary>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation.
            </summary>
            <remarks>
            Represents a token that was consumed during resynchronization
            rather than during a valid match operation. For example,
            we will create this kind of a node during single token insertion
            and deletion as well as during "consume until error recovery set"
            upon no viable alternative exceptions.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTree">
            <summary>
            An interface to access the tree of
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            objects created
            during a parse that makes the data structure look like a simple parse tree.
            This node represents both internal nodes, rule invocations,
            and leaf nodes, token matches.
            <p>The payload is either a
            <see cref="T:Antlr4.Runtime.IToken"/>
            or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.Accept``1(Antlr4.Runtime.Tree.IParseTreeVisitor{``0})">
            <summary>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1"/>
            needs a double dispatch method.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.GetText">
            <summary>Return the combined text of all leaf nodes.</summary>
            <remarks>
            Return the combined text of all leaf nodes. Does not get any
            off-channel tokens (if any) so won't return whitespace and
            comments if they are sent to parser on hidden channel.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTree.ToStringTree(Antlr4.Runtime.Parser)">
            <summary>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </summary>
            <remarks>
            Specialize toStringTree so that it can print out more information
            based upon the parser.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.IParseTreeVisitor`1">
            <summary>This interface defines the basic notion of a parse tree visitor.</summary>
            <remarks>
            This interface defines the basic notion of a parse tree visitor. Generated
            visitors implement this interface and the
            <c>XVisitor</c>
            interface for
            grammar
            <c>X</c>
            .
            </remarks>
            <author>Sam Harwell</author>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.Visit(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Visit a parse tree, and return a user-defined result of the operation.</summary>
            <remarks>Visit a parse tree, and return a user-defined result of the operation.</remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to visit.
            </param>
            <returns>The result of visiting the parse tree.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </summary>
            <remarks>
            Visit the children of a node, and return a user-defined result
            of the operation.
            </remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IRuleNode"/>
            whose children should be visited.
            </param>
            <returns>The result of visiting the children of the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <summary>Visit a terminal node, and return a user-defined result of the operation.</summary>
            <remarks>Visit a terminal node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.ITerminalNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.IParseTreeVisitor`1.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <summary>Visit an error node, and return a user-defined result of the operation.</summary>
            <remarks>Visit an error node, and return a user-defined result of the operation.</remarks>
            <param name="node">
            The
            <see cref="T:Antlr4.Runtime.Tree.IErrorNode"/>
            to visit.
            </param>
            <returns>The result of visiting the node.</returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ISyntaxTree">
            <summary>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree.
            </summary>
            <remarks>
            A tree that knows about an interval in a token stream
            is some kind of syntax tree. Subinterfaces distinguish
            between parse trees and other kinds of syntax trees we might want to create.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ISyntaxTree.SourceInterval">
            <summary>
            Return an
            <see cref="T:Antlr4.Runtime.Misc.Interval"/>
            indicating the index in the
            <see cref="T:Antlr4.Runtime.ITokenStream"/>
            of the first and last token associated with this
            subtree. If this node is a leaf, then the interval represents a single
            token.
            <p>If source interval is unknown, this returns
            <see cref="F:Antlr4.Runtime.Misc.Interval.Invalid"/>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ITree">
            <summary>The basic notion of a tree has a parent, a payload, and a list of children.</summary>
            <remarks>
            The basic notion of a tree has a parent, a payload, and a list of children.
            It is the most abstract interface for all the trees used by ANTLR.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Parent">
            <summary>The parent of this node.</summary>
            <remarks>
            The parent of this node. If the return value is null, then this
            node is the root of the tree.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.Payload">
            <summary>This method returns whatever object represents the data at this note.</summary>
            <remarks>
            This method returns whatever object represents the data at this note. For
            example, for parse trees, the payload can be a
            <see cref="T:Antlr4.Runtime.IToken"/>
            representing
            a leaf node or a
            <see cref="T:Antlr4.Runtime.RuleContext"/>
            object representing a rule
            invocation. For abstract syntax trees (ASTs), this is a
            <see cref="T:Antlr4.Runtime.IToken"/>
            object.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.GetChild(System.Int32)">
            <summary>
            If there are children, get the
            <paramref name="i"/>
            th value indexed from 0.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.ITree.ChildCount">
            <summary>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </summary>
            <remarks>
            How many children are there? If there is none, then this
            node represents a leaf node.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ITree.ToStringTree">
            <summary>
            Print out a whole tree, not just a node, in LISP format
            <c>(root child1 .. childN)</c>
            . Print just a node if this is a leaf.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.ParseTreeProperty`1">
            <summary>Associate a property with a parse tree node.</summary>
            <remarks>
            Associate a property with a parse tree node. Useful with parse tree listeners
            that need to associate values with particular tree nodes, kind of like
            specifying a return value for the listener event method that visited a
            particular node. Example:
            <pre>
            ParseTreeProperty&lt;Integer&gt; values = new ParseTreeProperty&lt;Integer&gt;();
            values.put(tree, 36);
            int x = values.get(tree);
            values.removeFrom(tree);
            </pre>
            You would make one decl (values here) in the listener and use lots of times
            in your event methods.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.Walk(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Performs a walk on the given parse tree starting at the root and going down recursively
            with depth-first search. On each node, 
            <see cref="M:Antlr4.Runtime.Tree.ParseTreeWalker.EnterRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)"/> is called before
            recursively walking down into child nodes, then
            <see cref="M:Antlr4.Runtime.Tree.ParseTreeWalker.ExitRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)"/>
            is called after the recursive call to wind up.
            </summary>
            <param name="listener">The listener used by the walker to process grammar rules</param>
            <param name="t">The parse tree to be walked on</param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.EnterRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Enters a grammar rule by first triggering the generic event 
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)"/>
            then by triggering the event specific to the given parse tree node
            </summary>
            <param name="listener"> The listener responding to the trigger events </param>
            <param name="r">The grammar rule containing the rule context</param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.ParseTreeWalker.ExitRule(Antlr4.Runtime.Tree.IParseTreeListener,Antlr4.Runtime.Tree.IRuleNode)">
            <summary>
            Exits a grammar rule by first triggering the event specific to the given parse tree node
            then by triggering the generic event 
            <see cref="M:Antlr4.Runtime.Tree.IParseTreeListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)"/>
            </summary>
            <param name="listener"> The listener responding to the trigger events </param>
            <param name="r">The grammar rule containing the rule context</param>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.Chunk">
            <summary>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            </summary>
            <remarks>
            A chunk is either a token tag, a rule tag, or a span of literal text within a
            tree pattern.
            <p>The method
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)"/>
            returns a list of
            chunks in preparation for creating a token stream by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            . From there, we get a parse
            tree from with
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            . These
            chunks are converted to
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            ,
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            , or the
            regular tokens of the text surrounding the tags.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch">
            <summary>
            Represents the result of matching a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            against a tree pattern.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.tree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.labels">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.mismatchedNode">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.#ctor(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree},Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            from the specified
            parse tree and pattern.
            </summary>
            <param name="tree">The parse tree to match against the pattern.</param>
            <param name="pattern">The parse tree pattern.</param>
            <param name="labels">
            A mapping from label names to collections of
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            objects located by the tree pattern matching process.
            </param>
            <param name="mismatchedNode">
            The first node which failed to match the tree
            pattern during the matching process.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tree"/>
            is
            <see langword="null"/>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="pattern"/>
            is
            <see langword="null"/>
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="labels"/>
            is
            <see langword="null"/>
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Get(System.String)">
            <summary>
            Get the last node associated with a specific
            <paramref name="label"/>
            .
            <p>For example, for pattern
            <c>&lt;id:ID&gt;</c>
            ,
            <c>get("id")</c>
            returns the
            node matched for that
            <c>ID</c>
            . If more than one node
            matched the specified label, only the last is returned. If there is
            no node associated with the label, this returns
            <see langword="null"/>
            .</p>
            <p>Pattern tags like
            <c>&lt;ID&gt;</c>
            and
            <c>&lt;expr&gt;</c>
            without labels are
            considered to be labeled with
            <c>ID</c>
            and
            <c>expr</c>
            , respectively.</p>
            </summary>
            <param name="label">The label to check.</param>
            <returns>
            The last
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match a tag with the specified
            label, or
            <see langword="null"/>
            if no parse tree matched a tag with the label.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)">
            <summary>Return all nodes matching a rule or token tag with the specified label.</summary>
            <remarks>
            Return all nodes matching a rule or token tag with the specified label.
            <p>If the
            <paramref name="label"/>
            is the name of a parser rule or token in the
            grammar, the resulting list will contain both the parse trees matching
            rule or tags explicitly labeled with the label and the complete set of
            parse trees matching the labeled and unlabeled tags in the pattern for
            the parser rule or token. For example, if
            <paramref name="label"/>
            is
            <c>"foo"</c>
            ,
            the result will contain <em>all</em> of the following.</p>
            <ul>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;foo:anyRuleName&gt;</c>
            and
            <c>&lt;foo:AnyTokenName&gt;</c>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;anyLabel:foo&gt;</c>
            .</li>
            <li>Parse tree nodes matching tags of the form
            <c>&lt;foo&gt;</c>
            .</li>
            </ul>
            </remarks>
            <param name="label">The label.</param>
            <returns>
            A collection of all
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            nodes matching tags with
            the specified
            <paramref name="label"/>
            . If no nodes matched the label, an empty list
            is returned.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels">
            <summary>Return a mapping from label &#x2192; [list of nodes].</summary>
            <remarks>
            Return a mapping from label &#x2192; [list of nodes].
            <p>The map includes special entries corresponding to the names of rules and
            tokens referenced in tags in the original pattern. For additional
            information, see the description of
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.GetAll(System.String)"/>
            .</p>
            </remarks>
            <returns>
            A mapping from labels to parse tree nodes. If the parse tree
            pattern did not contain any rule or token tags, this map will be empty.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode">
            <summary>Get the node at which we first detected a mismatch.</summary>
            <remarks>Get the node at which we first detected a mismatch.</remarks>
            <returns>
            the node at which we first detected a mismatch, or
            <see langword="null"/>
            if the match was successful.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded">
             <summary>Gets a value indicating whether the match operation succeeded.</summary>
             <remarks>Gets a value indicating whether the match operation succeeded.</remarks>
             <returns>
            
             <see langword="true"/>
             if the match operation succeeded; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Pattern">
            <summary>Get the tree pattern we are matching against.</summary>
            <remarks>Get the tree pattern we are matching against.</remarks>
            <returns>The tree pattern we are matching against.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Tree">
            <summary>Get the parse tree we are trying to match to a pattern.</summary>
            <remarks>Get the parse tree we are trying to match to a pattern.</remarks>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            we are trying to match to a pattern.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.ToString">
            <summary><inheritDoc/></summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern">
            <summary>
            A pattern like
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            converted to a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternRuleIndex">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.pattern">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.patternTree">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.matcher">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.#ctor(Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher,System.String,System.Int32,Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Construct a new instance of the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            class.
            </summary>
            <param name="matcher">
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this
            tree pattern.
            </param>
            <param name="pattern">The tree pattern in concrete syntax form.</param>
            <param name="patternRuleIndex">
            The parser rule which serves as the root of the
            tree pattern.
            </param>
            <param name="patternTree">
            The tree pattern in
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            form.
            </param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)">
            <summary>Match a specific parse tree against this tree pattern.</summary>
            <remarks>Match a specific parse tree against this tree pattern.</remarks>
            <param name="tree">The parse tree to match against this tree pattern.</param>
            <returns>
            A
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object describing the result of the
            match operation. The
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Succeeded"/>
            method can be
            used to determine whether or not the match was successful.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matches(Antlr4.Runtime.Tree.IParseTree)">
             <summary>Determine whether or not a parse tree matches this tree pattern.</summary>
             <remarks>Determine whether or not a parse tree matches this tree pattern.</remarks>
             <param name="tree">The parse tree to match against this tree pattern.</param>
             <returns>
            
             <see langword="true"/>
             if
             <paramref name="tree"/>
             is a match for the current tree
             pattern; otherwise,
             <see langword="false"/>
             .
             </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)">
            <summary>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </summary>
            <remarks>
            Find all nodes using XPath and then try to match those subtrees against
            this tree pattern.
            </remarks>
            <param name="tree">
            The
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            to match against this pattern.
            </param>
            <param name="xpath">An expression matching the nodes</param>
            <returns>
            A collection of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            objects describing the
            successful matches. Unsuccessful matches are omitted from the result,
            regardless of the reason for the failure.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Matcher">
            <summary>
            Get the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree pattern.
            </summary>
            <returns>
            The
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            which created this tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Pattern">
            <summary>Get the tree pattern in concrete syntax form.</summary>
            <remarks>Get the tree pattern in concrete syntax form.</remarks>
            <returns>The tree pattern in concrete syntax form.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternRuleIndex">
            <summary>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </summary>
            <remarks>
            Get the parser rule which serves as the outermost rule for the tree
            pattern.
            </remarks>
            <returns>
            The parser rule which serves as the outermost rule for the tree
            pattern.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.PatternTree">
            <summary>
            Get the tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            . The rule and token tags from
            the pattern are present in the parse tree as terminal nodes with a symbol
            of type
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            or
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            .
            </summary>
            <returns>
            The tree pattern as a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            .
            </returns>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher">
            <summary>
            A tree pattern matching mechanism for ANTLR
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            s.
            <p>Patterns are strings of source input text with special tags representing
            token or rule references such as:</p>
            <p>
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            </p>
            <p>Given a pattern start rule such as
            <c>statement</c>
            , this object constructs
            a
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            with placeholders for the
            <c>ID</c>
            and
            <c>expr</c>
            subtree. Then the
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines can compare an actual
            <see cref="T:Antlr4.Runtime.Tree.IParseTree"/>
            from a parse with this pattern. Tag
            <c>&lt;ID&gt;</c>
            matches
            any
            <c>ID</c>
            token and tag
            <c>&lt;expr&gt;</c>
            references the result of the
            <c>expr</c>
            rule (generally an instance of
            <c>ExprContext</c>
            .</p>
            <p>Pattern
            <c>x = 0;</c>
            is a similar pattern that matches the same pattern
            except that it requires the identifier to be
            <c>x</c>
            and the expression to
            be
            <c>0</c>
            .</p>
            <p>The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return
            <see langword="true"/>
            or
            <see langword="false"/>
            based
            upon a match for the tree rooted at the parameter sent in. The
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)"/>
            routines return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that
            contains the parse tree, the parse tree pattern, and a map from tag name to
            matched nodes (more below). A subtree that fails to match, returns with
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.MismatchedNode"/>
            set to the first tree node that did not
            match.</p>
            <p>For efficiency, you can compile a tree pattern in string form to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            object.</p>
            <p>See
            <c>TestParseTreeMatcher</c>
            for lots of examples.
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            has two static helper methods:
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String)"/>
            and
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePattern.Match(Antlr4.Runtime.Tree.IParseTree)"/>
            that
            are easy to use but not super efficient because they create new
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            objects each time and have to compile the
            pattern in string form before using it.</p>
            <p>The lexer and parser that you pass into the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            constructor are used to parse the pattern in string form. The lexer converts
            the
            <c>&lt;ID&gt; = &lt;expr&gt;;</c>
            into a sequence of four tokens (assuming lexer
            throws out whitespace or puts it on a hidden channel). Be aware that the
            input stream is reset for the lexer (but not the parser; a
            <see cref="T:Antlr4.Runtime.ParserInterpreter"/>
            is created to parse the input.). Any user-defined
            fields you have put into the lexer might get changed when this mechanism asks
            it to scan the pattern string.</p>
            <p>Normally a parser does not accept token
            <c>&lt;expr&gt;</c>
            as a valid
            <c>expr</c>
            but, from the parser passed in, we create a special version of
            the underlying grammar representation (an
            <see cref="T:Antlr4.Runtime.Atn.ATN"/>
            ) that allows imaginary
            tokens representing rules (
            <c>&lt;expr&gt;</c>
            ) to match entire rules. We call
            these <em>bypass alternatives</em>.</p>
            <p>Delimiters are
            <c>&lt;</c>
            and
            <c>&gt;</c>
            , with
            <c>\</c>
            as the escape string
            by default, but you can set them to whatever you want using
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)"/>
            . You must escape both start and stop strings
            <c>\&lt;</c>
            and
            <c>\&gt;</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.lexer">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.parser">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.#ctor(Antlr4.Runtime.Lexer,Antlr4.Runtime.Parser)">
            <summary>
            Constructs a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher"/>
            or from a
            <see cref="T:Antlr4.Runtime.Lexer"/>
            and
            <see cref="T:Antlr4.Runtime.Parser"/>
            object. The lexer input stream is altered for tokenizing
            the tree patterns. The parser is used as a convenient mechanism to get
            the grammar name, plus token, rule names.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.SetDelimiters(System.String,System.String,System.String)">
            <summary>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </summary>
            <remarks>
            Set the delimiters used for marking rule and token tags within concrete
            syntax used by the tree pattern parser.
            </remarks>
            <param name="start">The start delimiter.</param>
            <param name="stop">The stop delimiter.</param>
            <param name="escapeLeft">The escape sequence to use for escaping a start or stop delimiter.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="start"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
            <exception>
            IllegalArgumentException
            if
            <paramref name="stop"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Does
            <paramref name="pattern"/>
            matched as rule
            <paramref name="patternRuleIndex"/>
            match
            <paramref name="tree"/>
            ?
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Matches(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Does
            <paramref name="pattern"/>
            matched as rule patternRuleIndex match tree? Pass in a
            compiled pattern instead of a string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,System.String,System.Int32)">
            <summary>
            Compare
            <paramref name="pattern"/>
            matched as rule
            <paramref name="patternRuleIndex"/>
            against
            <paramref name="tree"/>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the
            matched elements, or the node at which the match failed.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Match(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.Pattern.ParseTreePattern)">
            <summary>
            Compare
            <paramref name="pattern"/>
            matched against
            <paramref name="tree"/>
            and return a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch"/>
            object that contains the matched elements, or the
            node at which the match failed. Pass in a compiled pattern instead of a
            string representation of a tree pattern.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Compile(System.String,System.Int32)">
            <summary>
            For repeated use of a tree pattern, compile it to a
            <see cref="T:Antlr4.Runtime.Tree.Pattern.ParseTreePattern"/>
            using this method.
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Lexer">
            <summary>Used to convert the tree pattern string into a series of tokens.</summary>
            <remarks>
            Used to convert the tree pattern string into a series of tokens. The
            input stream is reset.
            </remarks>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Parser">
            <summary>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </summary>
            <remarks>
            Used to collect to the grammar file name, token names, rule names for
            used to parse the pattern into a parse tree.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.MatchImpl(Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Tree.IParseTree,Antlr4.Runtime.Misc.MultiMap{System.String,Antlr4.Runtime.Tree.IParseTree})">
            <summary>
            Recursively walk
            <paramref name="tree"/>
            against
            <paramref name="patternTree"/>
            , filling
            <c>match.</c>
            <see cref="P:Antlr4.Runtime.Tree.Pattern.ParseTreeMatch.Labels"/>
            .
            </summary>
            <returns>
            the first node encountered in
            <paramref name="tree"/>
            which does not match
            a corresponding node in
            <paramref name="patternTree"/>
            , or
            <see langword="null"/>
            if the match
            was successful. The specific node returned depends on the matching
            algorithm used by the implementation, and may be overridden.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.GetRuleTagToken(Antlr4.Runtime.Tree.IParseTree)">
             <summary>
             Is
             <paramref name="t"/>
            
             <c>(expr &lt;expr&gt;)</c>
             subtree?
             </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Split(System.String)">
            <summary>
            Split
            <c>&lt;ID&gt; = &lt;e:expr&gt; ;</c>
            into 4 chunks for tokenizing by
            <see cref="M:Antlr4.Runtime.Tree.Pattern.ParseTreePatternMatcher.Tokenize(System.String)"/>
            .
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing an entire subtree matched by a parser
            rule; e.g.,
            <c>&lt;expr&gt;</c>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the tag corresponds to a parser rule.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ruleName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.bypassTokenType">
            <summary>The token type for the current token.</summary>
            <remarks>
            The token type for the current token. This is the token type assigned to
            the bypass alternative for the rule during ATN deserialization.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.RuleTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name and bypass token type and no label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="ruleName"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            with the specified rule
            name, bypass token type, and label.
            </summary>
            <param name="ruleName">The name of the parser rule this rule tag matches.</param>
            <param name="bypassTokenType">The bypass token type assigned to the parser rule.</param>
            <param name="label">
            The label associated with the rule tag, or
            <see langword="null"/>
            if
            the rule tag is unlabeled.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="ruleName"/>
            is
            <see langword="null"/>
            or empty.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.RuleName">
            <summary>Gets the name of the rule associated with this rule tag.</summary>
            <remarks>Gets the name of the rule associated with this rule tag.</remarks>
            <returns>The name of the parser rule associated with this rule tag.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <see langword="null"/>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Channel">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens are always placed on the
            <see cref="F:Antlr4.Runtime.TokenConstants.DefaultChannel"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>This method returns the rule tag formatted with
            <c>&lt;</c>
            and
            <c>&gt;</c>
            delimiters.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Type">
            <summary>
            <inheritDoc/>
            <p>Rule tag tokens have types assigned according to the rule bypass
            transitions created during ATN deserialization.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Line">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns 0.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.Column">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StartIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.StopIndex">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns -1.</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.TokenSource">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <see langword="null"/>
            .</p>
            </summary>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.RuleTagToken.InputStream">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            always returns
            <see langword="null"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.RuleTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.RuleTagToken"/>
            returns a string of the form
            <c>ruleName:bypassTokenType</c>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TagChunk">
            <summary>Represents a placeholder tag in a tree pattern.</summary>
            <remarks>
            Represents a placeholder tag in a tree pattern. A tag can have any of the
            following forms.
            <ul>
            <li>
            <c>expr</c>
            : An unlabeled placeholder for a parser rule
            <c>expr</c>
            .</li>
            <li>
            <c>ID</c>
            : An unlabeled placeholder for a token of type
            <c>ID</c>
            .</li>
            <li>
            <c>e:expr</c>
            : A labeled placeholder for a parser rule
            <c>expr</c>
            .</li>
            <li>
            <c>id:ID</c>
            : A labeled placeholder for a token of type
            <c>ID</c>
            .</li>
            </ul>
            This class does not perform any validation on the tag or label names aside
            from ensuring that the tag is a non-null, non-empty string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.tag">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TagChunk.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified tag and
            no label.
            </summary>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tag"/>
            is
            <see langword="null"/>
            or
            empty.
            </exception>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.#ctor(System.String,System.String)">
            <summary>
            Construct a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            using the specified label
            and tag.
            </summary>
            <param name="label">
            The label for the tag. If this is
            <see langword="null"/>
            , the
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            represents an unlabeled tag.
            </param>
            <param name="tag">
            The tag, which should be the name of a parser rule or token
            type.
            </param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="tag"/>
            is
            <see langword="null"/>
            or
            empty.
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Tag">
            <summary>Get the tag for this chunk.</summary>
            <remarks>Get the tag for this chunk.</remarks>
            <returns>The tag for the chunk.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TagChunk.Label">
            <summary>Get the label, if any, assigned to this chunk.</summary>
            <remarks>Get the label, if any, assigned to this chunk.</remarks>
            <returns>
            The label assigned to this chunk, or
            <see langword="null"/>
            if no label is
            assigned to the chunk.
            </returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TagChunk.ToString">
            <summary>This method returns a text representation of the tag chunk.</summary>
            <remarks>
            This method returns a text representation of the tag chunk. Labeled tags
            are returned in the form
            <c>label:tag</c>
            , and unlabeled tags are
            returned as just the tag name.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TextChunk">
            <summary>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </summary>
            <remarks>
            Represents a span of raw text (concrete syntax) between tags in a tree
            pattern string.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TextChunk.text">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.#ctor(System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            with the specified text.
            </summary>
            <param name="text">The text of this chunk.</param>
            <exception>
            IllegalArgumentException
            if
            <paramref name="text"/>
            is
            <see langword="null"/>
            .
            </exception>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text">
            <summary>Gets the raw text of this chunk.</summary>
            <remarks>Gets the raw text of this chunk.</remarks>
            <returns>The text of the chunk.</returns>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TextChunk.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TextChunk"/>
            returns the result of
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TextChunk.Text"/>
            in single quotes.</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken">
            <summary>
            A
            <see cref="T:Antlr4.Runtime.IToken"/>
            object representing a token of a particular type; e.g.,
            <c>&lt;ID&gt;</c>
            . These tokens are created for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TagChunk"/>
            chunks where the
            tag corresponds to a lexer rule or token type.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.tokenName">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.Tree.Pattern.TokenTagToken.label">
            <summary>
            This is the backing field for
            <see cref="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            for an unlabeled tag
            with the specified token name and type.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.#ctor(System.String,System.Int32,System.String)">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            with the specified
            token name, type, and label.
            </summary>
            <param name="tokenName">The token name.</param>
            <param name="type">The token type.</param>
            <param name="label">
            The label associated with the token tag, or
            <see langword="null"/>
            if
            the token tag is unlabeled.
            </param>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.TokenName">
            <summary>Gets the token name.</summary>
            <remarks>Gets the token name.</remarks>
            <returns>The token name.</returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Label">
            <summary>Gets the label associated with the rule tag.</summary>
            <remarks>Gets the label associated with the rule tag.</remarks>
            <returns>
            The name of the label associated with the rule tag, or
            <see langword="null"/>
            if this is an unlabeled rule tag.
            </returns>
        </member>
        <member name="P:Antlr4.Runtime.Tree.Pattern.TokenTagToken.Text">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns the token tag
            formatted with
            <c>&lt;</c>
            and
            <c>&gt;</c>
            delimiters.</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Pattern.TokenTagToken.ToString">
            <summary>
            <inheritDoc/>
            <p>The implementation for
            <see cref="T:Antlr4.Runtime.Tree.Pattern.TokenTagToken"/>
            returns a string of the form
            <c>tokenName:type</c>
            .</p>
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Trees">
            <summary>A set of utility routines useful for all kinds of ANTLR trees.</summary>
            <remarks>A set of utility routines useful for all kinds of ANTLR trees.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.ToStringTree(Antlr4.Runtime.Tree.ITree,System.Collections.Generic.IList{System.String})">
            <summary>Print out a whole tree in LISP form.</summary>
            <remarks>
            Print out a whole tree in LISP form.
            <see cref="M:Antlr4.Runtime.Tree.Trees.GetNodeText(Antlr4.Runtime.Tree.ITree,Antlr4.Runtime.Parser)"/>
            is used on the
            node payloads to get the text for the nodes.  Detect
            parse trees and extract data appropriately.
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetChildren(Antlr4.Runtime.Tree.ITree)">
            <summary>Return ordered list of all children of this node</summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Trees.GetAncestors(Antlr4.Runtime.Tree.ITree)">
            <summary>Return a list of all ancestors of this node.</summary>
            <remarks>
            Return a list of all ancestors of this node.  The first node of
            list is the root and the last is the parent of this node.
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPath">
            <summary>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            </summary>
            <remarks>
            Represent a subset of XPath XML path syntax for use in identifying nodes in
            parse trees.
            <p>
            Split path into words and separators
            <c>/</c>
            and
            <c>//</c>
            via ANTLR
            itself then walk path elements from left to right. At each separator-word
            pair, find set of nodes. Next stage uses those as work list.</p>
            <p>
            The basic interface is
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.FindAll(Antlr4.Runtime.Tree.IParseTree,System.String,Antlr4.Runtime.Parser)">ParseTree.findAll</see>
            <c>(tree, pathString, parser)</c>
            .
            But that is just shorthand for:</p>
            <pre>
            <see cref="T:Antlr4.Runtime.Tree.Xpath.XPath"/>
            p = new
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.#ctor(Antlr4.Runtime.Parser,System.String)">XPath</see>
            (parser, pathString);
            return p.
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">evaluate</see>
            (tree);
            </pre>
            <p>
            See
            <c>org.antlr.v4.test.TestXPath</c>
            for descriptions. In short, this
            allows operators:</p>
            <dl>
            <dt>/</dt> <dd>root</dd>
            <dt>//</dt> <dd>anywhere</dd>
            <dt>!</dt> <dd>invert; this must appear directly after root or anywhere
            operator</dd>
            </dl>
            <p>
            and path elements:</p>
            <dl>
            <dt>ID</dt> <dd>token name</dd>
            <dt>'string'</dt> <dd>any string literal token from the grammar</dd>
            <dt>expr</dt> <dd>rule name</dd>
            <dt>*</dt> <dd>wildcard matching any node</dd>
            </dl>
            <p>
            Whitespace is not allowed.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.GetXPathElement(Antlr4.Runtime.IToken,System.Boolean)">
            <summary>
            Convert word like
            <c>*</c>
            or
            <c>ID</c>
            or
            <c>expr</c>
            to a path
            element.
            <paramref name="anywhere"/>
            is
            <see langword="true"/>
            if
            <c>//</c>
            precedes the
            word.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Return a list of all nodes starting at
            <paramref name="t"/>
            as root that satisfy the
            path. The root
            <c>/</c>
            is relative to the node passed to
            <see cref="M:Antlr4.Runtime.Tree.Xpath.XPath.Evaluate(Antlr4.Runtime.Tree.IParseTree)"/>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.#ctor(System.String)">
            <summary>
            Construct element like
            <c>/ID</c>
            or
            <c>ID</c>
            or
            <c>/*</c>
            etc...
            op is null if just node
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Tree.Xpath.XPathElement.Evaluate(Antlr4.Runtime.Tree.IParseTree)">
            <summary>
            Given tree rooted at
            <paramref name="t"/>
            return all nodes matched by this path
            element.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.Tree.Xpath.XPathRuleAnywhereElement">
            <summary>
            Either
            <c>ID</c>
            at start of path or
            <c>...//ID</c>
            in middle of path.
            </summary>
        </member>
        <member name="T:Antlr4.Runtime.UnbufferedCharStream">
            <summary>Do not buffer up the entire char stream.</summary>
            <remarks>
            Do not buffer up the entire char stream. It does keep a small buffer
            for efficiency and also buffers while a mark exists (set by the
            lookahead prediction in parser). "Unbuffered" here refers to fact
            that it doesn't buffer all data, not that's it's on demand loading of char.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.data">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.n">
            <summary>
            The number of characters currently in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            .
            <p>This is not the buffer capacity, that's
            <c>data.length</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            of next character.
            <p>The
            <c>LA(1)</c>
            character is
            <c>data[p]</c>
            . If
            <c>p == n</c>
            , we are
            out of buffered characters.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">release()</see>
            . When we
            <c>release()</c>
            the last mark,
            <c>numMarkers</c>
            reaches 0 and we reset the buffer. Copy
            <c>data[p]..data[n-1]</c>
            to
            <c>data[0]..data[(n-1)-p]</c>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastChar">
            <summary>
            This is the
            <c>LA(-1)</c>
            character for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.lastCharBufferStart">
            <summary>
            When
            <c>numMarkers &gt; 0</c>
            , this is the
            <c>LA(-1)</c>
            character for the
            first character in
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.data">data</see>
            . Otherwise, this is unspecified.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.currentCharIndex">
            <summary>Absolute character index.</summary>
            <remarks>
            Absolute character index. It's the index of the character about to be
            read via
            <c>LA(1)</c>
            . Goes from 0 to the number of characters in the
            entire stream, although the stream size is unknown before the end is
            reached.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedCharStream.name">
            <summary>The name or source of this char stream.</summary>
            <remarks>The name or source of this char stream.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.#ctor(System.Int32)">
            <summary>Useful for subclasses that pull char from other than this.input.</summary>
            <remarks>Useful for subclasses that pull char from other than this.input.</remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.p">p</see>
            .
            Last valid
            <c>p</c>
            index is
            <c>data.length-1</c>
            .
            <c>p+need-1</c>
            is
            the char index 'need' elements ahead. If we need 1 element,
            <c>(p+1-1)==p</c>
            must be less than
            <c>data.length</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Fill(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            characters to the buffer. Returns the number of characters
            actually added to the buffer. If the return value is less than
            <paramref name="n"/>
            ,
            then EOF was reached before
            <paramref name="n"/>
            characters could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.NextChar">
            <summary>
            Override to provide different source of characters than
            <see cref="F:Antlr4.Runtime.UnbufferedCharStream.input">input</see>
            .
            </summary>
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <c>seek()</c>
            is called on a mark or
            <c>release()</c>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Release(System.Int32)">
            <summary>Decrement number of markers, resetting buffer if we hit 0.</summary>
            <remarks>Decrement number of markers, resetting buffer if we hit 0.</remarks>
            <param name="marker"/>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedCharStream.Seek(System.Int32)">
            <summary>
            Seek to absolute character index, which might not be in the current
            sliding window.
            </summary>
            <remarks>
            Seek to absolute character index, which might not be in the current
            sliding window.  Move
            <c>p</c>
            to
            <c>index-bufferStartIndex</c>
            .
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">
            <summary>A moving window buffer of the data being scanned.</summary>
            <remarks>
            A moving window buffer of the data being scanned. While there's a marker,
            we keep adding to buffer. Otherwise,
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Consume">consume()</see>
            resets so
            we start filling at index 0 again.
            </remarks>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.n">
            <summary>
            The number of tokens currently in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            .
            <p>This is not the buffer capacity, that's
            <c>tokens.length</c>
            .</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.p">
            <summary>
            0..n-1 index into
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens">tokens</see>
            of next token.
            <p>The
            <c>LT(1)</c>
            token is
            <c>tokens[p]</c>
            . If
            <c>p == n</c>
            , we are
            out of buffered tokens.</p>
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.numMarkers">
            <summary>
            Count up with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">mark()</see>
            and down with
            <see cref="M:Antlr4.Runtime.UnbufferedTokenStream.Release(System.Int32)">release()</see>
            . When we
            <c>release()</c>
            the last mark,
            <c>numMarkers</c>
            reaches 0 and we reset the buffer. Copy
            <c>tokens[p]..tokens[n-1]</c>
            to
            <c>tokens[0]..tokens[(n-1)-p]</c>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastToken">
            <summary>
            This is the
            <c>LT(-1)</c>
            token for the current position.
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.lastTokenBufferStart">
            <summary>
            When
            <c>numMarkers &gt; 0</c>
            , this is the
            <c>LT(-1)</c>
            token for the
            first token in
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.tokens"/>
            . Otherwise, this is
            <see langword="null"/>
            .
            </summary>
        </member>
        <member name="F:Antlr4.Runtime.UnbufferedTokenStream.currentTokenIndex">
            <summary>Absolute token index.</summary>
            <remarks>
            Absolute token index. It's the index of the token about to be read via
            <c>LT(1)</c>
            . Goes from 0 to the number of tokens in the entire stream,
            although the stream size is unknown before the end is reached.
            <p>This value is used to set the token indexes if the stream provides tokens
            that implement
            <see cref="T:Antlr4.Runtime.IWritableToken"/>
            .</p>
            </remarks>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Sync(System.Int32)">
            <summary>
            Make sure we have 'need' elements from current position
            <see cref="F:Antlr4.Runtime.UnbufferedTokenStream.p">p</see>
            . Last valid
            <c>p</c>
            index is
            <c>tokens.length-1</c>
            .
            <c>p+need-1</c>
            is the tokens index 'need' elements
            ahead.  If we need 1 element,
            <c>(p+1-1)==p</c>
            must be less than
            <c>tokens.length</c>
            .
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Fill(System.Int32)">
            <summary>
            Add
            <paramref name="n"/>
            elements to the buffer. Returns the number of tokens
            actually added to the buffer. If the return value is less than
            <paramref name="n"/>
            ,
            then EOF was reached before
            <paramref name="n"/>
            tokens could be added.
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.UnbufferedTokenStream.Mark">
            <summary>Return a marker that we can release later.</summary>
            <remarks>
            Return a marker that we can release later.
            <p>The specific marker value used for this class allows for some level of
            protection against misuse where
            <c>seek()</c>
            is called on a mark or
            <c>release()</c>
            is called in the wrong order.</p>
            </remarks>
        </member>
        <member name="T:Antlr4.Runtime.Vocabulary">
            <summary>
            This class provides a default implementation of the
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            interface.
            </summary>
            <author>Sam Harwell</author>
        </member>
        <member name="F:Antlr4.Runtime.Vocabulary.EmptyVocabulary">
            <summary>
            Gets an empty
            <see cref="T:Antlr4.Runtime.IVocabulary"/>
            instance.
            <p>
            No literal or symbol names are assigned to token types, so
            <see cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
            returns the numeric value for all tokens
            except
            <see cref="F:Antlr4.Runtime.TokenConstants.EOF"/>
            .</p>
            </summary>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.#ctor(System.String[],System.String[])">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Vocabulary"/>
            from the specified
            literal and symbolic token names.
            </summary>
            <param name="literalNames">
            The literal names assigned to tokens, or
            <see langword="null"/>
            if no literal names are assigned.
            </param>
            <param name="symbolicNames">
            The symbolic names assigned to tokens, or
            <see langword="null"/>
            if no symbolic names are assigned.
            </param>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetLiteralName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetSymbolicName(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.#ctor(System.String[],System.String[],System.String[])">
            <summary>
            Constructs a new instance of
            <see cref="T:Antlr4.Runtime.Vocabulary"/>
            from the specified
            literal, symbolic, and display token names.
            </summary>
            <param name="literalNames">
            The literal names assigned to tokens, or
            <see langword="null"/>
            if no literal names are assigned.
            </param>
            <param name="symbolicNames">
            The symbolic names assigned to tokens, or
            <see langword="null"/>
            if no symbolic names are assigned.
            </param>
            <param name="displayNames">
            The display names assigned to tokens, or
            <see langword="null"/>
            to use the values in
            <paramref name="literalNames"/>
            and
            <paramref name="symbolicNames"/>
            as
            the source of display names, as described in
            <see cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
            .
            </param>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetLiteralName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetSymbolicName(System.Int32)"/>
            <seealso cref="M:Antlr4.Runtime.Vocabulary.GetDisplayName(System.Int32)"/>
        </member>
        <member name="M:Antlr4.Runtime.Vocabulary.getMaxTokenType">
            <summary>
            Returns the highest token type value. It can be used to iterate from
            zero to that number, inclusively, thus querying all stored entries.
            </summary>
        </member>
        <member name="T:HdrHistogram.Encoding.HistogramEncoderV2">
            <summary>
            An implementation of <see cref="T:HdrHistogram.Encoding.IEncoder"/> for the V2 HdrHistogram log format.
            </summary>
        </member>
        <member name="F:HdrHistogram.Encoding.HistogramEncoderV2.Instance">
            <summary>
            A singleton instance of the <see cref="T:HdrHistogram.Encoding.HistogramEncoderV2"/>.
            </summary>
        </member>
        <member name="M:HdrHistogram.Encoding.HistogramEncoderV2.Encode(HdrHistogram.Encoding.IRecordedData,HdrHistogram.Utilities.ByteBuffer)">
            <summary>
            Encodes the supplied <see cref="T:HdrHistogram.Encoding.IRecordedData"/> into the supplied <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            </summary>
            <param name="data">The data to encode.</param>
            <param name="buffer">The target <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> to write to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="T:HdrHistogram.Encoding.IEncoder">
            <summary>
            Defines a method to allow histogram data to be encoded into a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            </summary>
        </member>
        <member name="M:HdrHistogram.Encoding.IEncoder.Encode(HdrHistogram.Encoding.IRecordedData,HdrHistogram.Utilities.ByteBuffer)">
            <summary>
            Encodes the supplied <see cref="T:HdrHistogram.Encoding.IRecordedData"/> into the supplied <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            </summary>
            <param name="data">The data to encode.</param>
            <param name="buffer">The target <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> to write to.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="T:HdrHistogram.Encoding.IHeader">
            <summary>
            Defines the header properties to be encoded for an HdrHistogram.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.Cookie">
            <summary>
            The cookie value for the histogram.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.PayloadLengthInBytes">
            <summary>
            The length in bytes of the payload body.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.NormalizingIndexOffset">
            <summary>
            The normalizing index offset.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.NumberOfSignificantValueDigits">
            <summary>
            THe number of significant digits that values are measured to.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.LowestTrackableUnitValue">
            <summary>
            The lowest trackable value for the histogram
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.HighestTrackableValue">
            <summary>
            The highest trackable value for the histogram
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.IntegerToDoubleValueConversionRatio">
            <summary>
            Integer to double conversion ratio.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IHeader.CapacityEstimateExcess">
            <summary>
            The amount of excess capacity that will not be needed.
            </summary>
        </member>
        <member name="T:HdrHistogram.Encoding.IRecordedData">
            <summary>
            Defines the histogram data to be recorded
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.Cookie">
            <summary>
            The cookie value for the histogram.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.NormalizingIndexOffset">
            <summary>
            The normalizing index offset.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.NumberOfSignificantValueDigits">
            <summary>
            THe number of significant digits that values are measured to.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.LowestDiscernibleValue">
            <summary>
            The lowest trackable value for the histogram
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.HighestTrackableValue">
            <summary>
            The highest trackable value for the histogram
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.IntegerToDoubleValueConversionRatio">
            <summary>
            Integer to double conversion ratio.
            </summary>
        </member>
        <member name="P:HdrHistogram.Encoding.IRecordedData.Counts">
            <summary>
            The actual array of counts.
            </summary>
        </member>
        <member name="T:HdrHistogram.HistogramFactory">
            <summary>
            Provides factory methods to define the features of your histogram.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.#ctor">
            <summary>
            Private constructor to force usage via the Static starter methods.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramFactory.LowestTrackableValue">
            <summary>
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramFactory.HighestTrackableValue">
            <summary>
            The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <see cref="P:HdrHistogram.HistogramFactory.LowestTrackableValue"/>).
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramFactory.NumberOfSignificantValueDigits">
            <summary>
            The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.WithThreadSafeWrites">
            <summary>
            Specifies that the Histogram to be created should be thread safe when written to from multiple threads.
            </summary>
            <returns>Returns a <see cref="T:HdrHistogram.HistogramFactory"/> that is set to return a threadsafe writer.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.WithThreadSafeReads">
            <summary>
            Specifies that the consumer will need to be able to read Histogram values in a thread safe manner.
            This will mean <see cref="T:HdrHistogram.Recorder"/> will be used to wrap the Histogram, allowing thread safe reads.
            </summary>
            <returns>Returns a <see cref="T:HdrHistogram.HistogramFactory.RecorderFactory"/> which can create recorders. Recorders allow for threadsafe reads.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.Create(System.Int64,System.Int64,System.Int32)">
            <summary>
            A factory-method to create the Histogram.
            </summary>
            <param name="lowestDiscernibleValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestDiscernibleValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.
            </param>
            <returns>Returns a newly created <see cref="T:HdrHistogram.HistogramBase"/> instance defined by the settings of the current instance of <see cref="T:HdrHistogram.HistogramFactory"/>.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.Create(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            A factory-method to create the Histogram.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestDiscernibleValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestDiscernibleValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.
            </param>
            <returns>Returns a newly created <see cref="T:HdrHistogram.HistogramBase"/> instance defined by the settings of the current instance of <see cref="T:HdrHistogram.HistogramFactory"/>.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.WithValuesFrom(System.Int64)">
            <summary>
            Specifies the lowest value the Histogram should be configured to record.
            </summary>
            <param name="lowestDiscernibleValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <returns>The <see cref="T:HdrHistogram.HistogramFactory"/> configured with the specified minimum allowed value.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.WithValuesUpTo(System.Int64)">
            <summary>
            Specifies the highest value the Histogram should be configured to record.
            </summary>
            <param name="highestTrackableValue">
            The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <see cref="P:HdrHistogram.HistogramFactory.LowestTrackableValue"/>).
            </param>
            <returns>The <see cref="T:HdrHistogram.HistogramFactory"/> configured with the specified maximum allowed value.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.WithPrecisionOf(System.Int32)">
            <summary>
            Specifies the number of significant figures that the Histogram should record.
            </summary>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.
            </param>
            <returns>The <see cref="T:HdrHistogram.HistogramFactory"/> configured with the specified maximum allowed value.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.Create">
            <summary>
            Creates the histogram as configured by this factory instance.
            </summary>
            <returns>A newly created instance of <see cref="T:HdrHistogram.HistogramBase"/>.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.With64BitBucketSize">
            <summary>
            Specify that the Histogram should be able to record count values in the 64bit range.
            </summary>
            <returns>The <see cref="T:HdrHistogram.HistogramFactory"/> configured for 64bit bucket sizes.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.With32BitBucketSize">
            <summary>
            Specify that the Histogram should be able to record count values in the 32bit range.
            </summary>
            <returns>The <see cref="T:HdrHistogram.HistogramFactory"/> configured for 64bit bucket sizes.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.With16BitBucketSize">
            <summary>
            Specify that the Histogram should be able to record count values in the 32bit range.
            </summary>
            <returns>The <see cref="T:HdrHistogram.HistogramFactory"/> configured for 64bit bucket sizes.</returns>
        </member>
        <member name="T:HdrHistogram.HistogramFactory.RecorderFactory">
            <summary>
            Factory for creating Recorders for thread safe reading of histograms.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramFactory.RecorderFactory.Create">
            <summary>
            Creates the recorder as configured by this factory instance.
            </summary>
            <returns>A newly created instance of <see cref="T:HdrHistogram.Recorder"/>.</returns>
        </member>
        <member name="T:HdrHistogram.HistogramBase">
            <summary>
            Base class for High Dynamic Range (HDR) Histograms
            </summary>
            <remarks>
            <see cref="T:HdrHistogram.HistogramBase"/> supports the recording and analyzing sampled data value counts across a configurable
            integer value range with configurable value precision within the range.
            Value precision is expressed as the number of significant digits in the value recording, and provides control over 
            value quantization behavior across the value range and the subsequent value resolution at any given level.
            <para>
            For example, a Histogram could be configured to track the counts of observed integer values between 0 and
            36,000,000,000 while maintaining a value precision of 3 significant digits across that range.
            Value quantization within the range will thus be no larger than 1/1,000th (or 0.1%) of any value.
            This example Histogram could be used to track and analyze the counts of observed response times ranging between
            100 nanoseconds and 1 hour in magnitude, while maintaining a value resolution of 100 nanosecond up to 
            100 microseconds, a resolution of 1 millisecond(or better) up to one second, and a resolution of 1 second 
            (or better) up to 1,000 seconds.
            At it's maximum tracked value(1 hour), it would still maintain a resolution of 3.6 seconds (or better).
            </para>
            </remarks>
        </member>
        <member name="P:HdrHistogram.HistogramBase.InstanceId">
            <summary>
            An identifier for the Histogram. Maybe generated by the Recorder if used.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.HighestTrackableValue">
            <summary>
            Get the configured highestTrackableValue
            </summary>
            <returns>highestTrackableValue</returns>
        </member>
        <member name="P:HdrHistogram.HistogramBase.LowestTrackableValue">
            <summary>
            Get the configured lowestTrackableValue
            </summary>
            <returns>lowestTrackableValue</returns>
        </member>
        <member name="P:HdrHistogram.HistogramBase.NumberOfSignificantValueDigits">
            <summary>
            Get the configured numberOfSignificantValueDigits
            </summary>
            <returns>numberOfSignificantValueDigits</returns>
        </member>
        <member name="P:HdrHistogram.HistogramBase.StartTimeStamp">
            <summary>
            Gets or Sets the start time stamp value associated with this histogram to a given value.
            By convention in milliseconds since the epoch.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.EndTimeStamp">
            <summary>
            Gets or Sets the end time stamp value associated with this histogram to a given value.
            By convention in milliseconds since the epoch.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.Tag">
            <summary>
            Gets or Sets the optional Tag string associated with this histogram.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.TotalCount">
            <summary>
            Gets the total number of recorded values.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.BucketCount">
            <summary>
            The number of buckets used to store count values.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.SubBucketCount">
            <summary>
            The number of sub-buckets used to store count values.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.CountsArrayLength">
            <summary>
            The length of the internal array that stores the counts.
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.WordSizeInBytes">
            <summary>
            Returns the word size of this implementation
            </summary>
        </member>
        <member name="P:HdrHistogram.HistogramBase.MaxAllowableCount">
            <summary>
            The maximum value a count can be for any given bucket.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramBase.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a histogram given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in nanoseconds, where the minimal accuracy required is a
            microsecond, the proper value for <paramref name="lowestTrackableValue"/> would be 1000.
            </remarks>
        </member>
        <member name="M:HdrHistogram.HistogramBase.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a histogram given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in ticks (100 nanoseconds), where the minimal accuracy required is a
            microsecond, the proper value for lowestTrackableValue would be 10.
            </remarks>
        </member>
        <member name="M:HdrHistogram.HistogramBase.Copy">
            <summary>
            Copies the data from this instance to a new instance.
            </summary>
            <returns>A new copy of this instance.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.RecordValue(System.Int64)">
            <summary>
            Records a value in the histogram
            </summary>
            <param name="value">The value to be recorded</param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
        </member>
        <member name="M:HdrHistogram.HistogramBase.RecordValueWithCount(System.Int64,System.Int64)">
            <summary>
            Record a value in the histogram (adding to the value's current count)
            </summary>
            <param name="value">The value to be recorded</param>
            <param name="count">The number of occurrences of this value to record</param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
        </member>
        <member name="M:HdrHistogram.HistogramBase.RecordValueWithExpectedInterval(System.Int64,System.Int64)">
            <summary>
            Record a value in the histogram.
            </summary>
            <param name="value">The value to record</param>
            <param name="expectedIntervalBetweenValueSamples">If <paramref name="expectedIntervalBetweenValueSamples"/> is larger than 0, add auto-generated value records as appropriate if <paramref name="value"/> is larger than <paramref name="expectedIntervalBetweenValueSamples"/></param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
            <remarks>
            To compensate for the loss of sampled values when a recorded value is larger than the expected interval between value samples, 
            Histogram will auto-generate an additional series of decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records.
            <para>
            Note: This is a at-recording correction method, as opposed to the post-recording correction method provided by currently unimplemented <c>CopyCorrectedForCoordinatedOmission</c> method.
            The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct for the same coordinated omission issue.
            </para>
            See notes in the description of the Histogram calls for an illustration of why this corrective behavior is important.
            </remarks>
        </member>
        <member name="M:HdrHistogram.HistogramBase.Reset">
            <summary>
            Reset the contents and stats of this histogram
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramBase.Add(HdrHistogram.HistogramBase)">
            <summary>
            Add the contents of another histogram to this one.
            </summary>
            <param name="fromHistogram">The other histogram.</param>
            <exception cref="T:System.IndexOutOfRangeException">if values in fromHistogram's are higher than highestTrackableValue.</exception>
        </member>
        <member name="M:HdrHistogram.HistogramBase.SizeOfEquivalentValueRange(System.Int64)">
            <summary>
            Get the size (in value units) of the range of values that are equivalent to the given value within the histogram's resolution. 
            Where "equivalent" means that value samples recorded for any two equivalent values are counted in a common total count.
            </summary>
            <param name="value">The given value</param>
            <returns>The lowest value that is equivalent to the given value within the histogram's resolution.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.LowestEquivalentValue(System.Int64)">
            <summary>
            Get the lowest value that is equivalent to the given value within the histogram's resolution.
            Where "equivalent" means that value samples recorded for any two equivalent values are counted in a common total count.
            </summary>
            <param name="value">The given value</param>
            <returns>The lowest value that is equivalent to the given value within the histogram's resolution.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.MedianEquivalentValue(System.Int64)">
            <summary>
            Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.
            Where "equivalent" means that value samples recorded for any two equivalent values are counted in a common total count.
            </summary>
            <param name="value">The given value</param>
            <returns>The value lies in the middle (rounded up) of the range of values equivalent the given value.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.NextNonEquivalentValue(System.Int64)">
            <summary>
            Get the next value that is not equivalent to the given value within the histogram's resolution.
            Where "equivalent" means that value samples recorded for any two equivalent values are counted in a common total count.
            </summary>
            <param name="value">The given value</param>
            <returns>The next value that is not equivalent to the given value within the histogram's resolution.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.GetValueAtPercentile(System.Double)">
            <summary>
            Get the value at a given percentile
            </summary>
            <param name="percentile">The percentile to get the value for</param>
            <returns>The value a given percentage of all recorded value entries in the histogram fall below.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.GetCountAtValue(System.Int64)">
            <summary>
            Get the count of recorded values at a specific value
            </summary>
            <param name="value">The value for which to provide the recorded count</param>
            <returns>The total count of values recorded in the histogram at the given value (to within the histogram resolution at the value level).</returns>
            <exception cref="T:System.IndexOutOfRangeException">On parameters that are outside the tracked value range</exception>
        </member>
        <member name="M:HdrHistogram.HistogramBase.RecordedValues">
            <summary>
            Provide a means of iterating through all recorded histogram values using the finest granularity steps supported by the underlying representation.
            The iteration steps through all non-zero recorded value counts, and terminates when all recorded histogram values are exhausted.
            </summary>
            <returns>An enumerator of <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> through the histogram using a <see cref="T:HdrHistogram.Iteration.RecordedValuesEnumerator"/></returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.AllValues">
            <summary>
            Provide a means of iterating through all histogram values using the finest granularity steps supported by the underlying representation.
            The iteration steps through all possible unit value levels, regardless of whether or not there were recorded values for that value level, and terminates when all recorded histogram values are exhausted.
            </summary>
            <returns>An enumerator of <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> through the histogram using a <see cref="T:HdrHistogram.Iteration.RecordedValuesEnumerator"/></returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.GetNeededByteBufferCapacity">
            <summary>
            Get the capacity needed to encode this histogram into a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>
            </summary>
            <returns>the capacity needed to encode this histogram into a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/></returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.Encode(HdrHistogram.Utilities.ByteBuffer,HdrHistogram.Encoding.IEncoder)">
            <summary>
            Encode this histogram into a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>
            </summary>
            <param name="targetBuffer">The buffer to encode into</param>
            <param name="encoder">The encoder to use</param>
            <returns>The number of bytes written to the buffer</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.HasOverflowed">
            <summary>
            Determine if this histogram had any of it's value counts overflow.
            </summary>
            <returns><c>true</c> if this histogram has had a count value overflow, else <c>false</c>.</returns>
            <remarks>
            Since counts are kept in fixed integer form with potentially limited range (e.g. int and short), a specific value range count could potentially overflow, leading to an inaccurate and misleading histogram representation.
            This method accurately determines whether or not an overflow condition has happened in an <see cref="T:HdrHistogram.IntHistogram"/> or <see cref="T:HdrHistogram.ShortHistogram"/>.
            </remarks>
        </member>
        <member name="M:HdrHistogram.HistogramBase.GetEstimatedFootprintInBytes">
            <summary>
            Provide a (conservatively high) estimate of the Histogram's total footprint in bytes
            </summary>
            <returns>a (conservatively high) estimate of the Histogram's total footprint in bytes</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.FillCountsFromBuffer(HdrHistogram.Utilities.ByteBuffer,System.Int32,System.Int32)">
            <summary>
            Copies data from the provided buffer into the internal counts array.
            </summary>
            <param name="buffer">The buffer to read from.</param>
            <param name="length">The length of the buffer to read.</param>
            <param name="wordSizeInBytes">The word size in bytes.</param>
        </member>
        <member name="M:HdrHistogram.HistogramBase.GetCountAtIndex(System.Int32)">
            <summary>
            Gets the number of recorded values at a given index.
            </summary>
            <param name="index">The index to get the count for</param>
            <returns>The number of recorded values at the given index.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramBase.SetCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Sets the count at the given index.
            </summary>
            <param name="index">The index to be set</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:HdrHistogram.HistogramBase.IncrementCountAtIndex(System.Int32)">
            <summary>
            Increments the count at the given index. Will also increment the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/>.
            </summary>
            <param name="index">The index to increment the count at.</param>
        </member>
        <member name="M:HdrHistogram.HistogramBase.AddToCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Adds the specified amount to the count of the provided index. Also increments the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/> by the same amount.
            </summary>
            <param name="index">The index to increment.</param>
            <param name="addend">The amount to increment by.</param>
        </member>
        <member name="M:HdrHistogram.HistogramBase.ClearCounts">
            <summary>
            Clears the counts of this implementation.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramBase.CopyCountsInto(System.Int64[])">
            <summary>
            Copies the internal counts array into the supplied array.
            </summary>
            <param name="target">The array to write each count value into.</param>
        </member>
        <member name="M:HdrHistogram.HistogramBase.UpdatedMaxValue(System.Int64)">
            <summary>
            Set internally tracked _maxValue to new value if new value is greater than current one.
            May be overridden by subclasses for synchronization or atomicity purposes.
            </summary>
            <param name="value">new _maxValue to set</param>
        </member>
        <member name="M:HdrHistogram.HistogramBase.UpdateMinNonZeroValue(System.Int64)">
            <summary>
            Set internally tracked _minNonZeroValue to new value if new value is smaller than current one.
            May be overridden by subclasses for synchronization or atomicity purposes.
            </summary>
            <param name="value">new _minNonZeroValue to set</param>
        </member>
        <member name="T:HdrHistogram.HistogramEncoding">
            <summary>
            Exposes functionality to encode and decode <see cref="T:HdrHistogram.HistogramBase"/> types.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramEncoding.DecodeFromCompressedByteBuffer(HdrHistogram.Utilities.ByteBuffer,System.Int64)">
            <summary>
            Construct a new histogram by decoding it from a compressed form in a ByteBuffer.
            </summary>
            <param name="buffer">The buffer to decode from</param>
            <param name="minBarForHighestTrackableValue">Force highestTrackableValue to be set at least this high</param>
            <returns>The newly constructed histogram</returns>
        </member>
        <member name="M:HdrHistogram.HistogramEncoding.DecodeFromByteBuffer(HdrHistogram.Utilities.ByteBuffer,System.Int64,System.IO.Compression.DeflateStream)">
            <summary>
            Construct a new histogram by decoding it from a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            </summary>
            <param name="buffer">The buffer to decode from</param>
            <param name="minBarForHighestTrackableValue">Force highestTrackableValue to be set at least this high</param>
            <param name="decompressor">The <see cref="T:System.IO.Compression.DeflateStream"/> that is being used to decompress the payload. Optional.</param>
            <returns>The newly constructed histogram</returns>
        </member>
        <member name="M:HdrHistogram.HistogramEncoding.EncodeIntoCompressedByteBuffer(HdrHistogram.HistogramBase,HdrHistogram.Utilities.ByteBuffer)">
            <summary>
            Encode this histogram in compressed form into a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            </summary>
            <param name="source">The histogram to encode</param>
            <param name="targetBuffer">The buffer to write to</param>
            <returns>The number of bytes written to the buffer</returns>
        </member>
        <member name="M:HdrHistogram.HistogramEncoding.GetEncodingCookie(HdrHistogram.HistogramBase)">
            <summary>
            Gets the encoding cookie for a Histogram.
            </summary>
            <param name="histogram">The histogram to get the cookie for</param>
            <returns>The integer cookie value for the histogram.</returns>
        </member>
        <member name="T:HdrHistogram.HistogramExtensions">
            <summary>
            Extension methods for the Histogram types.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.GetMaxValue(HdrHistogram.HistogramBase)">
            <summary>
            Get the highest recorded value level in the histogram
            </summary>
            <returns>the Max value recorded in the histogram</returns>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.GetMean(HdrHistogram.HistogramBase)">
            <summary>
            Get the computed mean value of all recorded values in the histogram
            </summary>
            <returns>the mean value (in value units) of the histogram data</returns>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.GetStdDeviation(HdrHistogram.HistogramBase)">
            <summary>
            Get the computed standard deviation of all recorded values in the histogram
            </summary>
            <returns>the standard deviation (in value units) of the histogram data</returns>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.HighestEquivalentValue(HdrHistogram.HistogramBase,System.Int64)">
            <summary>
            Get the highest value that is equivalent to the given value within the histogram's resolution.
            Where "equivalent" means that value samples recorded for any two equivalent values are counted in a common
            total count.
            </summary>
            <param name="histogram">The histogram to operate on</param>
            <param name="value">The given value</param>
            <returns>The highest value that is equivalent to the given value within the histogram's resolution.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.CopyInto(HdrHistogram.HistogramBase,HdrHistogram.HistogramBase)">
            <summary>
            Copy this histogram into the target histogram, overwriting it's contents.
            </summary>
            <param name="source">The source histogram</param>
            <param name="targetHistogram">the histogram to copy into</param>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.Percentiles(HdrHistogram.HistogramBase,System.Int32)">
            <summary>
            Provide a means of iterating through histogram values according to percentile levels. 
            The iteration is performed in steps that start at 0% and reduce their distance to 100% according to the
            <paramref name="percentileTicksPerHalfDistance"/> parameter, ultimately reaching 100% when all recorded
            histogram values are exhausted.
            </summary>
            <param name="histogram">The histogram to operate on</param>
            <param name="percentileTicksPerHalfDistance">
            The number of iteration steps per half-distance to 100%.
            </param>
            <returns>
            An enumerator of <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> through the histogram using a
            <see cref="T:HdrHistogram.Iteration.PercentileEnumerator"/>.
            </returns>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.OutputPercentileDistribution(HdrHistogram.HistogramBase,System.IO.TextWriter,System.Int32,System.Double,System.Boolean)">
            <summary>
            Produce textual representation of the value distribution of histogram data by percentile. 
            The distribution is output with exponentially increasing resolution, with each exponentially decreasing 
            half-distance containing <paramref name="percentileTicksPerHalfDistance"/> percentile reporting tick points.
            </summary>
            <param name="histogram">The histogram to operate on</param>
            <param name="writer">The <see cref="T:System.IO.TextWriter"/> into which the distribution will be output</param>
            <param name="percentileTicksPerHalfDistance">
            The number of reporting points per exponentially decreasing half-distance
            </param>
            <param name="outputValueUnitScalingRatio">
            The scaling factor by which to divide histogram recorded values units in output.
            Use the <see cref="T:HdrHistogram.OutputScalingFactor"/> constant values to help choose an appropriate output measurement.
            </param>
            <param name="useCsvFormat">Output in CSV (Comma Separated Values) format if <c>true</c>, else use plain text form.</param>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.Record(HdrHistogram.IRecorder,System.Action)">
            <summary>
            Executes the action and records the time to complete the action. 
            The time is recorded in system clock ticks. 
            This time may vary between frameworks and platforms, but is equivalent to <c>(1/Stopwatch.Frequency)</c> seconds.
            Note this is a convenience method and can carry a cost.
            If the <paramref name="action"/> delegate is not cached, then it may incur an allocation cost for each invocation of <see cref="M:HdrHistogram.HistogramExtensions.Record(HdrHistogram.IRecorder,System.Action)"/>
            </summary>
            <param name="recorder">The <see cref="T:HdrHistogram.IRecorder"/> instance to record the latency in.</param>
            <param name="action">The functionality to execute and measure</param>
            <remarks>
            <para>
            The units returned from <code>Stopwatch.GetTimestamp()</code> are used as the unit of 
            recording here as they are the smallest unit that .NET can measure and require no 
            conversion at time of recording. 
            Instead conversion (scaling) can be done at time of output to microseconds, milliseconds,
            seconds or other appropriate unit.
            These units are sometimes referred to as ticks, but should not not to be confused with 
            ticks used in <seealso cref="T:System.DateTime"/> or <seealso cref="T:System.TimeSpan"/>.
            </para>
            <para>
            If you are able to cache the <paramref name="action"/> delegate, then doing so is encouraged.
            <example>
            Here are two examples.
            The first does not cache the delegate
            
            <code>
            for (long i = 0; i &lt; loopCount; i++)
            {
              histogram.Record(IncrementNumber);
            }
            </code>
            This second example does cache the delegate
            <code>
            Action incrementNumber = IncrementNumber;
            for (long i = 0; i &lt; loopCount; i++)
            {
              histogram.Record(incrementNumber);
            }
            </code>
            In the second example, we will not be making allocations each time i.e. an allocation of an <seealso cref="T:System.Action"/> from <code>IncrementNumber</code>.
            This will reduce memory pressure and therefore garbage collection penalties.
            For performance sensitive applications, this method may not be suitable.
            As always, you are encouraged to test and measure the impact for your scenario.
            </example>
            </para>
            </remarks>
        </member>
        <member name="M:HdrHistogram.HistogramExtensions.RecordScope(HdrHistogram.IRecorder)">
            <summary>
            Records the elapsed time till the returned token is disposed.
            This can be useful to testing large blocks of code, or wrapping around and <c>await</c> clause.
            </summary>
            <param name="recorder">The <see cref="T:HdrHistogram.IRecorder"/> instance to record the latency in.</param>
            <returns>Returns a token to be disposed once the scope </returns>
            <remarks>
            This can be helpful for recording a scope of work.
            It also has the benefit of allowing a simple way to record an awaitable method.
            <example>
            This example shows how an awaitable method can be cleanly instrumented using C# using scope.
            <code>
            using(recorder.RecordScope())
            {
                await SomeExpensiveCall();
            }
            </code>
            </example>
            It should be noted that this method returns a token and as such allocates an object.
            This should taken into consideration, specifically the cost of the allocation and GC would affect the program.
            </remarks>
        </member>
        <member name="T:HdrHistogram.HistogramFactoryDelegate">
            <summary>
            The method definition for a histogram factory.
            </summary>
            <param name="instanceId">The instance id the histogram should be created with.</param>
            <param name="lowestDiscernibleValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
        </member>
        <member name="T:HdrHistogram.HistogramLogReader">
            <summary>
            Reads a log of Histograms from the provided <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramLogReader.Read(System.IO.Stream)">
            <summary>
            Reads each histogram out from the underlying stream.
            </summary>
            <param name="inputStream">The <see cref="T:System.IO.Stream"/> to read from.</param>
            <returns>Return a lazily evaluated sequence of histograms.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramLogReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a <see cref="T:HdrHistogram.HistogramLogReader"/> that reads from the provided <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="inputStream">The <see cref="T:System.IO.Stream"/> to read from.</param>
        </member>
        <member name="M:HdrHistogram.HistogramLogReader.ReadHistograms">
            <summary>
            Reads each histogram out from the underlying stream.
            </summary>
            <returns>Return a lazily evaluated sequence of histograms.</returns>
        </member>
        <member name="M:HdrHistogram.HistogramLogReader.GetStartTime">
            <summary>
            Gets the start time for the set of Histograms.
            </summary>
            <returns>Either the explicit encoded start time, or falls back to the start time of the first histogram.</returns>
            <remarks>
            The current implementation requires the consumer to only use this after enumerating the Histograms from the <see cref="M:HdrHistogram.HistogramLogReader.ReadHistograms"/> method.
            </remarks>
        </member>
        <member name="M:HdrHistogram.HistogramLogReader.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:HdrHistogram.HistogramLogWriter">
            <summary>
            Writes zero, one or many <see cref="T:HdrHistogram.HistogramBase"/> instances to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <seealso cref="T:HdrHistogram.HistogramLogReader"/>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.Write(System.IO.Stream,System.DateTime,HdrHistogram.HistogramBase[])">
            <summary>
            Writes the provided histograms to the underlying <see cref="T:System.IO.Stream"/> with a given overall start time.
            </summary>
            <param name="outputStream">The <see cref="T:System.IO.Stream"/> to write to.</param>
            <param name="startTime">The start time of the set of histograms.</param>
            <param name="histograms">The histograms to include in the output.</param>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.#ctor(System.IO.Stream)">
            <summary>
            Creates a <see cref="T:HdrHistogram.HistogramLogWriter"/> that writes to an underlying <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="outputStream">
            The stream to write to. 
            The stream is left open for the consumer to close.
            </param>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.Write(System.DateTime,HdrHistogram.HistogramBase[])">
            <summary>
            Writes the provided histograms to the underlying <see cref="T:System.IO.Stream"/> with a given overall start time.
            </summary>
            <param name="startTime">The start time of the set of histograms.</param>
            <param name="histograms">The histograms to include in the output.</param>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.Append(HdrHistogram.HistogramBase)">
            <summary>
            Appends a Histogram to the log. 
            </summary>
            <param name="histogram">The histogram to write to the log.</param>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.WriteLogFormatVersion">
            <summary>
            Output a log format version to the log.
            </summary>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.WriteStartTime(System.DateTime)">
            <summary>
            Log a start time in the log.
            </summary>
            <param name="startTimeWritten">Time the log was started.</param>
        </member>
        <member name="M:HdrHistogram.HistogramLogWriter.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:HdrHistogram.IHistogramLogV1Reader">
            <summary>
            Defines a method for reading Histogram logs in the v1 format.
            </summary>
        </member>
        <member name="M:HdrHistogram.IHistogramLogV1Reader.ReadHistograms">
            <summary>
            Reads a v1 formatted histogram log.
            </summary>
            <returns>Returns a sequence of <see cref="T:HdrHistogram.HistogramBase"/> items.</returns>
        </member>
        <member name="T:HdrHistogram.IntConcurrentHistogram">
            <summary>
            An integer values High Dynamic Range (HDR) Histogram that supports safe concurrent recording operations.
            </summary>
            <remarks>
            A <see cref="T:HdrHistogram.IntConcurrentHistogram"/> guarantees lossless recording of values into the histogram even when the histogram is updated by multiple threads.
            <p>
            It is important to note that concurrent recording is the only thread-safe behavior provided by <seealso cref="T:HdrHistogram.IntConcurrentHistogram"/>.
            It provides no implicit synchronization that would prevent the contents of the histogram from changing during other operations.
            These non-synchronised operations include queries, iterations, copies, or addition operations on the histogram. 
            Concurrent updates that would safely work in the presence of queries, copies, or additions of histogram objects should use the <seealso cref="T:HdrHistogram.Recorder"/> which is intended for this purpose.
            </p>
            </remarks>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.IntConcurrentHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            Providing a <paramref name="lowestTrackableValue"/> is useful is situations where the units used for the histogram's values are much smaller that the minimal accuracy required. 
            For example when tracking time values stated in nanoseconds, where the minimal accuracy required is a microsecond, the proper value for <paramref name="lowestTrackableValue"/> would be 1000.
            </summary>
            <param name="lowestTrackableValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestTrackableValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.</param>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.IntConcurrentHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in ticks (100 nanoseconds), where the minimal accuracy required is a
            microsecond, the proper value for lowestTrackableValue would be 10.
            </remarks>
        </member>
        <member name="P:HdrHistogram.IntConcurrentHistogram.TotalCount">
            <summary>
            Gets the total number of recorded values.
            </summary>
        </member>
        <member name="P:HdrHistogram.IntConcurrentHistogram.WordSizeInBytes">
            <summary>
            Returns the word size of this implementation
            </summary>
        </member>
        <member name="P:HdrHistogram.IntConcurrentHistogram.MaxAllowableCount">
            <summary>
            The maximum value a count can be for any given bucket.
            </summary>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.Copy">
            <summary>
            Copies the data from this instance to a new instance.
            </summary>
            <returns>A new copy of this instance.</returns>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.GetCountAtIndex(System.Int32)">
            <summary>
            Gets the number of recorded values at a given index.
            </summary>
            <param name="index">The index to get the count for</param>
            <returns>The number of recorded values at the given index.</returns>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.SetCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Sets the count at the given index.
            </summary>
            <param name="index">The index to be set</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.IncrementCountAtIndex(System.Int32)">
            <summary>
            Increments the count at the given index. Will also increment the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/>.
            </summary>
            <param name="index">The index to increment the count at.</param>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.AddToCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Adds the specified amount to the count of the provided index. Also increments the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/> by the same amount.
            </summary>
            <param name="index">The index to increment.</param>
            <param name="addend">The amount to increment by.</param>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.ClearCounts">
            <summary>
            Clears the counts of this implementation.
            </summary>
        </member>
        <member name="M:HdrHistogram.IntConcurrentHistogram.CopyCountsInto(System.Int64[])">
            <summary>
            Copies the internal counts array into the supplied array.
            </summary>
            <param name="target">The array to write each count value into.</param>
        </member>
        <member name="T:HdrHistogram.IntHistogram">
            <summary>
            A High Dynamic Range (HDR) Histogram using an <see cref="T:System.Int32"/> count type.
            </summary>
            <remarks>
            Histogram supports the recording and analyzing sampled data value counts across a configurable integer value
            range with configurable value precision within the range.
            Value precision is expressed as the number of significant digits in the value recording, and provides control 
            over value quantization behavior across the value range and the subsequent value resolution at any given level.
            <para>
            For example, a Histogram could be configured to track the counts of observed integer values between 0 and
            36,000,000,000 while maintaining a value precision of 3 significant digits across that range.
            Value quantization within the range will thus be no larger than 1/1,000th (or 0.1%) of any value.
            This example Histogram could be used to track and analyze the counts of observed response times ranging between
            100 nanoseconds and 1 hour in magnitude, while maintaining a value resolution of 100 nanosecond up to 
            100 microseconds, a resolution of 1 millisecond(or better) up to one second, and a resolution of 1 second 
            (or better) up to 1,000 seconds.
            At it's maximum tracked value(1 hour), it would still maintain a resolution of 3.6 seconds (or better).
            </para>
            Histogram tracks value counts in <see cref="T:System.Int32"/> fields.
            Other field types are available in the <see cref="T:HdrHistogram.LongHistogram"/> and <see cref="T:HdrHistogram.ShortHistogram"/> 
            implementations of <see cref="T:HdrHistogram.HistogramBase"/>.
            </remarks>
        </member>
        <member name="M:HdrHistogram.IntHistogram.#ctor(System.Int64,System.Int32)">
            <summary>
            Construct an <see cref="T:HdrHistogram.IntHistogram"/> given the highest value to be tracked and a number of significant decimal digits. 
            The histogram will be constructed to implicitly track(distinguish from 0) values as low as 1. 
            </summary>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= 2.</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.Must be a non-negative integer between 0 and 5.</param>
        </member>
        <member name="M:HdrHistogram.IntHistogram.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.IntHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            Providing a <paramref name="lowestTrackableValue"/> is useful is situations where the units used for the histogram's values are much smaller that the minimal accuracy required.
            For example when tracking time values stated in nanoseconds, where the minimal accuracy required is a microsecond, the proper value for <paramref name="lowestTrackableValue"/> would be 1000.
            </summary>
            <param name="lowestTrackableValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestTrackableValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.Must be a non-negative integer between 0 and 5.</param>
        </member>
        <member name="M:HdrHistogram.IntHistogram.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.IntHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in ticks (100 nanoseconds), where the minimal accuracy required is a
            microsecond, the proper value for lowestTrackableValue would be 10.
            </remarks>
        </member>
        <member name="P:HdrHistogram.IntHistogram.TotalCount">
            <summary>
            Gets the total number of recorded values.
            </summary>
        </member>
        <member name="P:HdrHistogram.IntHistogram.WordSizeInBytes">
            <summary>
            Returns the word size of this implementation
            </summary>
        </member>
        <member name="P:HdrHistogram.IntHistogram.MaxAllowableCount">
            <summary>
            The maximum value a count can be for any given bucket.
            </summary>
        </member>
        <member name="M:HdrHistogram.IntHistogram.Copy">
            <summary>
            Create a copy of this histogram, complete with data and everything.
            </summary>
            <returns>A distinct copy of this histogram.</returns>
        </member>
        <member name="M:HdrHistogram.IntHistogram.GetCountAtIndex(System.Int32)">
            <summary>
            Gets the number of recorded values at a given index.
            </summary>
            <param name="index">The index to get the count for</param>
            <returns>The number of recorded values at the given index.</returns>
        </member>
        <member name="M:HdrHistogram.IntHistogram.SetCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Sets the count at the given index.
            </summary>
            <param name="index">The index to be set</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:HdrHistogram.IntHistogram.IncrementCountAtIndex(System.Int32)">
            <summary>
            Increments the count at the given index. Will also increment the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/>.
            </summary>
            <param name="index">The index to increment the count at.</param>
        </member>
        <member name="M:HdrHistogram.IntHistogram.AddToCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Adds the specified amount to the count of the provided index. Also increments the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/> by the same amount.
            </summary>
            <param name="index">The index to increment.</param>
            <param name="addend">The amount to increment by.</param>
        </member>
        <member name="M:HdrHistogram.IntHistogram.ClearCounts">
            <summary>
            Clears the counts of this implementation.
            </summary>
        </member>
        <member name="M:HdrHistogram.IntHistogram.CopyCountsInto(System.Int64[])">
            <summary>
            Copies the internal counts array into the supplied array.
            </summary>
            <param name="target">The array to write each count value into.</param>
        </member>
        <member name="T:HdrHistogram.IRecorder">
            <summary>
            Provides methods to record values.
            </summary>
        </member>
        <member name="M:HdrHistogram.IRecorder.RecordValue(System.Int64)">
            <summary>
            Records a value in the histogram
            </summary>
            <param name="value">The value to be recorded</param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
        </member>
        <member name="M:HdrHistogram.IRecorder.RecordValueWithCount(System.Int64,System.Int64)">
            <summary>
            Record a value in the histogram (adding to the value's current count)
            </summary>
            <param name="value">The value to be recorded</param>
            <param name="count">The number of occurrences of this value to record</param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
        </member>
        <member name="M:HdrHistogram.IRecorder.RecordValueWithExpectedInterval(System.Int64,System.Int64)">
            <summary>
            Record a value in the histogram.
            </summary>
            <param name="value">The value to record</param>
            <param name="expectedIntervalBetweenValueSamples">If <paramref name="expectedIntervalBetweenValueSamples"/> is larger than 0, add auto-generated value records as appropriate if <paramref name="value"/> is larger than <paramref name="expectedIntervalBetweenValueSamples"/></param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
            <remarks>
            To compensate for the loss of sampled values when a recorded value is larger than the expected interval between value samples, 
            Histogram will auto-generate an additional series of decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records.
            <para>
            Note: This is a at-recording correction method, as opposed to the post-recording correction method provided by currently unimplemented <c>CopyCorrectedForCoordinatedOmission</c> method.
            The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct for the same coordinated omission issue.
            </para>
            See notes in the description of the Histogram calls for an illustration of why this corrective behavior is important.
            </remarks>
        </member>
        <member name="T:HdrHistogram.Iteration.AbstractHistogramEnumerator">
            <summary>
            Provide functionality for enumerating over histogram counts.
            </summary>
        </member>
        <member name="M:HdrHistogram.Iteration.AbstractHistogramEnumerator.HasNext">
            <summary>
             Returns <c>true</c> if the iteration has more elements. (In other words, returns true if next would return an element rather than throwing an exception.)
            </summary>
            <returns><c>true</c> if the iterator has more elements.</returns>
        </member>
        <member name="M:HdrHistogram.Iteration.AbstractHistogramEnumerator.Next">
            <summary>
            Returns the next element in the iteration.
            </summary>
            <returns>the <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> associated with the next element in the iteration.</returns>
        </member>
        <member name="T:HdrHistogram.Iteration.AllValueEnumerable">
            <summary>
            An enumerator of <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> through the histogram using a <see cref="T:HdrHistogram.Iteration.AllValuesEnumerator"/>
            </summary>
        </member>
        <member name="M:HdrHistogram.Iteration.AllValueEnumerable.#ctor(HdrHistogram.HistogramBase)">
            <summary>
            The constructor for the <see cref="T:HdrHistogram.Iteration.AllValueEnumerable"/>
            </summary>
            <param name="histogram">The <see cref="T:HdrHistogram.HistogramBase"/> to enumerate the values from.</param>
        </member>
        <member name="T:HdrHistogram.Iteration.AllValuesEnumerator">
            <summary>
            Used for iterating through histogram values using the finest granularity steps supported by the underlying
            representation.The iteration steps through all possible unit value levels, regardless of whether or not
            there were recorded values for that value level, and terminates when all recorded histogram values are exhausted.
            </summary>
        </member>
        <member name="M:HdrHistogram.Iteration.AllValuesEnumerator.#ctor(HdrHistogram.HistogramBase)">
            <summary>
            Constructor for the <see cref="T:HdrHistogram.Iteration.AllValuesEnumerator"/>.
            </summary>
            <param name="histogram">The histogram this iterator will operate on</param>
        </member>
        <member name="T:HdrHistogram.Iteration.HistogramIterationValue">
            <summary>
            Represents a value point iterated through in a Histogram, with associated stats.
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.ValueIteratedTo">
            <summary>
            The actual value level that was iterated to by the iterator
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.ValueIteratedFrom">
            <summary>
            The actual value level that was iterated from by the iterator
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.CountAtValueIteratedTo">
            <summary>
            The count of recorded values in the histogram that exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value range.
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.CountAddedInThisIterationStep">
            <summary>
            The count of recorded values in the histogram that were added to the totalCountToThisValue(below) as a result on this iteration step. Since multiple iteration steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at the value (e.g.multiple linear steps or percentile levels can occur within a single equivalent value range)
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.TotalCountToThisValue">
            <summary>
            The total count of all recorded values in the histogram at values equal or smaller than valueIteratedTo.
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.TotalValueToThisValue">
            <summary>
            The sum of all recorded values in the histogram at values equal or smaller than valueIteratedTo.
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.Percentile">
            <summary>
            The percentile of recorded values in the histogram at values equal or smaller than valueIteratedTo.
            </summary>
        </member>
        <member name="P:HdrHistogram.Iteration.HistogramIterationValue.PercentileLevelIteratedTo">
            <summary>
            The percentile level that the iterator returning this HistogramIterationValue had iterated to.
            Generally, percentileLevelIteratedTo will be equal to or smaller than percentile, but the same value point can contain multiple iteration levels for some iterators. 
            e.g. a PercentileEnumerator can stop multiple times in the exact same value point (if the count at that value covers a range of multiple percentiles in the requested percentile iteration points).
            </summary>
        </member>
        <member name="M:HdrHistogram.Iteration.HistogramIterationValue.IsLastValue">
            <summary>
            Indicates if this item is to be considered the last value in the set.
            </summary>
            <returns>Returns <c>true</c> if it is the last value, else <c>false</c>.</returns>
        </member>
        <member name="M:HdrHistogram.Iteration.HistogramIterationValue.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:HdrHistogram.Iteration.PercentileEnumerable">
            <summary>
            An enumerator of <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> through the histogram using a <see cref="T:HdrHistogram.Iteration.PercentileEnumerator"/>
            </summary>
        </member>
        <member name="T:HdrHistogram.Iteration.PercentileEnumerator">
            <summary>
            Used for iterating through histogram values according to percentile levels.The iteration is
            performed in steps that start at 0% and reduce their distance to 100% according to the
            <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram
            values are exhausted.
            </summary>
        </member>
        <member name="M:HdrHistogram.Iteration.PercentileEnumerator.#ctor(HdrHistogram.HistogramBase,System.Int32)">
            <summary>
            The constructor for the <see cref="T:HdrHistogram.Iteration.PercentileEnumerator"/>
            </summary>
            <param name="histogram">The histogram this iterator will operate on</param>
            <param name="percentileTicksPerHalfDistance">The number of iteration steps per half-distance to 100%.</param>
        </member>
        <member name="T:HdrHistogram.Iteration.RecordedValuesEnumerable">
            <summary>
            An enumerator of <see cref="T:HdrHistogram.Iteration.HistogramIterationValue"/> through the histogram using a <see cref="T:HdrHistogram.Iteration.RecordedValuesEnumerator"/>
            </summary>
        </member>
        <member name="T:HdrHistogram.Iteration.RecordedValuesEnumerator">
            <summary>
            An enumerator that enumerate over all non-zero values.
            </summary>
        </member>
        <member name="M:HdrHistogram.Iteration.RecordedValuesEnumerator.#ctor(HdrHistogram.HistogramBase)">
            <summary>
            The constructor for <see cref="T:HdrHistogram.Iteration.RecordedValuesEnumerator"/>
            </summary>
            <param name="histogram">The histogram this iterator will operate on</param>
        </member>
        <member name="T:HdrHistogram.LongConcurrentHistogram">
            <summary>
            An integer values High Dynamic Range (HDR) Histogram that supports safe concurrent recording operations.
            </summary>
            <remarks>
            A <see cref="T:HdrHistogram.LongConcurrentHistogram"/> guarantees lossless recording of values into the histogram even when the histogram is updated by multiple threads.
            <p>
            It is important to note that concurrent recording is the only thread-safe behavior provided by <seealso cref="T:HdrHistogram.LongConcurrentHistogram"/>.
            It provides no implicit synchronization that would prevent the contents of the histogram from changing during other operations.
            These non-synchronised operations include queries, iterations, copies, or addition operations on the histogram. 
            Concurrent updates that would safely work in the presence of queries, copies, or additions of histogram objects should use the <seealso cref="T:HdrHistogram.Recorder"/> which is intended for this purpose.
            </p>
            </remarks>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.LongConcurrentHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            Providing a <paramref name="lowestTrackableValue"/> is useful is situations where the units used for the histogram's values are much smaller that the minimal accuracy required. 
            For example when tracking time values stated in nanoseconds, where the minimal accuracy required is a microsecond, the proper value for <paramref name="lowestTrackableValue"/> would be 1000.
            </summary>
            <param name="lowestTrackableValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestTrackableValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.</param>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.LongConcurrentHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in ticks (100 nanoseconds), where the minimal accuracy required is a
            microsecond, the proper value for lowestTrackableValue would be 10.
            </remarks>
        </member>
        <member name="P:HdrHistogram.LongConcurrentHistogram.TotalCount">
            <summary>
            Gets the total number of recorded values.
            </summary>
        </member>
        <member name="P:HdrHistogram.LongConcurrentHistogram.WordSizeInBytes">
            <summary>
            Returns the word size of this implementation
            </summary>
        </member>
        <member name="P:HdrHistogram.LongConcurrentHistogram.MaxAllowableCount">
            <summary>
            The maximum value a count can be for any given bucket.
            </summary>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.Copy">
            <summary>
            Copies the data from this instance to a new instance.
            </summary>
            <returns>A new copy of this instance.</returns>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.GetCountAtIndex(System.Int32)">
            <summary>
            Gets the number of recorded values at a given index.
            </summary>
            <param name="index">The index to get the count for</param>
            <returns>The number of recorded values at the given index.</returns>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.SetCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Sets the count at the given index.
            </summary>
            <param name="index">The index to be set</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.IncrementCountAtIndex(System.Int32)">
            <summary>
            Increments the count at the given index. Will also increment the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/>.
            </summary>
            <param name="index">The index to increment the count at.</param>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.AddToCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Adds the specified amount to the count of the provided index. Also increments the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/> by the same amount.
            </summary>
            <param name="index">The index to increment.</param>
            <param name="addend">The amount to increment by.</param>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.ClearCounts">
            <summary>
            Clears the counts of this implementation.
            </summary>
        </member>
        <member name="M:HdrHistogram.LongConcurrentHistogram.CopyCountsInto(System.Int64[])">
            <summary>
            Copies the internal counts array into the supplied array.
            </summary>
            <param name="target">The array to write each count value into.</param>
        </member>
        <member name="T:HdrHistogram.LongHistogram">
            <summary>
            A High Dynamic Range (HDR) Histogram
            </summary>
            <remarks>
            Histogram supports the recording and analyzing sampled data value counts across a configurable integer value
            range with configurable value precision within the range.
            Value precision is expressed as the number of significant digits in the value recording, and provides control 
            over value quantization behavior across the value range and the subsequent value resolution at any given level.
            <para>
            For example, a Histogram could be configured to track the counts of observed integer values between 0 and
            36,000,000,000 while maintaining a value precision of 3 significant digits across that range.
            Value quantization within the range will thus be no larger than 1/1,000th (or 0.1%) of any value.
            This example Histogram could be used to track and analyze the counts of observed response times ranging between
            100 nanoseconds and 1 hour in magnitude, while maintaining a value resolution of 100 nanosecond up to 
            100 microseconds, a resolution of 1 millisecond(or better) up to one second, and a resolution of 1 second 
            (or better) up to 1,000 seconds.
            At it's maximum tracked value(1 hour), it would still maintain a resolution of 3.6 seconds (or better).
            </para>
            Histogram tracks value counts in <see cref="T:System.Int64"/> fields.
            </remarks>
        </member>
        <member name="M:HdrHistogram.LongHistogram.#ctor(System.Int64,System.Int32)">
            <summary>
            Construct a Histogram given the highest value to be tracked and a number of significant decimal digits. 
            The histogram will be constructed to implicitly track(distinguish from 0) values as low as 1.
            </summary>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= 2.</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.
            </param>
        </member>
        <member name="M:HdrHistogram.LongHistogram.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.LongHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            Providing a <paramref name="lowestTrackableValue"/> is useful is situations where the units used for the histogram's values are much smaller that the minimal accuracy required. 
            For example when tracking time values stated in nanosecond units, where the minimal accuracy required is a microsecond, the proper value for <paramref name="lowestTrackableValue"/> would be 1000.
            </summary>
            <param name="lowestTrackableValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestTrackableValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.
            </param>
        </member>
        <member name="M:HdrHistogram.LongHistogram.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.LongHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in ticks (100 nanoseconds), where the minimal accuracy required is a
            microsecond, the proper value for lowestTrackableValue would be 10.
            </remarks>
        </member>
        <member name="P:HdrHistogram.LongHistogram.TotalCount">
            <summary>
            Gets the total number of recorded values.
            </summary>
        </member>
        <member name="P:HdrHistogram.LongHistogram.WordSizeInBytes">
            <summary>
            Returns the word size of this implementation
            </summary>
        </member>
        <member name="P:HdrHistogram.LongHistogram.MaxAllowableCount">
            <summary>
            The maximum value a count can be for any given bucket.
            </summary>
        </member>
        <member name="M:HdrHistogram.LongHistogram.Copy">
            <summary>
            Create a copy of this histogram, complete with data and everything.
            </summary>
            <returns>A distinct copy of this histogram.</returns>
        </member>
        <member name="M:HdrHistogram.LongHistogram.GetCountAtIndex(System.Int32)">
            <summary>
            Gets the number of recorded values at a given index.
            </summary>
            <param name="index">The index to get the count for</param>
            <returns>The number of recorded values at the given index.</returns>
        </member>
        <member name="M:HdrHistogram.LongHistogram.SetCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Sets the count at the given index.
            </summary>
            <param name="index">The index to be set</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:HdrHistogram.LongHistogram.IncrementCountAtIndex(System.Int32)">
            <summary>
            Increments the count at the given index. Will also increment the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/>.
            </summary>
            <param name="index">The index to increment the count at.</param>
        </member>
        <member name="M:HdrHistogram.LongHistogram.AddToCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Adds the specified amount to the count of the provided index. Also increments the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/> by the same amount.
            </summary>
            <param name="index">The index to increment.</param>
            <param name="addend">The amount to increment by.</param>
        </member>
        <member name="M:HdrHistogram.LongHistogram.ClearCounts">
            <summary>
            Clears the counts of this implementation.
            </summary>
        </member>
        <member name="M:HdrHistogram.LongHistogram.CopyCountsInto(System.Int64[])">
            <summary>
            Copies the internal counts array into the supplied array.
            </summary>
            <param name="target">The array to write each count value into.</param>
        </member>
        <member name="T:HdrHistogram.OutputScalingFactor">
            <summary>
            Provides constants to use in selecting a scaling factor for output of a histograms recordings.
            </summary>
        </member>
        <member name="F:HdrHistogram.OutputScalingFactor.None">
            <summary>
            For use when values are recorded and reported in the same unit of measurement.
            </summary>
        </member>
        <member name="F:HdrHistogram.OutputScalingFactor.TimeStampToMicroseconds">
            <summary>
            For use when values are recorded with <seealso cref="M:System.Diagnostics.Stopwatch.GetTimestamp"/> and output should be reported in microseconds.
            </summary>
        </member>
        <member name="F:HdrHistogram.OutputScalingFactor.TimeStampToMilliseconds">
            <summary>
            For use when values are recorded with <seealso cref="M:System.Diagnostics.Stopwatch.GetTimestamp"/> and output should be reported in milliseconds.
            </summary>
        </member>
        <member name="F:HdrHistogram.OutputScalingFactor.TimeStampToSeconds">
            <summary>
            For use when values are recorded with <seealso cref="M:System.Diagnostics.Stopwatch.GetTimestamp"/> and output should be reported in seconds.
            </summary>
        </member>
        <member name="T:HdrHistogram.Persistence.CountsDecoder">
            <summary>
            Provides a method to get the correct <see cref="T:HdrHistogram.Persistence.ICountsDecoder"/> implementation for a given word size.
            </summary>
        </member>
        <member name="M:HdrHistogram.Persistence.CountsDecoder.GetDecoderForWordSize(System.Int32)">
            <summary>
            Gets the correct implementation of a <see cref="T:HdrHistogram.Persistence.ICountsDecoder"/> for the supplied word size.
            </summary>
            <param name="wordSize">The word size of the encoded histogram</param>
            <returns>A <see cref="T:HdrHistogram.Persistence.ICountsDecoder"/> implementation.</returns>
        </member>
        <member name="T:HdrHistogram.Persistence.ICountsDecoder">
            <summary>
            Defines methods to read counts values from a potentially encoded <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            </summary>
        </member>
        <member name="P:HdrHistogram.Persistence.ICountsDecoder.WordSize">
            <summary>
            The target word size for the encoder.
            </summary>
        </member>
        <member name="M:HdrHistogram.Persistence.ICountsDecoder.ReadCounts(HdrHistogram.Utilities.ByteBuffer,System.Int32,System.Int32,System.Action{System.Int32,System.Int64})">
            <summary>
            Decodes from a supplied <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> count values and calls a delegate with index and count.
            </summary>
            <param name="sourceBuffer">The source of the data.</param>
            <param name="lengthInBytes">The length in bytes to read.</param>
            <param name="maxIndex"></param>
            <param name="setCount">A delegate to call with the count for a given index.</param>
            <returns>The index that was read to.</returns>
        </member>
        <member name="T:HdrHistogram.Recorder">
            <summary>
            Records integer values, and provides stable interval <see cref="T:HdrHistogram.HistogramBase"/> samples from live recorded data without interrupting or stalling active recording of values.
            Each interval histogram provided contains all value counts accumulated since the previous interval histogram was taken.
            </summary>
            <remarks>
            This pattern is commonly used in logging interval histogram information while recording is ongoing.
            Recording calls are wait-free on architectures that support atomic increment operations, and are lock-free on architectures that do not.
            </remarks>
        </member>
        <member name="M:HdrHistogram.Recorder.#ctor(System.Int64,System.Int64,System.Int32,HdrHistogram.HistogramFactoryDelegate)">
            <summary>
            Creates a recorder that will delegate recording to histograms created from these parameters.
            </summary>
            <param name="lowestDiscernibleValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <param name="histogramFactory">The factory to be used to actually create instances of <seealso cref="T:HdrHistogram.HistogramBase"/>.</param>
        </member>
        <member name="M:HdrHistogram.Recorder.RecordValue(System.Int64)">
            <summary>
            Records a value in the histogram
            </summary>
            <param name="value">The value to be recorded</param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
        </member>
        <member name="M:HdrHistogram.Recorder.RecordValueWithCount(System.Int64,System.Int64)">
            <summary>
            Record a value in the histogram (adding to the value's current count)
            </summary>
            <param name="value">The value to be recorded</param>
            <param name="count">The number of occurrences of this value to record</param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
        </member>
        <member name="M:HdrHistogram.Recorder.RecordValueWithExpectedInterval(System.Int64,System.Int64)">
            <summary>
            Record a value in the histogram.
            </summary>
            <param name="value">The value to record</param>
            <param name="expectedIntervalBetweenValueSamples">If <paramref name="expectedIntervalBetweenValueSamples"/> is larger than 0, add auto-generated value records as appropriate if <paramref name="value"/> is larger than <paramref name="expectedIntervalBetweenValueSamples"/></param>
            <exception cref="T:System.IndexOutOfRangeException">if value is exceeds highestTrackableValue</exception>
            <remarks>
            To compensate for the loss of sampled values when a recorded value is larger than the expected interval between value samples, 
            Histogram will auto-generate an additional series of decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records.
            <para>
            Note: This is a at-recording correction method, as opposed to the post-recording correction method provided by currently unimplemented <c>CopyCorrectedForCoordinatedOmission</c> method.
            The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct for the same coordinated omission issue.
            </para>
            See notes in the description of the Histogram calls for an illustration of why this corrective behavior is important.
            </remarks>
        </member>
        <member name="M:HdrHistogram.Recorder.GetIntervalHistogram">
            <summary>
            Get a new instance of an interval histogram, which will include a stable, consistent view of all value counts accumulated since the last interval histogram was taken.
            Calling <see cref="M:HdrHistogram.Recorder.GetIntervalHistogram"/> will reset the value counts, and start accumulating value counts for the next interval.
            </summary>
            <returns>A histogram containing the value counts accumulated since the last interval histogram was taken.</returns>
        </member>
        <member name="M:HdrHistogram.Recorder.GetIntervalHistogram(HdrHistogram.HistogramBase)">
            <summary>
            Get a new instance of an interval histogram, which will include a stable, consistent view of all value counts accumulated since the last interval histogram was taken.
            Calling <see cref="M:HdrHistogram.Recorder.GetIntervalHistogram"/> will reset the value counts, and start accumulating value counts for the next interval.
            </summary>
            <param name="histogramToRecycle">a previously returned interval histogram that may be recycled to avoid allocation and copy operations.</param>
            <returns>A histogram containing the value counts accumulated since the last interval histogram was taken.</returns>
            <remarks>
            <see cref="M:HdrHistogram.Recorder.GetIntervalHistogram(HdrHistogram.HistogramBase)"/> accepts a previously returned interval histogram that can be recycled internally to avoid allocation and content copying operations.
            It is therefore significantly more efficient for repeated use than <see cref="M:HdrHistogram.Recorder.GetIntervalHistogram"/> and <see cref="M:HdrHistogram.Recorder.GetIntervalHistogramInto(HdrHistogram.HistogramBase)"/>.
            The provided <paramref name="histogramToRecycle"/> must be either be null or an interval histogram returned by a previous call to <see cref="M:HdrHistogram.Recorder.GetIntervalHistogram(HdrHistogram.HistogramBase)"/> or <see cref="M:HdrHistogram.Recorder.GetIntervalHistogram"/>.
            NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. 
            If the same interval histogram instance is recycled more than once, behavior is undefined.
            </remarks>
        </member>
        <member name="M:HdrHistogram.Recorder.GetIntervalHistogramInto(HdrHistogram.HistogramBase)">
            <summary>
            Place a copy of the value counts accumulated since accumulated (since the last interval histogram was taken) into <paramref name="targetHistogram"/>.
            This will overwrite the existing data in <paramref name="targetHistogram"/>.
            Calling <see cref="M:HdrHistogram.Recorder.GetIntervalHistogramInto(HdrHistogram.HistogramBase)"/> will reset the value counts, and start accumulating value counts for the next interval.
            </summary>
            <param name="targetHistogram">The histogram into which the interval histogram's data should be copied.</param>
        </member>
        <member name="M:HdrHistogram.Recorder.Reset">
            <summary>
            Reset any value counts accumulated thus far.
            </summary>
        </member>
        <member name="T:HdrHistogram.ShortHistogram">
            <summary>
            A High Dynamic Range (HDR) Histogram using a <see cref="T:System.Int16"/> count type
            </summary>
            <remarks>
            Histogram supports the recording and analyzing sampled data value counts across a configurable integer value
            range with configurable value precision within the range.
            Value precision is expressed as the number of significant digits in the value recording, and provides control 
            over value quantization behavior across the value range and the subsequent value resolution at any given level.
            <para>
            For example, a Histogram could be configured to track the counts of observed integer values between 0 and
            36,000,000,000 while maintaining a value precision of 3 significant digits across that range.
            Value quantization within the range will thus be no larger than 1/1,000th (or 0.1%) of any value.
            This example Histogram could be used to track and analyze the counts of observed response times ranging between
            100 nanoseconds and 1 hour in magnitude, while maintaining a value resolution of 100 nanosecond up to 
            100 microseconds, a resolution of 1 millisecond(or better) up to one second, and a resolution of 1 second 
            (or better) up to 1,000 seconds.
            At it's maximum tracked value(1 hour), it would still maintain a resolution of 3.6 seconds (or better).
            </para>
            Histogram tracks value counts in <see cref="T:System.Int16"/> fields.
            Other field types are available in the <see cref="T:HdrHistogram.IntHistogram"/> and <see cref="T:HdrHistogram.LongHistogram"/> 
            implementations of <see cref="T:HdrHistogram.HistogramBase"/>.
            </remarks>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.#ctor(System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.ShortHistogram"/> given the highest value to be tracked and a number of significant decimal digits. 
            The histogram will be constructed to implicitly track (distinguish from 0) values as low as 1. 
            </summary>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= 2.</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.Must be a non-negative integer between 0 and 5.</param>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.ShortHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            Providing a <paramref name="lowestTrackableValue"/> is useful is situations where the units used for the histogram's values are much smaller that the minimal accuracy required. 
            For example when tracking time values stated in nanoseconds, where the minimal accuracy required is a microsecond, the proper value for <paramref name="lowestTrackableValue"/> would be 1000.
            </summary>
            <param name="lowestTrackableValue">
            The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1. 
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram. Must be a positive integer that is &gt;= (2 * <paramref name="lowestTrackableValue"/>).</param>
            <param name="numberOfSignificantValueDigits">The number of significant decimal digits to which the histogram will maintain value resolution and separation.
            Must be a non-negative integer between 0 and 5.</param>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.#ctor(System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>
            Construct a <see cref="T:HdrHistogram.ShortHistogram"/> given the lowest and highest values to be tracked and a number of significant decimal digits.
            </summary>
            <param name="instanceId">An identifier for this instance.</param>
            <param name="lowestTrackableValue">The lowest value that can be tracked (distinguished from 0) by the histogram.
            Must be a positive integer that is &gt;= 1.
            May be internally rounded down to nearest power of 2.
            </param>
            <param name="highestTrackableValue">The highest value to be tracked by the histogram.
            Must be a positive integer that is &gt;= (2 * lowestTrackableValue).
            </param>
            <param name="numberOfSignificantValueDigits">
            The number of significant decimal digits to which the histogram will maintain value resolution and separation. 
            Must be a non-negative integer between 0 and 5.
            </param>
            <remarks>
            Providing a lowestTrackableValue is useful in situations where the units used for the histogram's values are much 
            smaller that the minimal accuracy required.
            For example when tracking time values stated in ticks (100 nanoseconds), where the minimal accuracy required is a
            microsecond, the proper value for lowestTrackableValue would be 10.
            </remarks>
        </member>
        <member name="P:HdrHistogram.ShortHistogram.TotalCount">
            <summary>
            Gets the total number of recorded values.
            </summary>
        </member>
        <member name="P:HdrHistogram.ShortHistogram.WordSizeInBytes">
            <summary>
            Returns the word size of this implementation
            </summary>
        </member>
        <member name="P:HdrHistogram.ShortHistogram.MaxAllowableCount">
            <summary>
            The maximum value a count can be for any given bucket.
            </summary>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.Copy">
            <summary>
            Create a copy of this histogram, complete with data and everything.
            </summary>
            <returns>A distinct copy of this histogram.</returns>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.GetCountAtIndex(System.Int32)">
            <summary>
            Gets the number of recorded values at a given index.
            </summary>
            <param name="index">The index to get the count for</param>
            <returns>The number of recorded values at the given index.</returns>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.SetCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Sets the count at the given index.
            </summary>
            <param name="index">The index to be set</param>
            <param name="value">The value to set</param>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.IncrementCountAtIndex(System.Int32)">
            <summary>
            Increments the count at the given index. Will also increment the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/>.
            </summary>
            <param name="index">The index to increment the count at.</param>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.AddToCountAtIndex(System.Int32,System.Int64)">
            <summary>
            Adds the specified amount to the count of the provided index. Also increments the <see cref="P:HdrHistogram.HistogramBase.TotalCount"/> by the same amount.
            </summary>
            <param name="index">The index to increment.</param>
            <param name="addend">The amount to increment by.</param>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.ClearCounts">
            <summary>
            Clears the counts of this implementation.
            </summary>
        </member>
        <member name="M:HdrHistogram.ShortHistogram.CopyCountsInto(System.Int64[])">
            <summary>
            Copies the internal counts array into the supplied array.
            </summary>
            <param name="target">The array to write each count value into.</param>
        </member>
        <member name="T:HdrHistogram.TimeStamp">
            <summary>
            Helper methods to get time periods based in system stopwatch units.
            </summary>
        </member>
        <member name="M:HdrHistogram.TimeStamp.Seconds(System.Int64)">
            <summary>
            Return a <see cref="T:System.Int64"/> representing the number system timer ticks that occur over the provided number of seconds.
            </summary>
            <param name="seconds">A number seconds to represent.</param>
            <returns>The number of system timer ticks that represent the <paramref name="seconds"/>.</returns>
        </member>
        <member name="M:HdrHistogram.TimeStamp.Minutes(System.Int64)">
            <summary>
            Return a <see cref="T:System.Int64"/> representing the number system timer ticks that occur over the provided number of minutes.
            </summary>
            <param name="minutes">A number minutes to represent.</param>
            <returns>The number of system timer ticks that represent the <paramref name="minutes"/>.</returns>
        </member>
        <member name="M:HdrHistogram.TimeStamp.Hours(System.Int32)">
            <summary>
            Return a <see cref="T:System.Int64"/> representing the number system timer ticks that occur over the provided number of hours.
            </summary>
            <param name="hours">A number hours to represent.</param>
            <returns>The number of system timer ticks that represent the <paramref name="hours"/>.</returns>
        </member>
        <member name="T:HdrHistogram.Utilities.ArrayExtensions">
            <summary>
            Extension methods for Arrays.
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.ArrayExtensions.IsSequenceEqual``1(``0[],``0[])">
            <summary>
            Checks if the two arrays have the same items in the same order.
            </summary>
            <typeparam name="T">The type of the items in the arrays.</typeparam>
            <param name="source">The source array to check.</param>
            <param name="other">The other array to check against.</param>
            <returns>Returns <c>true</c> if the arrays are of the same length and each item by index is equal, else <c>false</c>.</returns>
        </member>
        <member name="T:HdrHistogram.Utilities.AtomicIntArray">
            <summary>
            This is a basic implementation/port, of just the methods that are required internally.
            </summary>
        </member>
        <member name="T:HdrHistogram.Utilities.AtomicLongArray">
            <summary>
            This is a basic implementation/port, of just the methods that are required internally.
            </summary>
        </member>
        <member name="T:HdrHistogram.Utilities.Bitwise">
            <summary>
            Exposes optimised methods to get Leading Zero Count.
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.Bitwise.NumberOfLeadingZeros(System.Int64)">
            <summary>
            Returns the Leading Zero Count (lzc) of the <paramref name="value"/> for its binary representation.
            </summary>
            <param name="value">The value to find the number of leading zeros</param>
            <returns>The number of leading zeros.</returns>
        </member>
        <member name="T:HdrHistogram.Utilities.ByteBuffer">
            <summary>
            A byte buffer that tracks position and allows reads and writes of 32 and 64 bit integer values.
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Allocate(System.Int32)">
            <summary>
            Creates a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> with a specified capacity in bytes.
            </summary>
            <param name="bufferCapacity">The capacity of the buffer in bytes</param>
            <returns>A newly created <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Allocate(System.Byte[])">
            <summary>
            Creates a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> loaded with the provided byte array.
            </summary>
            <param name="source">The source byte array to load the buffer with.</param>
            <returns>A newly created <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.</returns>
        </member>
        <member name="P:HdrHistogram.Utilities.ByteBuffer.Position">
            <summary>
            The buffer's current position in the underlying byte array
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Capacity">
            <summary>
            Returns the capacity of the <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>
            </summary>
            <returns>The length of the internal byte array.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Remaining">
            <summary>
            The remaining capacity.
            </summary>
            <returns>The number of bytes between the current position and the underlying byte array length.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.ReadFrom(System.IO.Stream,System.Int32)">
            <summary>
            Reads from the provided <see cref="T:System.IO.Stream"/>, into the buffer.
            </summary>
            <param name="source">The source stream to read from.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The number of bytes read.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Get">
            <summary>
            Gets the current byte and advances the position by one.
            </summary>
            <returns>The byte at the current position.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.GetShort">
            <summary>
            Gets the 16 bit integer (<seealso cref="T:System.Int16"/>) at the current position, and then advances by two.
            </summary>
            <returns>The value of the <see cref="T:System.Int16"/> at the current position.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.GetInt">
            <summary>
            Gets the 32 bit integer (<seealso cref="T:System.Int32"/>) at the current position, and then advances by four.
            </summary>
            <returns>The value of the <see cref="T:System.Int32"/> at the current position.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.GetLong">
            <summary>
            Gets the 64 bit integer (<seealso cref="T:System.Int64"/>) at the current position, and then advances by eight.
            </summary>
            <returns>The value of the <see cref="T:System.Int64"/> at the current position.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.GetDouble">
            <summary>
            Gets the double floating point number (<seealso cref="T:System.Double"/>) at the current position, and then advances by eight.
            </summary>
            <returns>The value of the <see cref="T:System.Double"/> at the current position.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Int64BitsToDouble(System.Int64)">
            <summary>
            Converts the specified 64-bit signed integer to a double-precision 
            floating point number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A double-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.ToInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit signed integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.CheckedFromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the arguments for validity before calling FromBytes
            (which can therefore assume the arguments are valid).
            </summary>
            <param name="value">The bytes to convert after checking</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.CheckByteArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the given argument for validity.
            </summary>
            <param name="value">The byte array passed in</param>
            <param name="startIndex">The start index passed in</param>
            <param name="bytesRequired">The number of bytes required</param>
            <exception cref="T:System.ArgumentNullException">value is a null reference</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            startIndex is less than zero or greater than the length of value minus bytesRequired.
            </exception>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.Put(System.Byte)">
            <summary>
            Writes a byte value to the current position, and advances the position by one.
            </summary>
            <param name="value">The byte value to write.</param>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.PutInt(System.Int32)">
            <summary>
            Sets the bytes at the current position to the value of the passed value, and advances the position.
            </summary>
            <param name="value">The value to set the current position to.</param>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.PutInt(System.Int32,System.Int32)">
            <summary>
            Sets the bytes at the provided position to the value of the passed value, and does not advance the position.
            </summary>
            <param name="index">The position to set the value at.</param>
            <param name="value">The value to set.</param>
            <remarks>
            This can be useful for writing a value into an earlier placeholder e.g. a header property for storing the body length.
            </remarks>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.PutLong(System.Int64)">
            <summary>
            Sets the bytes at the current position to the value of the passed value, and advances the position.
            </summary>
            <param name="value">The value to set the current position to.</param>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.PutDouble(System.Double)">
            <summary>
            Sets the bytes at the current position to the value of the passed value, and advances the position.
            </summary>
            <param name="value">The value to set the current position to.</param>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBuffer.ToArray">
            <summary>
            Gets a copy of the internal byte array.
            </summary>
            <returns>The a copy of the internal byte array.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.ByteBufferExtensions.CompressedCopy(HdrHistogram.Utilities.ByteBuffer,HdrHistogram.Utilities.ByteBuffer,System.Int32)">
            <summary>
            Copies compressed contents from <paramref name="source"/> into the <paramref name="target"/> from the <paramref name="targetOffset"/>
            </summary>
            <param name="target">The <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> that will be written to.</param>
            <param name="source">The source <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> to read the data from.</param>
            <param name="targetOffset">The <paramref name="target"/> buffer's offset to start writing from.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.TypeHelper.GetConstructor(System.Type,System.Type[])">
            <summary>
            Gets the constructor that matches the parameter array.
            Searches for a public instance constructor whose parameters match the types in the specified array.
            </summary>
            <param name="type">The type to search.</param>
            <param name="ctorArgTypes">An array of <see cref="T:System.Type"/> objects representing the number, order and type of the parameters for the desired constructor.</param>
            <returns>The <see cref="T:System.Reflection.ConstructorInfo"/> if a match is found, else <c>null</c>.</returns>
            <remarks>
            In most versions of .NET this method is provided directly on <see cref="T:System.Type"/>, however for full support, we provide this ourselves.
            </remarks>
        </member>
        <member name="T:HdrHistogram.Utilities.UnixTimeExtensions">
            <summary>
            Provides helper methods for working with times in Unix Epoch convention.
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.UnixTimeExtensions.SecondsSinceUnixEpoch(System.DateTime)">
            <summary>
            Gets the seconds elapsed since the Unix Epoch (01-Jan-1970 UTC)
            </summary>
            <param name="source">The source time.</param>
            <returns>Returns the number whole and partial seconds elapsed since the Unix Epoch until the <paramref name="source"/> time.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="source"/> Kind is <see cref="F:System.DateTimeKind.Unspecified"/>.</exception>
        </member>
        <member name="M:HdrHistogram.Utilities.UnixTimeExtensions.MillisecondsSinceUnixEpoch(System.DateTime)">
            <summary>
            Gets the milliseconds elapsed since the Unix Epoch (01-Jan-1970 UTC)
            </summary>
            <param name="source">The source time.</param>
            <returns>Returns the number whole milliseconds elapsed since the Unix Epoch until the <paramref name="source"/> time.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the <paramref name="source"/> Kind is <see cref="F:System.DateTimeKind.Unspecified"/>.</exception>
        </member>
        <member name="M:HdrHistogram.Utilities.UnixTimeExtensions.ToDateFromSecondsSinceEpoch(System.Double)">
            <summary>
            Returns the date and time specified by the seconds since the Unix Epoch
            </summary>
            <param name="secondsSinceUnixEpoch">The seconds since epoch</param>
            <returns>A DateTime value in UTC kind.</returns>
        </member>
        <member name="M:HdrHistogram.Utilities.UnixTimeExtensions.ToDateFromMillisecondsSinceEpoch(System.Int64)">
            <summary>
            Returns the date and time specified by the milliseconds since the Unix Epoch
            </summary>
            <param name="millisecondsSinceUnixEpoch">The milliseconds since epoch</param>
            <returns>A DateTime value in UTC kind.</returns>
        </member>
        <member name="T:HdrHistogram.Utilities.WriterReaderPhaser">
            <summary>
            <see cref="T:HdrHistogram.Utilities.WriterReaderPhaser"/> instances provide an asymmetric means for synchronizing the execution of wait-free "writer" critical sections against a "reader phase flip" that needs to make sure no writer critical sections that were active at the beginning of the flip are still active after the flip is done.
            Multiple writers and multiple readers are supported.
            </summary>
            <remarks>
            <para>
            While a<see cref="T:HdrHistogram.Utilities.WriterReaderPhaser"/> can be useful in multiple scenarios, a specific and common use case is that of safely managing "double buffered" data stream access.
            This style of access allows writers to proceed without being blocked, while readers gain access to stable and unchanging buffer samples
            </para>
            
            <blockquote>
            NOTE: <see cref="T:HdrHistogram.Utilities.WriterReaderPhaser" /> writers are wait-free on architectures that support wait-free atomic increment operations.
            They remain lock-free (but not wait-free) on architectures that do not support wait-free atomic increment operations.
            </blockquote>
            <see cref="T:HdrHistogram.Utilities.WriterReaderPhaser"/> "writers" are wait free, "readers" block for other "readers", and "readers" are only blocked by "writers" whose critical was entered before the reader's <seealso cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> attempt.
            <para>
            When used to protect an actively recording data structure, the assumptions on how readers and writers act are:
            <ol>
            <li>There are two sets of data structures("active" and "inactive")</li>
            <li>Writing is done to the perceived active version(as perceived by the writer), and only within critical sections delineated by <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> and <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/>).</li>
            <li> Only readers switch the perceived roles of the active and inactive data structures.
            They do so only while under <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/>, and only before calling <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/>.</li>
            </ol>
            When the above assumptions are met, <see cref="T:HdrHistogram.Utilities.WriterReaderPhaser"/> guarantees that the inactive data structures are not being modified by any writers while being read while under <seealso cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/> protection after a <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> operation.
            </para>
            </remarks>
        </member>
        <member name="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter">
            <summary>
            Indicate entry to a critical section containing a write operation.
            </summary>
            <returns>
            an (opaque) value associated with the critical section entry, 
            which MUST be provided to the matching <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/> call.
            </returns>
            <remarks>
            <para>
            This call is wait-free on architectures that support wait free atomic increment operations,
            and is lock-free on architectures that do not.
            </para>
            <para>
            <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> must be matched with a subsequent <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/>
            in order for CriticalSectionPhaser synchronization to function properly.
            </para>
            <para>
            The <seealso cref="T:System.IDisposable"/> pattern could have been used but was not due to the high allocation count it would have incurred.
            </para>
            </remarks>
        </member>
        <member name="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)">
            <summary>
            Indicate exit from a critical section containing a write operation.
            </summary>
            <param name="criticalValueAtEnter">the opaque value (token) returned from the matching <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> call.</param>
            <remarks>
            This call is wait-free on architectures that support wait free atomic increment operations, and is lock-free on architectures that do not.
            <para>
            <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/> must be matched with a preceding  <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> call, and must be provided with the matching <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> call's return value, in order for CriticalSectionPhaser synchronization to function properly.
            </para>
            </remarks>
        </member>
        <member name="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock">
            <summary>
            Enter to a critical section containing a read operation (mutually excludes against other <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/> calls).
            <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/> DOES NOT provide synchronization against <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> calls.
            Use <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> to synchronize reads against writers.
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderUnlock">
            <summary>
            Exit from a critical section containing a read operation(relinquishes mutual exclusion against other <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/> calls).
            </summary>
        </member>
        <member name="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)">
            <summary>
            Flip a phase in the <see cref="T:HdrHistogram.Utilities.WriterReaderPhaser"/> instance, <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)"/> can only be called while holding the <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/>.
            </summary>
            <param name="yieldPeriod">The amount of time to sleep in each yield if yield loop is needed.</param>
            <remarks>
            <seealso cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)"/> will return only after all writer critical sections (protected by <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> and <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/> that may have been in flight when the <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)"/> call were made had completed.
            <para>
            No actual writer critical section activity is required for <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)"/> to succeed.
            </para>
            <para>
            However, <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)"/> is lock-free with respect to calls to <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> and <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/>. 
            It may spin-wait for for active writer critical section code to complete.
            </para>
            </remarks>
        </member>
        <member name="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase">
            <summary>
            Flip a phase in the <see cref="T:HdrHistogram.Utilities.WriterReaderPhaser"/> instance, <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> can only be called while holding the <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.ReaderLock"/>.
            </summary>
            <remarks>
            <seealso cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> will return only after all writer critical sections (protected by <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> and <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/> that may have been in flight when the <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase(System.TimeSpan)"/> call were made had completed.
            <para>
            No actual writer critical section activity is required for <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> to succeed.
            </para>
            <para>
            However, <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.FlipPhase"/> is lock-free with respect to calls to <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionEnter"/> and <see cref="M:HdrHistogram.Utilities.WriterReaderPhaser.WriterCriticalSectionExit(System.Int64)"/>. 
            It may spin-wait for for active writer critical section code to complete.
            </para>
            </remarks>
        </member>
        <member name="T:HdrHistogram.ZigZagEncoding">
            <summary>
            Exposes methods to write values to a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/> with ZigZag LEB128-64b9B-variant encoding.
            (Little Endian Base128 Encoding, 64bit value store as a maximum of 9Bytes)
            </summary>
            <remarks>
            <p>
            This class provides encoding and decoding methods for writing and reading ZigZag-encoded LEB128-64b9B-variant(Little Endian Base 128) values to/from a <see cref="T:HdrHistogram.Utilities.ByteBuffer"/>.
            LEB128's variable length encoding provides for using a smaller number of bytes for smaller values, and the use of ZigZag encoding allows small(closer to zero) negative values to use fewer bytes.
            Details on both LEB128 and ZigZag can be readily found elsewhere.
            </p>
            <p>
            The LEB128-64b9B-variant encoding used here diverges from the "original" LEB128 as it extends to 64 bit values.
            In the original LEB128, a 64 bit value can take up to 10 bytes in the stream, where this variant's encoding of a 64 bit values will max out at 9 bytes.
            As such, this encoder/decoder should NOT be used for encoding or decoding "standard" LEB128 formats (e.g.Google Protocol Buffers).
            </p>
            <p>
            ZigZag Encoding explained here - https://gist.github.com/mfuerstenau/ba870a29e16536fdbaba
            LEB128 explained here - https://en.wikipedia.org/wiki/LEB128
            </p>
            </remarks>
        </member>
        <member name="M:HdrHistogram.ZigZagEncoding.PutLong(HdrHistogram.Utilities.ByteBuffer,System.Int64)">
            <summary>
            Writes a 64 bit integer (<see cref="T:System.Int64"/>) value to the given buffer in LEB128-64b9B-variant ZigZag encoded format.
            </summary>
            <param name="buffer">The buffer to write to.</param>
            <param name="value">The value to write to the buffer.</param>
        </member>
        <member name="M:HdrHistogram.ZigZagEncoding.GetLong(HdrHistogram.Utilities.ByteBuffer)">
            <summary>
            Reads an LEB128-64b9B ZigZag encoded 64 bit integer (<see cref="T:System.Int64"/>) value from the given buffer.
            </summary>
            <param name="buffer">The buffer to read from.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="T:IsqlListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:sqlParser"/>.
            </summary>
        </member>
        <member name="M:IsqlListener.EnterProgram(sqlParser.ProgramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitProgram(sqlParser.ProgramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSql_query(sqlParser.Sql_queryContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.sql_query"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSql_query(sqlParser.Sql_queryContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.sql_query"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSelect_clause(sqlParser.Select_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSelect_clause(sqlParser.Select_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterTop_spec(sqlParser.Top_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.top_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitTop_spec(sqlParser.Top_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.top_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSelection(sqlParser.SelectionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.selection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSelection(sqlParser.SelectionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.selection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSelect_star_spec(sqlParser.Select_star_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_star_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSelect_star_spec(sqlParser.Select_star_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_star_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSelect_value_spec(sqlParser.Select_value_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_value_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSelect_value_spec(sqlParser.Select_value_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_value_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSelect_list_spec(sqlParser.Select_list_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_list_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSelect_list_spec(sqlParser.Select_list_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_list_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSelect_item(sqlParser.Select_itemContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_item"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSelect_item(sqlParser.Select_itemContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_item"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterFrom_clause(sqlParser.From_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.from_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitFrom_clause(sqlParser.From_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.from_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterJoinCollectionExpression(sqlParser.JoinCollectionExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>JoinCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitJoinCollectionExpression(sqlParser.JoinCollectionExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>JoinCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterAliasedCollectionExpression(sqlParser.AliasedCollectionExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>AliasedCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitAliasedCollectionExpression(sqlParser.AliasedCollectionExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>AliasedCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterArrayIteratorCollectionExpression(sqlParser.ArrayIteratorCollectionExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ArrayIteratorCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitArrayIteratorCollectionExpression(sqlParser.ArrayIteratorCollectionExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ArrayIteratorCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterInputPathCollection(sqlParser.InputPathCollectionContext)">
            <summary>
            Enter a parse tree produced by the <c>InputPathCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitInputPathCollection(sqlParser.InputPathCollectionContext)">
            <summary>
            Exit a parse tree produced by the <c>InputPathCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSubqueryCollection(sqlParser.SubqueryCollectionContext)">
            <summary>
            Enter a parse tree produced by the <c>SubqueryCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSubqueryCollection(sqlParser.SubqueryCollectionContext)">
            <summary>
            Exit a parse tree produced by the <c>SubqueryCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterStringPathExpression(sqlParser.StringPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>StringPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitStringPathExpression(sqlParser.StringPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>StringPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterEpsilonPathExpression(sqlParser.EpsilonPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>EpsilonPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitEpsilonPathExpression(sqlParser.EpsilonPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>EpsilonPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterIdentifierPathExpression(sqlParser.IdentifierPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>IdentifierPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitIdentifierPathExpression(sqlParser.IdentifierPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>IdentifierPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterNumberPathExpression(sqlParser.NumberPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>NumberPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitNumberPathExpression(sqlParser.NumberPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>NumberPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterWhere_clause(sqlParser.Where_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.where_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitWhere_clause(sqlParser.Where_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.where_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterGroup_by_clause(sqlParser.Group_by_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.group_by_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitGroup_by_clause(sqlParser.Group_by_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.group_by_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterOrder_by_clause(sqlParser.Order_by_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.order_by_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitOrder_by_clause(sqlParser.Order_by_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.order_by_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterOrder_by_items(sqlParser.Order_by_itemsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.order_by_items"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitOrder_by_items(sqlParser.Order_by_itemsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.order_by_items"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterOrder_by_item(sqlParser.Order_by_itemContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.order_by_item"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitOrder_by_item(sqlParser.Order_by_itemContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.order_by_item"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSort_order(sqlParser.Sort_orderContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.sort_order"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSort_order(sqlParser.Sort_orderContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.sort_order"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterOffset_limit_clause(sqlParser.Offset_limit_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.offset_limit_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitOffset_limit_clause(sqlParser.Offset_limit_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.offset_limit_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterOffset_count(sqlParser.Offset_countContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.offset_count"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitOffset_count(sqlParser.Offset_countContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.offset_count"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterLimit_count(sqlParser.Limit_countContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.limit_count"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitLimit_count(sqlParser.Limit_countContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.limit_count"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterLogicalScalarExpression(sqlParser.LogicalScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>LogicalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitLogicalScalarExpression(sqlParser.LogicalScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>LogicalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterConditionalScalarExpression(sqlParser.ConditionalScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ConditionalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitConditionalScalarExpression(sqlParser.ConditionalScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ConditionalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterCoalesceScalarExpression(sqlParser.CoalesceScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>CoalesceScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitCoalesceScalarExpression(sqlParser.CoalesceScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>CoalesceScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterBetweenScalarExpression(sqlParser.BetweenScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>BetweenScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitBetweenScalarExpression(sqlParser.BetweenScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>BetweenScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterLogical_scalar_expression(sqlParser.Logical_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.logical_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitLogical_scalar_expression(sqlParser.Logical_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.logical_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterIn_scalar_expression(sqlParser.In_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.in_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitIn_scalar_expression(sqlParser.In_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.in_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterLike_scalar_expression(sqlParser.Like_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.like_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitLike_scalar_expression(sqlParser.Like_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.like_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterEscape_expression(sqlParser.Escape_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.escape_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitEscape_expression(sqlParser.Escape_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.escape_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterBinary_scalar_expression(sqlParser.Binary_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.binary_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitBinary_scalar_expression(sqlParser.Binary_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.binary_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterMultiplicative_operator(sqlParser.Multiplicative_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.multiplicative_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitMultiplicative_operator(sqlParser.Multiplicative_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.multiplicative_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterAdditive_operator(sqlParser.Additive_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.additive_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitAdditive_operator(sqlParser.Additive_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.additive_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterRelational_operator(sqlParser.Relational_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.relational_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitRelational_operator(sqlParser.Relational_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.relational_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterEquality_operator(sqlParser.Equality_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.equality_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitEquality_operator(sqlParser.Equality_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.equality_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterBitwise_and_operator(sqlParser.Bitwise_and_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.bitwise_and_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitBitwise_and_operator(sqlParser.Bitwise_and_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.bitwise_and_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterBitwise_exclusive_or_operator(sqlParser.Bitwise_exclusive_or_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.bitwise_exclusive_or_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitBitwise_exclusive_or_operator(sqlParser.Bitwise_exclusive_or_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.bitwise_exclusive_or_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterBitwise_inclusive_or_operator(sqlParser.Bitwise_inclusive_or_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.bitwise_inclusive_or_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitBitwise_inclusive_or_operator(sqlParser.Bitwise_inclusive_or_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.bitwise_inclusive_or_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterString_concat_operator(sqlParser.String_concat_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.string_concat_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitString_concat_operator(sqlParser.String_concat_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.string_concat_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterUnary_scalar_expression(sqlParser.Unary_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.unary_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitUnary_scalar_expression(sqlParser.Unary_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.unary_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterUnary_operator(sqlParser.Unary_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.unary_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitUnary_operator(sqlParser.Unary_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.unary_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterSubqueryScalarExpression(sqlParser.SubqueryScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>SubqueryScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitSubqueryScalarExpression(sqlParser.SubqueryScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>SubqueryScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterPropertyRefScalarExpressionBase(sqlParser.PropertyRefScalarExpressionBaseContext)">
            <summary>
            Enter a parse tree produced by the <c>PropertyRefScalarExpressionBase</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitPropertyRefScalarExpressionBase(sqlParser.PropertyRefScalarExpressionBaseContext)">
            <summary>
            Exit a parse tree produced by the <c>PropertyRefScalarExpressionBase</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterFunctionCallScalarExpression(sqlParser.FunctionCallScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionCallScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitFunctionCallScalarExpression(sqlParser.FunctionCallScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionCallScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterLiteralScalarExpression(sqlParser.LiteralScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>LiteralScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitLiteralScalarExpression(sqlParser.LiteralScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>LiteralScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterObjectCreateScalarExpression(sqlParser.ObjectCreateScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ObjectCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitObjectCreateScalarExpression(sqlParser.ObjectCreateScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ObjectCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterParenthesizedScalarExperession(sqlParser.ParenthesizedScalarExperessionContext)">
            <summary>
            Enter a parse tree produced by the <c>ParenthesizedScalarExperession</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitParenthesizedScalarExperession(sqlParser.ParenthesizedScalarExperessionContext)">
            <summary>
            Exit a parse tree produced by the <c>ParenthesizedScalarExperession</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterParameterRefScalarExpression(sqlParser.ParameterRefScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ParameterRefScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitParameterRefScalarExpression(sqlParser.ParameterRefScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ParameterRefScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterArrayCreateScalarExpression(sqlParser.ArrayCreateScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ArrayCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitArrayCreateScalarExpression(sqlParser.ArrayCreateScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ArrayCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterExistsScalarExpression(sqlParser.ExistsScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ExistsScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitExistsScalarExpression(sqlParser.ExistsScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ExistsScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterArrayScalarExpression(sqlParser.ArrayScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ArrayScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitArrayScalarExpression(sqlParser.ArrayScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ArrayScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterMemberIndexerScalarExpression(sqlParser.MemberIndexerScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>MemberIndexerScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitMemberIndexerScalarExpression(sqlParser.MemberIndexerScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>MemberIndexerScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterPropertyRefScalarExpressionRecursive(sqlParser.PropertyRefScalarExpressionRecursiveContext)">
            <summary>
            Enter a parse tree produced by the <c>PropertyRefScalarExpressionRecursive</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitPropertyRefScalarExpressionRecursive(sqlParser.PropertyRefScalarExpressionRecursiveContext)">
            <summary>
            Exit a parse tree produced by the <c>PropertyRefScalarExpressionRecursive</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterScalar_expression_list(sqlParser.Scalar_expression_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.scalar_expression_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitScalar_expression_list(sqlParser.Scalar_expression_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.scalar_expression_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterObject_property_list(sqlParser.Object_property_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.object_property_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitObject_property_list(sqlParser.Object_property_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.object_property_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterObject_property(sqlParser.Object_propertyContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.object_property"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitObject_property(sqlParser.Object_propertyContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.object_property"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.EnterLiteral(sqlParser.LiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.literal"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:IsqlListener.ExitLiteral(sqlParser.LiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.literal"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:IsqlVisitor`1">
            <summary>
            This interface defines a complete generic visitor for a parse tree produced
            by <see cref="T:sqlParser"/>.
            </summary>
            <typeparam name="Result">The return type of the visit operation.</typeparam>
        </member>
        <member name="M:IsqlVisitor`1.VisitProgram(sqlParser.ProgramContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.program"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSql_query(sqlParser.Sql_queryContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.sql_query"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSelect_clause(sqlParser.Select_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitTop_spec(sqlParser.Top_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.top_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSelection(sqlParser.SelectionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.selection"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSelect_star_spec(sqlParser.Select_star_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_star_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSelect_value_spec(sqlParser.Select_value_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_value_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSelect_list_spec(sqlParser.Select_list_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_list_spec"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSelect_item(sqlParser.Select_itemContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_item"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitFrom_clause(sqlParser.From_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.from_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitJoinCollectionExpression(sqlParser.JoinCollectionExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>JoinCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitAliasedCollectionExpression(sqlParser.AliasedCollectionExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>AliasedCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitArrayIteratorCollectionExpression(sqlParser.ArrayIteratorCollectionExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ArrayIteratorCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitInputPathCollection(sqlParser.InputPathCollectionContext)">
            <summary>
            Visit a parse tree produced by the <c>InputPathCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSubqueryCollection(sqlParser.SubqueryCollectionContext)">
            <summary>
            Visit a parse tree produced by the <c>SubqueryCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitStringPathExpression(sqlParser.StringPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>StringPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitEpsilonPathExpression(sqlParser.EpsilonPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>EpsilonPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitIdentifierPathExpression(sqlParser.IdentifierPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>IdentifierPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitNumberPathExpression(sqlParser.NumberPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>NumberPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitWhere_clause(sqlParser.Where_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.where_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitGroup_by_clause(sqlParser.Group_by_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.group_by_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitOrder_by_clause(sqlParser.Order_by_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.order_by_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitOrder_by_items(sqlParser.Order_by_itemsContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.order_by_items"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitOrder_by_item(sqlParser.Order_by_itemContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.order_by_item"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSort_order(sqlParser.Sort_orderContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.sort_order"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitOffset_limit_clause(sqlParser.Offset_limit_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.offset_limit_clause"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitOffset_count(sqlParser.Offset_countContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.offset_count"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitLimit_count(sqlParser.Limit_countContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.limit_count"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitLogicalScalarExpression(sqlParser.LogicalScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>LogicalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitConditionalScalarExpression(sqlParser.ConditionalScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ConditionalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitCoalesceScalarExpression(sqlParser.CoalesceScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>CoalesceScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitBetweenScalarExpression(sqlParser.BetweenScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>BetweenScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitLogical_scalar_expression(sqlParser.Logical_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.logical_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitIn_scalar_expression(sqlParser.In_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.in_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitLike_scalar_expression(sqlParser.Like_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.like_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitEscape_expression(sqlParser.Escape_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.escape_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitBinary_scalar_expression(sqlParser.Binary_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.binary_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitMultiplicative_operator(sqlParser.Multiplicative_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.multiplicative_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitAdditive_operator(sqlParser.Additive_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.additive_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitRelational_operator(sqlParser.Relational_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.relational_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitEquality_operator(sqlParser.Equality_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.equality_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitBitwise_and_operator(sqlParser.Bitwise_and_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.bitwise_and_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitBitwise_exclusive_or_operator(sqlParser.Bitwise_exclusive_or_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.bitwise_exclusive_or_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitBitwise_inclusive_or_operator(sqlParser.Bitwise_inclusive_or_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.bitwise_inclusive_or_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitString_concat_operator(sqlParser.String_concat_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.string_concat_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitUnary_scalar_expression(sqlParser.Unary_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.unary_scalar_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitUnary_operator(sqlParser.Unary_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.unary_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitSubqueryScalarExpression(sqlParser.SubqueryScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>SubqueryScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitPropertyRefScalarExpressionBase(sqlParser.PropertyRefScalarExpressionBaseContext)">
            <summary>
            Visit a parse tree produced by the <c>PropertyRefScalarExpressionBase</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitFunctionCallScalarExpression(sqlParser.FunctionCallScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>FunctionCallScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitLiteralScalarExpression(sqlParser.LiteralScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>LiteralScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitObjectCreateScalarExpression(sqlParser.ObjectCreateScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ObjectCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitParenthesizedScalarExperession(sqlParser.ParenthesizedScalarExperessionContext)">
            <summary>
            Visit a parse tree produced by the <c>ParenthesizedScalarExperession</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitParameterRefScalarExpression(sqlParser.ParameterRefScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ParameterRefScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitArrayCreateScalarExpression(sqlParser.ArrayCreateScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ArrayCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitExistsScalarExpression(sqlParser.ExistsScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ExistsScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitArrayScalarExpression(sqlParser.ArrayScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ArrayScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitMemberIndexerScalarExpression(sqlParser.MemberIndexerScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>MemberIndexerScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitPropertyRefScalarExpressionRecursive(sqlParser.PropertyRefScalarExpressionRecursiveContext)">
            <summary>
            Visit a parse tree produced by the <c>PropertyRefScalarExpressionRecursive</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitScalar_expression_list(sqlParser.Scalar_expression_listContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.scalar_expression_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitObject_property_list(sqlParser.Object_property_listContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.object_property_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitObject_property(sqlParser.Object_propertyContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.object_property"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:IsqlVisitor`1.VisitLiteral(sqlParser.LiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.literal"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="T:sqlBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:IsqlListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:sqlBaseListener.EnterProgram(sqlParser.ProgramContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.program"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitProgram(sqlParser.ProgramContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.program"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSql_query(sqlParser.Sql_queryContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.sql_query"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSql_query(sqlParser.Sql_queryContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.sql_query"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSelect_clause(sqlParser.Select_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSelect_clause(sqlParser.Select_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterTop_spec(sqlParser.Top_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.top_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitTop_spec(sqlParser.Top_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.top_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSelection(sqlParser.SelectionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.selection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSelection(sqlParser.SelectionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.selection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSelect_star_spec(sqlParser.Select_star_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_star_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSelect_star_spec(sqlParser.Select_star_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_star_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSelect_value_spec(sqlParser.Select_value_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_value_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSelect_value_spec(sqlParser.Select_value_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_value_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSelect_list_spec(sqlParser.Select_list_specContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_list_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSelect_list_spec(sqlParser.Select_list_specContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_list_spec"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSelect_item(sqlParser.Select_itemContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.select_item"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSelect_item(sqlParser.Select_itemContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.select_item"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterFrom_clause(sqlParser.From_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.from_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitFrom_clause(sqlParser.From_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.from_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterJoinCollectionExpression(sqlParser.JoinCollectionExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>JoinCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitJoinCollectionExpression(sqlParser.JoinCollectionExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>JoinCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterAliasedCollectionExpression(sqlParser.AliasedCollectionExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>AliasedCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitAliasedCollectionExpression(sqlParser.AliasedCollectionExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>AliasedCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterArrayIteratorCollectionExpression(sqlParser.ArrayIteratorCollectionExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ArrayIteratorCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitArrayIteratorCollectionExpression(sqlParser.ArrayIteratorCollectionExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ArrayIteratorCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterInputPathCollection(sqlParser.InputPathCollectionContext)">
            <summary>
            Enter a parse tree produced by the <c>InputPathCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitInputPathCollection(sqlParser.InputPathCollectionContext)">
            <summary>
            Exit a parse tree produced by the <c>InputPathCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSubqueryCollection(sqlParser.SubqueryCollectionContext)">
            <summary>
            Enter a parse tree produced by the <c>SubqueryCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSubqueryCollection(sqlParser.SubqueryCollectionContext)">
            <summary>
            Exit a parse tree produced by the <c>SubqueryCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterStringPathExpression(sqlParser.StringPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>StringPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitStringPathExpression(sqlParser.StringPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>StringPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterEpsilonPathExpression(sqlParser.EpsilonPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>EpsilonPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitEpsilonPathExpression(sqlParser.EpsilonPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>EpsilonPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterIdentifierPathExpression(sqlParser.IdentifierPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>IdentifierPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitIdentifierPathExpression(sqlParser.IdentifierPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>IdentifierPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterNumberPathExpression(sqlParser.NumberPathExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>NumberPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitNumberPathExpression(sqlParser.NumberPathExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>NumberPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterWhere_clause(sqlParser.Where_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.where_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitWhere_clause(sqlParser.Where_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.where_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterGroup_by_clause(sqlParser.Group_by_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.group_by_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitGroup_by_clause(sqlParser.Group_by_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.group_by_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterOrder_by_clause(sqlParser.Order_by_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.order_by_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitOrder_by_clause(sqlParser.Order_by_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.order_by_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterOrder_by_items(sqlParser.Order_by_itemsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.order_by_items"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitOrder_by_items(sqlParser.Order_by_itemsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.order_by_items"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterOrder_by_item(sqlParser.Order_by_itemContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.order_by_item"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitOrder_by_item(sqlParser.Order_by_itemContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.order_by_item"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSort_order(sqlParser.Sort_orderContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.sort_order"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSort_order(sqlParser.Sort_orderContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.sort_order"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterOffset_limit_clause(sqlParser.Offset_limit_clauseContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.offset_limit_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitOffset_limit_clause(sqlParser.Offset_limit_clauseContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.offset_limit_clause"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterOffset_count(sqlParser.Offset_countContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.offset_count"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitOffset_count(sqlParser.Offset_countContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.offset_count"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterLimit_count(sqlParser.Limit_countContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.limit_count"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitLimit_count(sqlParser.Limit_countContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.limit_count"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterLogicalScalarExpression(sqlParser.LogicalScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>LogicalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitLogicalScalarExpression(sqlParser.LogicalScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>LogicalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterConditionalScalarExpression(sqlParser.ConditionalScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ConditionalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitConditionalScalarExpression(sqlParser.ConditionalScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ConditionalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterCoalesceScalarExpression(sqlParser.CoalesceScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>CoalesceScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitCoalesceScalarExpression(sqlParser.CoalesceScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>CoalesceScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterBetweenScalarExpression(sqlParser.BetweenScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>BetweenScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitBetweenScalarExpression(sqlParser.BetweenScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>BetweenScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterLogical_scalar_expression(sqlParser.Logical_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.logical_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitLogical_scalar_expression(sqlParser.Logical_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.logical_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterIn_scalar_expression(sqlParser.In_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.in_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitIn_scalar_expression(sqlParser.In_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.in_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterLike_scalar_expression(sqlParser.Like_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.like_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitLike_scalar_expression(sqlParser.Like_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.like_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterEscape_expression(sqlParser.Escape_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.escape_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitEscape_expression(sqlParser.Escape_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.escape_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterBinary_scalar_expression(sqlParser.Binary_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.binary_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitBinary_scalar_expression(sqlParser.Binary_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.binary_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterMultiplicative_operator(sqlParser.Multiplicative_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.multiplicative_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitMultiplicative_operator(sqlParser.Multiplicative_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.multiplicative_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterAdditive_operator(sqlParser.Additive_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.additive_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitAdditive_operator(sqlParser.Additive_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.additive_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterRelational_operator(sqlParser.Relational_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.relational_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitRelational_operator(sqlParser.Relational_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.relational_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterEquality_operator(sqlParser.Equality_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.equality_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitEquality_operator(sqlParser.Equality_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.equality_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterBitwise_and_operator(sqlParser.Bitwise_and_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.bitwise_and_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitBitwise_and_operator(sqlParser.Bitwise_and_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.bitwise_and_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterBitwise_exclusive_or_operator(sqlParser.Bitwise_exclusive_or_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.bitwise_exclusive_or_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitBitwise_exclusive_or_operator(sqlParser.Bitwise_exclusive_or_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.bitwise_exclusive_or_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterBitwise_inclusive_or_operator(sqlParser.Bitwise_inclusive_or_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.bitwise_inclusive_or_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitBitwise_inclusive_or_operator(sqlParser.Bitwise_inclusive_or_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.bitwise_inclusive_or_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterString_concat_operator(sqlParser.String_concat_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.string_concat_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitString_concat_operator(sqlParser.String_concat_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.string_concat_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterUnary_scalar_expression(sqlParser.Unary_scalar_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.unary_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitUnary_scalar_expression(sqlParser.Unary_scalar_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.unary_scalar_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterUnary_operator(sqlParser.Unary_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.unary_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitUnary_operator(sqlParser.Unary_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.unary_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterSubqueryScalarExpression(sqlParser.SubqueryScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>SubqueryScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitSubqueryScalarExpression(sqlParser.SubqueryScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>SubqueryScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterPropertyRefScalarExpressionBase(sqlParser.PropertyRefScalarExpressionBaseContext)">
            <summary>
            Enter a parse tree produced by the <c>PropertyRefScalarExpressionBase</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitPropertyRefScalarExpressionBase(sqlParser.PropertyRefScalarExpressionBaseContext)">
            <summary>
            Exit a parse tree produced by the <c>PropertyRefScalarExpressionBase</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterFunctionCallScalarExpression(sqlParser.FunctionCallScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>FunctionCallScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitFunctionCallScalarExpression(sqlParser.FunctionCallScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>FunctionCallScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterLiteralScalarExpression(sqlParser.LiteralScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>LiteralScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitLiteralScalarExpression(sqlParser.LiteralScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>LiteralScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterObjectCreateScalarExpression(sqlParser.ObjectCreateScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ObjectCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitObjectCreateScalarExpression(sqlParser.ObjectCreateScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ObjectCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterParenthesizedScalarExperession(sqlParser.ParenthesizedScalarExperessionContext)">
            <summary>
            Enter a parse tree produced by the <c>ParenthesizedScalarExperession</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitParenthesizedScalarExperession(sqlParser.ParenthesizedScalarExperessionContext)">
            <summary>
            Exit a parse tree produced by the <c>ParenthesizedScalarExperession</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterParameterRefScalarExpression(sqlParser.ParameterRefScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ParameterRefScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitParameterRefScalarExpression(sqlParser.ParameterRefScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ParameterRefScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterArrayCreateScalarExpression(sqlParser.ArrayCreateScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ArrayCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitArrayCreateScalarExpression(sqlParser.ArrayCreateScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ArrayCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterExistsScalarExpression(sqlParser.ExistsScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ExistsScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitExistsScalarExpression(sqlParser.ExistsScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ExistsScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterArrayScalarExpression(sqlParser.ArrayScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ArrayScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitArrayScalarExpression(sqlParser.ArrayScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ArrayScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterMemberIndexerScalarExpression(sqlParser.MemberIndexerScalarExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>MemberIndexerScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitMemberIndexerScalarExpression(sqlParser.MemberIndexerScalarExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>MemberIndexerScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterPropertyRefScalarExpressionRecursive(sqlParser.PropertyRefScalarExpressionRecursiveContext)">
            <summary>
            Enter a parse tree produced by the <c>PropertyRefScalarExpressionRecursive</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitPropertyRefScalarExpressionRecursive(sqlParser.PropertyRefScalarExpressionRecursiveContext)">
            <summary>
            Exit a parse tree produced by the <c>PropertyRefScalarExpressionRecursive</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterScalar_expression_list(sqlParser.Scalar_expression_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.scalar_expression_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitScalar_expression_list(sqlParser.Scalar_expression_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.scalar_expression_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterObject_property_list(sqlParser.Object_property_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.object_property_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitObject_property_list(sqlParser.Object_property_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.object_property_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterObject_property(sqlParser.Object_propertyContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.object_property"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitObject_property(sqlParser.Object_propertyContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.object_property"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterLiteral(sqlParser.LiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:sqlParser.literal"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.ExitLiteral(sqlParser.LiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:sqlParser.literal"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:sqlBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:sqlBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:sqlBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:sqlBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:sqlBaseVisitor`1">
            <summary>
            This class provides an empty implementation of <see cref="T:IsqlVisitor`1"/>,
            which can be extended to create a visitor which only needs to handle a subset
            of the available methods.
            </summary>
            <typeparam name="Result">The return type of the visit operation.</typeparam>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitProgram(sqlParser.ProgramContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.program"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSql_query(sqlParser.Sql_queryContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.sql_query"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSelect_clause(sqlParser.Select_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_clause"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitTop_spec(sqlParser.Top_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.top_spec"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSelection(sqlParser.SelectionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.selection"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSelect_star_spec(sqlParser.Select_star_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_star_spec"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSelect_value_spec(sqlParser.Select_value_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_value_spec"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSelect_list_spec(sqlParser.Select_list_specContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_list_spec"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSelect_item(sqlParser.Select_itemContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.select_item"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitFrom_clause(sqlParser.From_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.from_clause"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitJoinCollectionExpression(sqlParser.JoinCollectionExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>JoinCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitAliasedCollectionExpression(sqlParser.AliasedCollectionExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>AliasedCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitArrayIteratorCollectionExpression(sqlParser.ArrayIteratorCollectionExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ArrayIteratorCollectionExpression</c>
            labeled alternative in <see cref="M:sqlParser.collection_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitInputPathCollection(sqlParser.InputPathCollectionContext)">
            <summary>
            Visit a parse tree produced by the <c>InputPathCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSubqueryCollection(sqlParser.SubqueryCollectionContext)">
            <summary>
            Visit a parse tree produced by the <c>SubqueryCollection</c>
            labeled alternative in <see cref="M:sqlParser.collection"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitStringPathExpression(sqlParser.StringPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>StringPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitEpsilonPathExpression(sqlParser.EpsilonPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>EpsilonPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitIdentifierPathExpression(sqlParser.IdentifierPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>IdentifierPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitNumberPathExpression(sqlParser.NumberPathExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>NumberPathExpression</c>
            labeled alternative in <see cref="M:sqlParser.path_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitWhere_clause(sqlParser.Where_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.where_clause"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitGroup_by_clause(sqlParser.Group_by_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.group_by_clause"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitOrder_by_clause(sqlParser.Order_by_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.order_by_clause"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitOrder_by_items(sqlParser.Order_by_itemsContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.order_by_items"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitOrder_by_item(sqlParser.Order_by_itemContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.order_by_item"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSort_order(sqlParser.Sort_orderContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.sort_order"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitOffset_limit_clause(sqlParser.Offset_limit_clauseContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.offset_limit_clause"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitOffset_count(sqlParser.Offset_countContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.offset_count"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitLimit_count(sqlParser.Limit_countContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.limit_count"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitLogicalScalarExpression(sqlParser.LogicalScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>LogicalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitConditionalScalarExpression(sqlParser.ConditionalScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ConditionalScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitCoalesceScalarExpression(sqlParser.CoalesceScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>CoalesceScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitBetweenScalarExpression(sqlParser.BetweenScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>BetweenScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitLogical_scalar_expression(sqlParser.Logical_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.logical_scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitIn_scalar_expression(sqlParser.In_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.in_scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitLike_scalar_expression(sqlParser.Like_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.like_scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitEscape_expression(sqlParser.Escape_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.escape_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitBinary_scalar_expression(sqlParser.Binary_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.binary_scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitMultiplicative_operator(sqlParser.Multiplicative_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.multiplicative_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitAdditive_operator(sqlParser.Additive_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.additive_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitRelational_operator(sqlParser.Relational_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.relational_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitEquality_operator(sqlParser.Equality_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.equality_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitBitwise_and_operator(sqlParser.Bitwise_and_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.bitwise_and_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitBitwise_exclusive_or_operator(sqlParser.Bitwise_exclusive_or_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.bitwise_exclusive_or_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitBitwise_inclusive_or_operator(sqlParser.Bitwise_inclusive_or_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.bitwise_inclusive_or_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitString_concat_operator(sqlParser.String_concat_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.string_concat_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitUnary_scalar_expression(sqlParser.Unary_scalar_expressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.unary_scalar_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitUnary_operator(sqlParser.Unary_operatorContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.unary_operator"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitSubqueryScalarExpression(sqlParser.SubqueryScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>SubqueryScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitPropertyRefScalarExpressionBase(sqlParser.PropertyRefScalarExpressionBaseContext)">
            <summary>
            Visit a parse tree produced by the <c>PropertyRefScalarExpressionBase</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitFunctionCallScalarExpression(sqlParser.FunctionCallScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>FunctionCallScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitLiteralScalarExpression(sqlParser.LiteralScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>LiteralScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitObjectCreateScalarExpression(sqlParser.ObjectCreateScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ObjectCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitParenthesizedScalarExperession(sqlParser.ParenthesizedScalarExperessionContext)">
            <summary>
            Visit a parse tree produced by the <c>ParenthesizedScalarExperession</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitParameterRefScalarExpression(sqlParser.ParameterRefScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ParameterRefScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitArrayCreateScalarExpression(sqlParser.ArrayCreateScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ArrayCreateScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitExistsScalarExpression(sqlParser.ExistsScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ExistsScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitArrayScalarExpression(sqlParser.ArrayScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ArrayScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitMemberIndexerScalarExpression(sqlParser.MemberIndexerScalarExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>MemberIndexerScalarExpression</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitPropertyRefScalarExpressionRecursive(sqlParser.PropertyRefScalarExpressionRecursiveContext)">
            <summary>
            Visit a parse tree produced by the <c>PropertyRefScalarExpressionRecursive</c>
            labeled alternative in <see cref="M:sqlParser.primary_expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitScalar_expression_list(sqlParser.Scalar_expression_listContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.scalar_expression_list"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitObject_property_list(sqlParser.Object_property_listContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.object_property_list"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitObject_property(sqlParser.Object_propertyContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.object_property"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:sqlBaseVisitor`1.VisitLiteral(sqlParser.LiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:sqlParser.literal"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
    </members>
</doc>
